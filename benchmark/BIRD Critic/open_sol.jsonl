{"instance_id": "PostgreSQL_0", "sol_sql": ["SELECT DISTINCT account_id FROM \"order\" GROUP BY account_id HAVING COUNT(order_id) > 1 AND (MAX(amount) - MIN(amount)) > 12000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_1", "sol_sql": ["SELECT to_char(CreationDate, 'FMHH:MI:SS') FROM comments;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_2", "sol_sql": ["\n    CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER\n    AS $$\n    BEGIN \n        UPDATE loan_summary\n        SET total_loan_count = ( \n            SELECT COUNT(*) \n            FROM loan \n            WHERE loan.account_id = loan_summary.account_id\n              AND loan.status = 'A') \n        WHERE loan_summary.account_id = NEW.account_id; \n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;\n    ", "\n    CREATE TRIGGER tr_total_loans AFTER UPDATE OF status ON loan FOR EACH ROW EXECUTE PROCEDURE total_loans();\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT account_id, total_loan_count FROM loan_summary ORDER BY account_id LIMIT 1;\"], db_name,conn)\n    account_id, loan_count = res[0][0], res[0][1]\n    res, _, _ = execute_queries([f\"SELECT loan_id, account_id FROM loan WHERE account_id = {account_id} AND status = 'A' LIMIT 1;\"], db_name,conn)\n    loan_id = res[0][0]\n    check_sql = [f\"UPDATE loan SET status = 'B' WHERE loan_id = {loan_id};\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT total_loan_count FROM loan_summary WHERE account_id = {account_id};\"], db_name,conn)\n    new_count = res[0][0]\n    assert new_count == (loan_count - 1), f\"The trigger does not work.\"\n"]}
{"instance_id": "PostgreSQL_3", "sol_sql": ["ALTER TYPE buildupplayspeedclass_enum ADD VALUE 'Very Fast';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT id FROM team_attributes LIMIT 1;\"]\n    res, _, _ = execute_queries(queries,  db_name, conn)\n    team_id = res[0][0]\n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'Very Fast' WHERE id = {team_id};\"]\n    _, exec_err, time_err = execute_queries(queries, db_name, conn)\n    assert exec_err == False\n    \n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'TEST' WHERE id = {team_id};\"]\n    res, exec_err, _ = execute_queries(queries, db_name, conn)\n    assert exec_err == True\n"]}
{"instance_id": "PostgreSQL_4", "sol_sql": ["CREATE UNIQUE INDEX unique_name_location ON event(event_name, location, event_date) WHERE coalesce(event_name, location) is not null;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_queries = [\n        \"\"\"\n        INSERT INTO event (event_id, event_name, location, event_date)\n        VALUES ('test1', 'test_name', 'test_location', 'test_date');\n        \"\"\"\n    ]\n    execute_queries(check_queries, db_name, conn)\n    \n    check_queries = [\n        \"\"\"\n        insert into event (event_id, event_name, location, event_date)\n\n        values('test2', 'test_name', 'test_location', 'test_date')\n        on conflict (event_name, location, event_date)        \n        where coalesce(event_name, location) is not null \n        do update set\n            event_id = excluded.event_id,\n            event_name = excluded.event_name,\n            location = excluded.location,\n            event_date = excluded.event_date \"\"\"\n    ]\n    res, exec_err, _ = execute_queries(check_queries, db_name, conn)\n    assert exec_err == False\n    queries = [\"SELECT event_id, event_name, location, event_date FROM event WHERE event_name = 'test_name';\"]\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert len(res) == 1\n    assert res[0][0] == 'test2'\n"]}
{"instance_id": "PostgreSQL_5", "sol_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT customerid, transactionid FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    JOIN customers c ON c.customerid = sub.customerid WHERE transactions_1k.transactionid = sub.transactionid RETURNING transactions_1k.transactionid, c.Segment;\n   "], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    assert pred_query_result == [(947, \"SME\"), (988, \"KAM\")]\n    assert check_sql_function_usage(pred_sqls, [\"RETURNING\"]) == 1"]}
{"instance_id": "PostgreSQL_6", "sol_sql": ["SELECT users.Id, COUNT(posts.Id) FILTER (WHERE AnswerCount > 0) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_7", "sol_sql": ["DROP TABLE IF EXISTS users CASCADE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_users_table = execute_queries([\"SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'users';\"], 'codebase_community',conn)[0]\n    assert test_users_table[0][0] == 0, 'Users table should be dropped.'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_posts_lasteditoruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_1';\"], 'codebase_community',conn)[0] \n    assert test_posts_lasteditoruserid_fkey[0][0] == 0, 'Foreign key posts_lasteditoruserid_fkey should be dropped.'\n    test_posts_owneruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_2';\"], 'codebase_community',conn)[0] \n    assert test_posts_owneruserid_fkey[0][0] == 0, 'Foreign key posts_owneruserid_fkey should be dropped.'\n"]}
{"instance_id": "PostgreSQL_8", "sol_sql": ["WITH RECURSIVE nodes AS (SELECT u.id, r.ref FROM users u CROSS JOIN LATERAL (VALUES (u.ref1), (u.ref2)) r(ref)), edges AS (SELECT DISTINCT n1.id AS id1, n2.id AS id2 FROM nodes n1 INNER JOIN nodes n2 ON n1.ref = n2.ref), rcte AS (SELECT id1, id2, ARRAY[id1] AS visited FROM edges WHERE id1 = id2 UNION ALL SELECT r.id1, e.id2, r.visited || e.id2 FROM rcte r INNER JOIN edges e ON e.id1 = r.id2 WHERE e.id2 <> ALL(r.visited)), groups AS (SELECT id1 AS id, ARRAY_AGG(DISTINCT id2 ORDER BY id2) AS ids FROM rcte GROUP BY id1) SELECT g.ids, array_agg(DISTINCT u.username) AS usernames, array_agg(DISTINCT u.ref1) AS refs1, CASE WHEN g.ids IS NULL THEN array_agg(DISTINCT a.owner) ELSE array_agg(DISTINCT u.ref2) END AS refs2, array_agg(DISTINCT a.id) AS asset_ids, COUNT(DISTINCT a.id) AS asset_count FROM assets a LEFT JOIN users u ON a.owner IN (u.ref1, u.ref2) LEFT JOIN groups g ON g.id = u.id GROUP BY g.ids;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_9", "sol_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ), CTE2 AS ( SELECT link_to_event, COUNT(budget_id) AS count FROM budget GROUP BY link_to_event) SELECT CTE.link_to_event, CTE.count AS newCount, CTE2.count AS oldCount FROM CTE2 JOIN CTE ON CTE2.link_to_event = CTE.link_to_event WHERE CTE2.count != CTE.count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_10", "sol_sql": ["INSERT INTO attendance (link_to_event, link_to_member, attend) VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1) ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET attend = 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    test_query_result_1 = execute_queries([\"SELECT attend FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi' AND link_to_member = 'rec280Sk7o31iG0Tx'\"], 'student_club', conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} rows.'\n    assert test_query_result_1[0][0] == 1, f'Expected attend is updated to 1, but found it is {test_query_result_1[0][0]}'\n    test_query_result_2 = execute_queries([\"SELECT * FROM attendance WHERE attend = 1\"], 'student_club', conn)[0]\n    assert test_query_result_2[0][0] == 'recEVTik3MlqbvLFi', f'Expected recEVTik3MlqbvLFi, but found {test_query_result_2[0][0]}'\n    assert test_query_result_2[0][1] == 'rec280Sk7o31iG0Tx', f'Expected rec280Sk7o31iG0Tx, but found {test_query_result_2[0][1]}'"]}
{"instance_id": "PostgreSQL_11", "sol_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE varchar(30) \n    USING date::varchar;\n    ", "\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE timestamp \n    USING date::timestamp;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n    \"\"\"\n    SELECT  data_type\n    FROM information_schema.columns\n    WHERE table_name = 'account'\n    AND column_name = 'date';\n    \"\"\"\n    ]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    data_type = res[0][0]\n    assert 'timestamp' in data_type\n    "]}
{"instance_id": "PostgreSQL_12", "sol_sql": ["\n    select t1.*\n    from cards t1\n    join\n    (\n        SELECT min(id) as id\n        FROM cards\n        GROUP BY artist\n    ) t2 on t1.id = t2.id\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_13", "sol_sql": ["SELECT *\nFROM transactions_1k\nWHERE CustomerID = 3\n  AND Date = '2012-08-24'\n\nUNION ALL\n\nSELECT *\nFROM transactions_1k\nWHERE CustomerID = 7626\n  AND Date = '2012-08-24'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM transactions_1k\n    WHERE CustomerID = 3\n      AND Date = '2012-08-24'\n  );\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_14", "sol_sql": ["SELECT 'SELECT ' || STRING_AGG('a.' || column_name, ', ') || ' FROM account AS a' FROM information_schema.columns WHERE table_name = 'account' AND table_schema = 'public' AND column_name NOT IN ('account_id', 'date');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_2 = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_2 = execute_queries(sol_sqls, db_name, conn)\n    pred_sqls_2 = remove_distinct(pred_sqls_2[0][0])\n    sol_sqls_2 = remove_distinct(sol_sqls_2[0][0])\n    result = ex_base(pred_sqls_2, sol_sqls_2, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_15", "sol_sql": ["SELECT *\nFROM\n(\n  SELECT DISTINCT ON (account_id) *\n  FROM\n  (\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        0 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n        AND l.date >= (NOW() - INTERVAL '48 hours')\n      ORDER BY l.date DESC NULLS LAST\n      LIMIT 6\n    )\n    UNION\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        1 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n    )\n  ) t\n  ORDER BY account_id, priority\n) t\nORDER BY priority, loan_date DESC;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": "PostgreSQL_16", "sol_sql": ["SELECT json_agg(events_array) AS all_events\nFROM (\n  SELECT \n    json_agg(\n      json_build_object(\n        'link_to_member', link_to_member,\n        'link_to_event',  link_to_event\n      )\n    ) AS events_array\n  FROM attendance\n  GROUP BY link_to_event\n) sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def compare_array_of_arrays(arr1, arr2):\n        assert arr1 == arr2, \"The two array-of-array structures do not match.\"\n        return 1\n    \n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = compare_array_of_arrays(pred_query_result[0][0][0], sol_query_result[0][0][0])\n    return result"]}
{"instance_id": "PostgreSQL_17", "sol_sql": ["SELECT generate_series(\n  EXTRACT(YEAR FROM MIN(date)::timestamptz AT TIME ZONE 'UTC')::int,\n  EXTRACT(YEAR FROM MAX(date)::timestamptz AT TIME ZONE 'UTC')::int\n)::text AS the_year\nFROM loan;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": "PostgreSQL_18", "sol_sql": ["SELECT *, MAX(amount) OVER (PARTITION BY account_id) \"max\" FROM loan"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_19", "sol_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(101) GENERATED ALWAYS AS  (CASE WHEN first_name IS NULL THEN last_name WHEN last_name  IS NULL THEN first_name ELSE first_name || ' ' || last_name END) STORED, PRIMARY KEY (client_id) );"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'client_information';\"], db_name, conn)[0]\n    assert test_query_result_1[0][0] == 'client_information' , f\"Table client_information not found in database {test_query_result_1}.\"\n    insert_sql = execute_queries([\"INSERT INTO client_information (first_name, last_name) VALUES ('aaa', 'bbb');\"], db_name, conn);\n    test_query_result_2 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_2 == [('aaa bbb',)], f\"Full name not generated correctly. Found {test_query_result_2}\"\n    update_sql = execute_queries([\"UPDATE client_information SET last_name = 'ccc' WHERE first_name = 'aaa'\"], db_name, conn)\n    test_query_result_3 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_3 == [('aaa ccc',)], f\"Full name not generated correctly. Found {test_query_result_3}\""]}
{"instance_id": "PostgreSQL_20", "sol_sql": ["WITH ins AS (INSERT INTO cards (uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT (uuid) DO UPDATE SET uuid = NULL WHERE FALSE RETURNING id) SELECT id FROM ins UNION ALL SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' LIMIT 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][0] is not None, 'The returned ID should not be None'\n    test_pred_query_result_1 = execute_queries([\"SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c';\"], db_name, conn)[0]\n    assert pred_query_result[0][0] == test_pred_query_result_1[0][0], f'Expected ID to match, but found {pred_query_result[0][0]} and {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": "PostgreSQL_21", "sol_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    today = execute_queries([\"SELECT CURRENT_DATE\"], db_name, conn)[0][0][0]\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][4] == 'UPDATE', f'Expected operation_type to be UPDATE, but found {pred_query_result[0][4]}'\n    assert pred_query_result[0][3] == today, f'Expected date is updated to today {today}, but found {pred_query_result[0][3]}'\n    test_query_result_1 = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (22222, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;\"], db_name, conn)[0]\n    assert test_query_result_1[0][4] == 'INSERT', f'Expected operation_type to be INSERT, but found {test_query_result_1[0][4]}'"]}
{"instance_id": "PostgreSQL_22", "sol_sql": ["SELECT (MAX(releaseDate) - MIN(releaseDate)) + 1 AS cnt, MIN(releaseDate) AS date_min, MAX(releaseDate) AS date_max FROM (SELECT x.*, SUM(i) OVER(ORDER BY releaseDate) AS g FROM (SELECT t.*, CASE WHEN releaseDate > LAG(releaseDate) OVER(ORDER BY releaseDate) + 1 THEN 1 ELSE 0 END AS i FROM sets_releaseInfo t) x) y GROUP BY g;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_23", "sol_sql": ["WITH RECURSIVE path_cte AS (SELECT id, id::text AS Path, id AS FirstID, 1 AS Lvl FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.id::text || ' --> ' || cte.Path, cte.FirstId, cte.Lvl + 1 FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT DISTINCT ON (FirstID) Path FROM path_cte ORDER BY FirstID, Lvl DESC, id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_24", "sol_sql": ["CREATE OR REPLACE FUNCTION what_quarter_is(date_in DATE, start_mon_in INTEGER DEFAULT 1) RETURNS INTEGER LANGUAGE sql AS $$ WITH RECURSIVE qtrs(mq, q, m, c) AS (SELECT 1, 1, start_mon_in, 1 UNION ALL SELECT mq % 3 + 1, CASE WHEN mq % 3 + 1 = 1 THEN q + 1 ELSE q END, CASE WHEN m = 12 THEN 1 ELSE m + 1 END, c + 1 FROM qtrs WHERE c < 12) SELECT q FROM qtrs WHERE m = EXTRACT(MONTH FROM date_in); $$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT proname, proargnames, prorettype::regtype, prosrc FROM pg_proc WHERE proname = 'what_quarter_is';\"], db_name, conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} row(s).'\n    test_query_result_2 = execute_queries([\"SELECT what_quarter_is('2024-01-01', 4)\"], db_name, conn)[0]\n    assert test_query_result_2[0][0] == 4, f'Expected 4, but found {test_query_result_2[0][0]}'\n    test_query_result_3 = execute_queries([\"SELECT what_quarter_is('2023-07-01', 2)\"], db_name, conn)[0]\n    assert test_query_result_3[0][0] == 2, f'Expected 2, but found {test_query_result_3[0][0]}.'"]}
{"instance_id": "PostgreSQL_25", "sol_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table, a.attname as base_col, (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table, UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col, pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey) WHERE c.confrelid = (select oid from pg_class where relname = 'users') AND c.confrelid!=c.conrelid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_26", "sol_sql": ["SELECT bank, first_value(bank) over (partition by account_id order by date rows between current row and unbounded following) as next_bank FROM trans WHERE bank is not null ORDER BY account_id, date;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_27", "sol_sql": ["SELECT t1.team_api_id, t1.team_short_name, t2.buildUpPlaySpeed FROM Team t1 INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_28", "sol_sql": ["WITH years AS ( SELECT date_trunc('year', date) as year, COUNT(*) as count FROM trans GROUP BY 1 UNION ALL SELECT date_trunc('year', date) as year, COUNT(*) as count FROM loan GROUP BY 1 ) SELECT year, SUM(count) as count FROM years GROUP BY year ORDER BY year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_29", "sol_sql": ["WITH gen_transactions AS ( SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER)) ), shuffle AS ( SELECT CustomerID, Amount, row_number() OVER (ORDER BY CustomerID, Amount) AS rn FROM gen_transactions ) SELECT CustomerID, Amount FROM shuffle WHERE rn <= 5 ORDER BY rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_30", "sol_sql": ["\nINSERT INTO card_information(price)\nSELECT jsonb_agg(s.elements)\nFROM (\n  SELECT jsonb_array_elements(price) FROM card_information\n) AS s(elements);\n\nSELECT * FROM card_information;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    assert isinstance(concatenated_json, list), f'Expected result to be a list, but found {type(concatenated_json)}'   \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_json_length = 9\n    assert len(concatenated_json) == expected_json_length, f'Expected {expected_json_length} elements, but found {len(concatenated_json)} elements'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_values = [{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}, {\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}, {\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "]}
{"instance_id": "PostgreSQL_31", "sol_sql": ["\nSELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency\nFROM (\n    SELECT DISTINCT ON (t.k_symbol) \n           t.k_symbol, t.operation, t.amount, t.balance, t.account_id, t.date\n    FROM trans t\n    WHERE t.account_id = 1\n    AND t.type = 'PRIJEM'\n    ORDER BY t.k_symbol, t.date\n) t\nINNER JOIN account a ON t.account_id = a.account_id LIMIT 100\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_UROK = [i for i, row in enumerate(pred_query_result) if row[0] == 'UROK']\n    row_n = row_with_UROK[0]\n    assert pred_query_result[row_n][1] is None, f'Expected operation to be NULL, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 19, f'Expected amount to be 19, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 17298, f'Expected balance to be 17298, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_NULL = [i for i, row in enumerate(pred_query_result) if row[0] is None]\n    row_n = row_with_NULL[0]\n    assert pred_query_result[row_n][1] == 'VKLAD', f'Expected operation to be VKLAD, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 1000, f'Expected amount to be 1000, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 1000, f'Expected balance to be 1000, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    "]}
{"instance_id": "PostgreSQL_32", "sol_sql": ["\nWITH cte AS (\n    SELECT user_id, \n           TO_DATE(purchase_date || '-01','YYYY-MM-DD') AS date_as_date\n    FROM purchase\n), islands AS ( \n    SELECT *, \n           CASE WHEN LAG(date_as_date) OVER(PARTITION BY user_id ORDER BY date_as_date) + INTERVAL '1 month' <> date_as_date\n                THEN 1 ELSE 0 \n           END AS new_partition\n    FROM cte\n), partitioned_islands AS (\n    SELECT user_id, \n           SUM(new_partition) OVER(PARTITION BY user_id ORDER BY date_as_date) AS partitions\n    FROM islands\n), count_per_island AS (\n    SELECT COUNT(*) AS num_consecutive_dates\n    FROM partitioned_islands\n    GROUP BY user_id, partitions\n    ORDER BY ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY COUNT(*) DESC)\n    FETCH FIRST 1 ROWS WITH TIES\n)\nSELECT num_consecutive_dates AS streakLength, \n       COUNT(*) AS numOfOccurrences  \nFROM count_per_island\nGROUP BY streakLength\nORDER BY streakLength DESC\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 5, f'Expected longest streak length to be 5, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == 1, f'Expected 1 user with longest streak of 5 months, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][0] == 4, f'Expected longest streak length to be 4, but found {pred_query_result[1][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == 2, f'Expected 2 users with longest streak of 4 months, but found {pred_query_result[1][1]}'\n    "]}
{"instance_id": "PostgreSQL_33", "sol_sql": ["\nWITH tab_with_cardid AS (\n    SELECT *, \n           REGEXP_REPLACE(cardid, '([^-]+)-[^-]+-(.*)', '\\1-\\2') AS pure_cardid\n    FROM card_info\n),\nranked_visits AS (\n    SELECT *, \n           ROW_NUMBER() OVER (PARTITION BY pure_cardid ORDER BY type) AS rn\n    FROM tab_with_cardid\n)\nSELECT cardid, pure_cardid, type\nFROM ranked_visits\nWHERE rn = 1\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == '1234-HIJK', f'Expected ci_ku to be 1234-HIJK, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][2] == 'A', f'Expected l1m_visits to be A, but found {pred_query_result[0][2]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == '56457-DF-GH-TC', f'Expected ci_ku to be 56457-DF-GH-TC, but found {pred_query_result[1][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][2] == 'D', f'Expected l1m_visits to be D, but found {pred_query_result[1][2]}'\n"]}
{"instance_id": "PostgreSQL_34", "sol_sql": ["SELECT player_api_id, date, overall_rating FROM Player_Attributes ORDER BY ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date DESC) FETCH FIRST 1 ROWS WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_35", "sol_sql": ["CREATE OR REPLACE FUNCTION get_user_ages() RETURNS setof numeric AS $BODY$ DECLARE curr_age  text; BEGIN FOR curr_age IN SELECT Age FROM users LOOP BEGIN RETURN NEXT curr_age::numeric; EXCEPTION WHEN OTHERS THEN NULL; END; END LOOP; END $BODY$  LANGUAGE plpgsql; SELECT * FROM get_user_ages();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT count(*) FROM users;\"], db_name, conn)\n    ori_count = res[0][0]\n    res, _, _ = execute_queries([\"SELECT count(*) FROM get_user_ages();\"], db_name, conn)\n    next_count = res[0][0]\n    assert next_count ==  (ori_count-1), f'Expected 40325 row in get_user_ages table, got {next_count}'\n    res,_, _ = execute_queries([\"SELECT count(get_user_ages) FROM get_user_ages() where get_user_ages = 31 GROUP BY get_user_ages order by get_user_ages;\"], db_name,conn)\n    init_res = res[0][0]\n    res, _, _ = execute_queries([\"select count(age) from users where age = '31' group by age order by age ;\"], db_name,conn)\n    other_res = res[0][0]\n    assert init_res == other_res, f'Expected same result, got {init_res} and {other_res}'\n    \n"]}
{"instance_id": "PostgreSQL_36", "sol_sql": ["CREATE OR REPLACE FUNCTION profileTrigger() RETURNS TRIGGER AS $profile_table$ begin insert into profiles (id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), strpos(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), '.')-1);return new; end; $profile_table$ LANGUAGE plpgsql; CREATE TRIGGER profile_table AFTER INSERT ON users FOR EACH ROW EXECUTE PROCEDURE profileTrigger();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_sql = [\"INSERT INTO users VALUES (341111,185,'2010-07-19 19:11:11','Christopher D. Long','2014-09-13 00:02:35','http://angrystatistician.blogspot.com','Versailles, KY','<p>Consulting analyst for the San Diego Padres, Houston Rockets.</p><p>Twitter:</a></p><p>LinkedIn/p>',27,23,0,509455,NULL,'http://i.stack.imgur.com/km1pr.jpg')\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([\"SELECT * FROM profiles LIMIT 1;\"], db_name,conn)\n    res_id, res_CreationDate, res_WebsiteUrl = res[0][0], res[0][1], res[0][2]\n    assert len(res) == 1, f\"Expected 1 row in profiles table, got {len(res)}\"\n    assert res_id == '341111', f\"Expected id to be '341111', got {res_id}\"\n    assert res_WebsiteUrl == 'angrystatistician', f\"Expected WebsiteUrl to be 'angrystatistician', got {res_WebsiteUrl}\"\n    \n"]}
{"instance_id": "PostgreSQL_37", "sol_sql": ["DROP INDEX IF EXISTS idx_trans_covering; CREATE INDEX idx_trans_covering ON trans (account_id, bank, type) INCLUDE (trans_id, date, amount); SELECT t.trans_id, t.account_id, t.date, t.type, t.amount FROM trans t WHERE t.bank = 'AB' AND t.type IN ('PRIJEM','VYDAJ') AND EXISTS (SELECT 1 FROM account a WHERE a.account_id = t.account_id AND a.district_id = 18);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_38", "sol_sql": ["SELECT * FROM cards WHERE  3 = (CASE WHEN availability = 'paper' THEN 1 ELSE 0 END) + (CASE WHEN bordercolor = 'black' THEN 1 ELSE 0 END) + (CASE WHEN rarity = 'uncommon' THEN 1 ELSE 0 END) + (CASE WHEN types = 'Creature' THEN 1 ELSE 0 END);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_39", "sol_sql": ["WITH j AS (INSERT INTO event (event_id, event_name, event_date, type, notes, location, status) VALUES ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') ON CONFLICT (event_id) DO UPDATE SET event_id = event.event_id RETURNING xmax = 0 AS inserted, *) INSERT INTO failure (event, member) SELECT event_id, 'rec280Sk7o31iG0Tx' FROM j WHERE NOT inserted RETURNING *;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1, _, _ = execute_queries([\"SELECT event FROM failure;\"], db_name, conn)\n    pred_query_result_2, _, _  = execute_queries([\"SELECT member FROM failure;\"], db_name, conn)\n    assert len(pred_query_result_1) == 1, f'Expected 1 rows, but found {len(pred_query_result_1)} rows' \n    assert len(pred_query_result_2) == 1, f'Expected 1 rows, but found {len(pred_query_result_2)} rows'\n    assert pred_query_result_1[0][0] == 'recAlAwtBZ0Fqbr5K', f'Expected event ID to match, but found {pred_query_result_1[0][0]}'\n    assert pred_query_result_2[0][0] == 'rec280Sk7o31iG0Tx', f'Expected member ID to match, but found {pred_query_result_2[0][0]}'\n    "]}
{"instance_id": "PostgreSQL_40", "sol_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ LANGUAGE plpgsql;CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([f\"SELECT player_name FROM player WHERE id = 1;\"], db_name,conn)\n    old_p_name = res[0][0]\n    check_sql = [f\"UPDATE player SET player_name = {old_p_name} WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT * FROM player_audits\"], db_name, conn)\n    assert len(res) == 0, f\"The trigger conditioning does not work.\"\n    \n    check_sql = [f\"UPDATE player SET player_name = 'James Higginsons' WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT old_player_name FROM player_audits LIMIT 1\"], db_name,conn)\n    old_name = res[0][0]\n    assert old_name == 'Aaron Appindangoye', f\"The trigger does not work.\"\n"]}
{"instance_id": "PostgreSQL_41", "sol_sql": ["\nSELECT\n    ea.MemberID,\n    MAX(CASE WHEN ea.EventType = 'Game' THEN ea.AttendanceDate END) AS Latest_Game_Date,\n    SUM(CASE WHEN ea.EventType = 'Game' THEN 1 ELSE 0 END) AS Total_Game_Attendance,\n    MAX(CASE WHEN ea.EventType = 'Workshop' THEN ea.AttendanceDate END) AS Latest_Workshop_Date,\n    SUM(CASE WHEN ea.EventType = 'Workshop' THEN 1 ELSE 0 END) AS Total_Workshop_Attendance,\n    COUNT(*) AS Total_Attendance\nFROM (\n    SELECT MemberID, EventType, AttendanceDate\n    FROM event_attendance\n    WHERE EventType IN ('Game', 'Workshop')\n) ea\nGROUP BY ea.MemberID\nORDER BY ea.MemberID;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n\n    ", "\nimport datetime\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected MemberID 1 in the first row, but found {pred_query_result[0][0]}'\n    pred_game_date = pred_query_result[0][1]\n    pred_game_date_str = pred_game_date.strftime('%Y-%m-%d')\n    expected_date_str = '2023-02-20'\n    assert pred_game_date_str == expected_date_str, f'Expected Game_AttendanceDate 2023-02-20 for MemberID 1, but found {pred_game_date_str}'\n    assert pred_query_result[1][4] == 1, f'Expected Workshop_Attendances 1 for MemberID 2, but found {pred_query_result[1][4]}'\n\n    assert pred_query_result[0][5] == 6, f'Expected Total_Attendances 6 for MemberID 1, but found {pred_query_result[0][5]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_42", "sol_sql": ["\nSELECT t.userid, t.tag\nFROM   preference_tag t\nWHERE  NOT EXISTS (\n   SELECT FROM unnest('{%friend%, %cat%}'::text[]) AS p(pattern)\n   WHERE  NOT EXISTS (\n      SELECT FROM unnest(t.tag) AS a(elem)\n      WHERE  a.elem LIKE p.pattern\n      )\n   )\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected id to be 1, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][1] == ['wildcat', 'potato', 'alices-friend'], f\"Expected value to be ['wildcat', 'potato', 'alices-friend'], but found {pred_query_result[2][1]}\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][0] == 4, f'Expected id to be 4, but found {pred_query_result[2][0]}'\n"]}
{"instance_id": "PostgreSQL_43", "sol_sql": ["SELECT * FROM account_info WHERE condition::jsonb @> '[ { \"conditions\": { \"rootcompanyid\": { \"$in\": [5] } } } ]'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} row(s).'\n    assert pred_query_result[0][0] == 1, f'Expected the account_id is 1, but found {pred_query_result[0][0]}'\n    assert pred_query_result[1][0] == 3, f'Expected the account_id is 3, but found {pred_query_result[1][0]}'"]}
{"instance_id": "PostgreSQL_44", "sol_sql": ["CREATE UNIQUE INDEX idx_hero_power_active ON hero_power (hero_id, power_id) WHERE active;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    try:\n        insert_sql_1 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, TRUE);'], db_name, conn)[0];\n        assert False, 'Inserting duplicate id should have raised an error'\n    except Exception as err:\n        assert 'duplicate' in str(err), f'Expected duplicate key error, but found {err}.'\n    check_insertion_result_1 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_1[0][0] == 1, 'Expected only 1 entry for hero_id 1 and power_id 1.'\n    insert_sql_2 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_2 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_2[0][0] == 2, 'Expected two entries for hero_id 1 and power_id 1, one active and one inactive.'\n    insert_sql_3 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_3 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_3[0][0] == 3, 'Expected three entries for hero_id 1 and power_id 1, one active and two inactive.'"]}
{"instance_id": "PostgreSQL_45", "sol_sql": ["SELECT DISTINCT o1.user_id, o1.email FROM orders o1 WHERE (o1.segment = 'luxury' AND o1.destination = 'New York') OR (o1.segment = 'luxury' AND o1.destination = 'London') OR (o1.segment = 'basic' AND o1.destination = 'New York' AND o1.user_id IN (SELECT o2.user_id FROM orders o2 WHERE o2.segment = 'basic' AND o2.destination = 'New York' GROUP BY o2.user_id HAVING SUM(o2.revenue) > 2000)) EXCEPT SELECT DISTINCT o3.user_id, o3.email FROM orders o3 WHERE o3.destination = 'Miami'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_46", "sol_sql": ["SELECT version FROM cars ORDER BY CAST(SUBSTRING(version FROM '^[0-9]+') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.([0-9]+)') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, CASE WHEN version LIKE '%-%' THEN SUBSTRING(version FROM '-(.*)') ELSE '' END DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_47", "sol_sql": ["SELECT p.patient_id, array_agg(DISTINCT p.medication_id ORDER BY p.medication_id) AS medications FROM prescriptions p WHERE p.patient_id IN (SELECT patient_id FROM prescriptions WHERE medication_id = 1)GROUP BY p.patient_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_48", "sol_sql": ["SELECT d.driverId, COALESCE(SUM(r.points), 0) AS total_points FROM drivers d LEFT JOIN results r ON d.driverId = r.driverId GROUP BY d.driverId"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_49", "sol_sql": ["SELECT \n    sqA.alignment_count     AS total_by_alignment,\n    A.alignment             AS alignment,\n    R.race                  AS race,\n    sqAR.alignment_race_count AS count_by_alignment_race\nFROM\n    (\n       SELECT\n           alignment_id,\n           COUNT(*) AS alignment_count\n       FROM superhero\n       GROUP BY alignment_id\n    ) sqA\n\n    INNER JOIN\n    (\n       SELECT\n           alignment_id,\n           race_id,\n           COUNT(*) AS alignment_race_count\n       FROM superhero\n       GROUP BY alignment_id, race_id\n    ) sqAR ON sqA.alignment_id = sqAR.alignment_id\n\n    INNER JOIN alignment A ON sqA.alignment_id = A.id\n\n    INNER JOIN race R ON sqAR.race_id = R.id\nORDER BY\n    A.alignment,\n    R.race;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_50", "sol_sql": ["select driverId, points, array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred = execute_queries(pred_sqls,db_name,conn)\n    sol = execute_queries(sol_sqls,db_name,conn)\n    assert pred == sol\n    return pred == sol"]}
{"instance_id": "PostgreSQL_51", "sol_sql": ["WITH cte AS (\n    SELECT\n        p.*,\n        CEIL( (ROW_NUMBER() OVER (\n                 PARTITION BY raceId \n                 ORDER BY time::time\n               ) + 1 ) / 2.0\n        ) AS rn\n    FROM pitStops p\n    WHERE raceId = 842\n),\ncte2 AS (\n    SELECT\n        rn,\n        MIN(time::time) AS starttime,\n        MAX(time::time) AS endtime,\n        CAST(MAX(time::time) - MIN(time::time) AS time) AS total_pause\n    FROM cte\n    GROUP BY rn\n)\nSELECT\n    MAX(endtime) AS endtime,\n    MIN(starttime) AS starttime,\n    CAST(SUM(total_pause) AS time) AS total_pit_stop_duration\nFROM cte2;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_52", "sol_sql": ["SELECT json_object_agg(label, groupedMolecules) AS molecules_by_label\nFROM (\n  SELECT label,\n         json_agg(\n           json_build_object(\n             'molecule_id', molecule.molecule_id,\n             'atoms', (\n               SELECT json_agg(\n                 json_build_object(\n                   'atom_id', atom.atom_id,\n                   'element', atom.element\n                 )\n               )\n               FROM atom\n               WHERE atom.molecule_id = molecule.molecule_id\n             ),\n             'bonds', (\n               SELECT json_agg(\n                 json_build_object(\n                   'bond_id', bond.bond_id,\n                   'bond_type', bond.bond_type\n                 )\n               )\n               FROM bond\n               WHERE bond.molecule_id = molecule.molecule_id\n             )\n           )\n         ) AS groupedMolecules\n  FROM molecule\n  GROUP BY label\n) AS sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def json_matches_gold(generated_json, gold_json):\n        # If either object is a string, parse it as JSON\n        if isinstance(generated_json, str):\n            generated_json = json.loads(generated_json)\n        if isinstance(gold_json, str):\n            gold_json = json.loads(gold_json)\n\n        # Return whether the Python structures match exactly\n        return generated_json == gold_json\n    \n    sol = execute_queries(sol_sqls,db_name,conn)\n    pred = execute_queries(pred_sqls,db_name,conn)\n    assert json_matches_gold(sol[0], pred[0])\n    return json_matches_gold(sol[0], pred[0])"]}
{"instance_id": "PostgreSQL_53", "sol_sql": ["SELECT\n    molecule_id,\n    COUNT(DISTINCT CASE WHEN element = 'na' THEN 1 END)         AS na_atoms,\n    COUNT(DISTINCT CASE WHEN element IN ('c', 'cl') THEN molecule_id END) AS c_atoms\nFROM atom\nGROUP BY molecule_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_54", "sol_sql": ["SELECT date_trunc('hour', \"date\"::timestamp), home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY date_trunc('hour', \"date\"::timestamp), home_team_api_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_55", "sol_sql": ["SELECT c.id  FROM clients c INNER JOIN clients_to_groups ctg ON c.id = ctg.client_id AND ctg.group_id IN (1,3,5,6) GROUP BY c.id HAVING  COUNT(CASE WHEN ctg.group_id IN (1,3) THEN 1 END) > 0 AND COUNT(CASE WHEN ctg.group_id IN (5,6) THEN 1 END) > 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_56", "sol_sql": ["SELECT MIN(transaction_date) AS date, club_name, SUM(amount) AS amount FROM (SELECT *, SUM(flag) OVER (PARTITION BY club_name ORDER BY transaction_date) AS grp FROM (SELECT *, COALESCE(SIGN(amount) <> LAG(SIGN(amount)) OVER (PARTITION BY club_name ORDER BY transaction_date), true)::int AS flag FROM club_transactions) t) t GROUP BY club_name, grp ORDER BY club_name, date;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_57", "sol_sql": ["WITH RECURSIVE cte(id, p, js) AS (SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m1.id_module, 'id_parent_module', m1.id_parent_module, 'module_code', m1.module_code, 'name_module', m1.name_module, 'desc_module', m1.desc_module) jsn FROM modules m JOIN modules m1 ON m1.id_parent_module = m.id_module WHERE NOT EXISTS (SELECT 1 FROM modules m2 WHERE m2.id_parent_module = m1.id_module)) t GROUP BY t.id_module, t.id_parent_module UNION ALL SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js) jsn FROM modules m JOIN cte c ON m.id_module = c.p JOIN modules m2 ON m2.id_module = c.id) t GROUP BY t.id_module, t.id_parent_module) SELECT jsonb_pretty(t.result::jsonb) FROM (SELECT json_agg(json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js)) result FROM cte c JOIN modules m2 ON c.id = m2.id_module WHERE c.p IS NULL) t"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_58", "sol_sql": ["SELECT atom_id,(ARRAY_AGG(element ORDER BY edit_id DESC) FILTER (WHERE element IS NOT NULL))[1] AS element,(ARRAY_AGG(molecule_id ORDER BY edit_id DESC)FILTER (WHERE molecule_id IS NOT NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_59", "sol_sql": ["INSERT INTO customers (customerid, segment, currency)\nSELECT DISTINCT ON (customerid, segment, currency) \n       customerid, \n       segment, \n       currency\nFROM (\n    VALUES\n       (3, 'SME', 'EUR'),\n       (1, 'KAM', 'CZK'),\n       (3, 'SME', 'EUR')\n) AS v(customerid, segment, currency)\nON CONFLICT (customerid, segment, currency)\nDO UPDATE \n   SET currency = customers.currency\nRETURNING CustomerID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == [(1,), (3,)]"]}
{"instance_id": "PostgreSQL_60", "sol_sql": ["\nUPDATE disp\nSET addresses = '[{\"PostCode\": null}]'\nWHERE jsonb_typeof(addresses) <> 'array'\n   OR addresses = '[]';\n\nSELECT \n    c.client_id, \n    c.gender, \n    d.disp_id, \n    addr ->> 'PostCode' AS PostCode\nFROM client c\nFULL JOIN disp d ON c.client_id = d.client_id,\njsonb_array_elements(d.addresses) AS addr\nWHERE c.client_id = 100;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_61", "sol_sql": ["-- Correct / Solution SQL\nINSERT INTO loan (\n  account_id,\n  date,\n  amount,\n  duration,\n  payments,\n  status\n)\nVALUES (\n  2,\n  '1996-04-29',\n  30276,\n  12,\n  2523.0,\n  'B'\n)\nON CONFLICT (account_id, date)\nDO UPDATE\n   SET amount = EXCLUDED.amount + 1000;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    This function tests whether the given pred_sqls can fulfill the requirement:\n      \"The 'loan_id' should only increment when a new record is inserted.\"\n    Specifically, if (account_id, date) already exists, we expect to UPDATE instead\n    of inserting a new row or incrementing the loan_id.\n    \n    - We create a fresh 'loan' table with a unique constraint on (account_id, date).\n    - Insert one baseline record that matches the sol_sqls initial amount (30276).\n    - Run the pred_sqls (which presumably does an UPSERT on the same (account_id, date)).\n    - Check if we still have exactly one row with the updated amount (30276 + 1000 = 31276).\n    - If there's more than one row or the amount is not updated to 31276, we fail.\n    \"\"\"\n\n    # 1) Drop the table if it exists, to start fresh\n    drop_sql = [\"DROP TABLE IF EXISTS loan CASCADE;\"]\n    execute_queries(drop_sql, db_name, conn)\n\n    # 2) Create a fresh 'loan' table with a unique constraint on (account_id, date)\n    create_sql = [\"\"\"\n        CREATE TABLE loan (\n            loan_id   SERIAL PRIMARY KEY,\n            account_id INT NOT NULL,\n            date       DATE NOT NULL,\n            amount     INT NOT NULL,\n            duration   INT NOT NULL,\n            payments   DOUBLE PRECISION NOT NULL,\n            status     TEXT NOT NULL,\n            UNIQUE(account_id, date)\n        );\n    \"\"\"]\n    execute_queries(create_sql, db_name, conn)\n\n    # 3) Insert an initial record that we expect to update later\n    #    We use the same baseline amount as sol_sqls (30276) so the final will be 31276.\n    init_insert_sql = [\"\"\"\n        INSERT INTO loan (account_id, date, amount, duration, payments, status)\n        VALUES (2, '1996-04-29', 30276, 12, 2500.0, 'X');\n    \"\"\"]\n    execute_queries(init_insert_sql, db_name, conn)\n\n    # 4) Execute the pred_sqls (the user's upsert logic)\n    execute_queries(pred_sqls, db_name, conn)\n\n    # 5) Check how many rows we have for (account_id=2, date='1996-04-29') \n    check_sql = [\"SELECT loan_id, account_id, date, amount FROM loan WHERE account_id=2 AND date='1996-04-29';\"]\n    rows = execute_queries(check_sql, db_name, conn)[0]\n\n    # 6) Evaluate the result\n    assert len(rows) == 1, (\n        f\"Expected only 1 row for (account_id=2, date='1996-04-29'), but found {len(rows)}. \"\n        \"This likely means the upsert inserted a new row instead of updating.\"\n    )\n\n    loan_id_val, acct_val, date_val, amount_val = rows[0]\n\n    # Amount should be updated from 30276 to 31276 (30276 + 1000).\n    expected_amount = 30276 + 1000\n    assert amount_val == expected_amount, (\n        f\"Expected amount={expected_amount} after update, but got {amount_val}. \"\n        \"This likely means the existing row was not updated correctly (or the conflict logic is wrong).\"\n    )"]}
{"instance_id": "PostgreSQL_62", "sol_sql": ["DELETE FROM cards WHERE ctid IN ( SELECT ctid FROM cards c WHERE NOT EXISTS ( SELECT 1 FROM ( SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL ) n WHERE n.uuid = c.uuid AND n.setCode = c.setCode AND n.rarity = c.rarity AND n.manaCost = c.manaCost ) LIMIT 1000 );"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM (SELECT ctid FROM cards c WHERE NOT EXISTS (SELECT 1 FROM (SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL) n WHERE n.uuid = c.uuid AND n.setCode = c.setCode AND n.rarity = c.rarity AND n.manaCost = c.manaCost) LIMIT 1000) subq;', db_name)[0]\n    assert test_pred_query_result_2[0][0] == 1000, f'Expected count to be 0, but found {test_pred_query_result_2[0][0]}'\n"]}
{"instance_id": "PostgreSQL_63", "sol_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(\n    _tbl regclass, \n    _id text, \n    _row_num text, \n    OUT nullable_columns int, \n    OUT updated_rows int\n) LANGUAGE plpgsql AS $func$\nDECLARE \n    _pk text := quote_ident(_row_num); \n    _sql text;\nBEGIN\n    SELECT INTO _sql, nullable_columns concat_ws(E'\n',\n        'UPDATE ' || _tbl || ' t',\n        'SET (' || string_agg(quote_ident(a.attname), ', ') || ') = ',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')',\n        'FROM (',\n        '   SELECT ' || _pk,\n        '        , ' || string_agg(\n                     format(\n                         'COALESCE(%1$I, MAX(%1$I) OVER (PARTITION BY %2$s ORDER BY %3$s ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)) AS %1$I',\n                         a.attname, _id, _pk\n                     ), \n                     ', '\n                 ),\n        '   FROM ' || _tbl,\n        '   ) u',\n        format('WHERE t.%1$s = u.%1$s', _pk),\n        'AND (' || string_agg('t.' || quote_ident(a.attname), ', ') || ') IS DISTINCT FROM',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')'\n    ), \n    count(*)\n    FROM (\n        SELECT a.attname \n        FROM pg_attribute a \n        WHERE a.attrelid = _tbl \n          AND a.attnum > 0 \n          AND NOT a.attisdropped \n          AND NOT a.attnotnull \n        ORDER BY a.attnum\n    ) a;\n\n    RAISE NOTICE 'Generated SQL: %', _sql;\n\n    IF nullable_columns = 0 THEN \n        RAISE EXCEPTION 'No nullable columns found in table >>%<<', _tbl; \n    ELSIF _sql IS NULL THEN \n        RAISE EXCEPTION 'Generated SQL is NULL. Check table or column logic!';\n    END IF;\n\n    EXECUTE _sql;\n\n    GET DIAGNOSTICS updated_rows = ROW_COUNT; \nEND $func$;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    def execute_sqls(sql_list):\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                try:\n                    cur.execute(sql)\n                    conn.commit()\n                except Exception as e:\n                    conn.rollback()\n                    return str(e)\n        return \"success\"\n\n    def validate_forward_fill(limit=10):\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SELECT t1.trans_id, t1.account_id, t1.amount AS current_amount, t2.amount AS previous_amount\n                FROM trans t1\n                LEFT JOIN trans t2\n                  ON t1.account_id = t2.account_id\n                 AND t1.date > t2.date\n                WHERE t1.amount IS NULL AND t2.amount IS NOT NULL\n                ORDER BY t1.date\n                LIMIT %s;\n            \"\"\", (limit,))\n            rows = cur.fetchall()\n            if rows:\n                return False\n            return True\n\n    def debug_generated_sql():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SET client_min_messages TO NOTICE;\n                DO $$\n                BEGIN\n                    PERFORM f_gap_fill_update('trans', 'account_id', 'trans_id');\n                END $$;\n            \"\"\")\n            cur.execute(\"RESET client_min_messages;\") \n\n    def reset_trans_table():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                UPDATE trans\n                SET amount = CASE\n                    WHEN trans_id = 1 THEN 1000\n                    WHEN trans_id IN (5, 6, 7, 8, 9, 10, 11, 12) THEN NULL\n                    ELSE amount\n                END;\n            \"\"\")\n            conn.commit()\n\n    reset_trans_table()\n    pred_result = execute_sqls(pred_sqls)\n    assert pred_result == \"success\"\n\n    debug_generated_sql()\n    assert validate_forward_fill(), \"Validate forward fill function logic.\"\n\n    return 1"]}
{"instance_id": "PostgreSQL_64", "sol_sql": ["UPDATE card c\nSET disp_id =\n    CASE \n        WHEN c.disp_id = sub.disp_id THEN 1\n        WHEN c.disp_id < sub.disp_id THEN c.disp_id + 1\n        ELSE c.disp_id\n    END\nFROM (\n    SELECT disp_id, type\n    FROM card\n    WHERE disp_id = 41\n) sub\nWHERE c.type = sub.type\n  AND c.disp_id <= sub.disp_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the predicted SQLs\n    _, pred_exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert pred_exec_err == False, \"Error in executing predicted SQLs\"\n\n    # Validate the change\n    query = \"SELECT disp_id FROM card WHERE card_id = 1 AND type = 'gold';\"\n    res, _, _ = execute_queries([query], db_name, conn)\n    assert len(res) == 1, \"No matching record found for card_id = 1 and type = 'gold'\"\n    assert res[0][0] == 10, f\"Expected disp_id to be 10, but got {res[0][0]}\"\n\n    return 1"]}
{"instance_id": "PostgreSQL_65", "sol_sql": ["\n  CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\n    RETURNS SETOF date\n    LANGUAGE SQL\n    IMMUTABLE\n    PARALLEL SAFE\n    ROWS 10\n  AS\n  $function$\n    SELECT generate_series(\n      date_trunc('month', a),\n      date_trunc('month', b),\n      '1 month'\n    );\n  $function$;\n  ", "\n  EXPLAIN VERBOSE\n  SELECT generate_series_monthly('2024-01-01', '2024-05-01');\n  "], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    Checks if pred_sqls (the tested scenario) produces the same \"rows=10\" estimate\n    as sol_sqls (the correct solution), using assert statements.\n\n    :param pred_sqls: list[str] - SQL statements to be tested\n    :param sol_sqls: list[str] - SQL statements that represent the known correct solution\n    :param db_name: str - name of the database to connect to (if needed)\n    :param conn: psycopg2.extensions.connection - an established DB connection\n    :return: None - the function will raise AssertionError if the conditions are not met\n    \"\"\"\n    def run_sql_and_get_explain_rows(sql_list):\n        \"\"\"\n        Executes a list of SQL statements and returns the output rows of the last\n        EXPLAIN statement (if any).\n        \"\"\"\n        rows_output = []\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                cur.execute(sql)\n                # If it is an EXPLAIN statement, fetch and store its result\n                if sql.strip().upper().startswith(\"EXPLAIN\"):\n                    rows_output = cur.fetchall()\n        return rows_output\n\n    # Run the tested SQL and check for \"rows=10\"\n    pred_explain_rows = run_sql_and_get_explain_rows(pred_sqls)\n    pred_has_rows10 = any(\"rows=10\" in str(row) for row in pred_explain_rows)\n\n    assert pred_has_rows10, (\n        \"Expected to find 'rows=10' in the tested scenario's EXPLAIN output, but it was not found.\"\n    )\n\n    return 1"]}
{"instance_id": "PostgreSQL_66", "sol_sql": ["WITH cte AS (\n    SELECT\n        m.*,\n        SUM(\n          CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END\n        ) OVER (ORDER BY m.date) AS grp\n    FROM match AS m\n),\naggregates AS (\n    SELECT\n        grp,\n        MAX(date) FILTER (WHERE home_team_goal = away_team_goal) AS draw_date,\n        1 AS invoiced,\n        SUM(home_team_goal + away_team_goal) AS total_goals\n    FROM cte\n    GROUP BY grp\n)\nSELECT \n    grp,\n    draw_date AS date,\n    invoiced,\n    total_goals AS amount\nFROM aggregates\nWHERE draw_date IS NOT NULL\nORDER BY grp;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_67", "sol_sql": ["WITH last_per_station AS (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY customerid, gasstationid\n      ORDER BY transactionid DESC\n    ) AS rn\n  FROM transactions_1k t\n),\nDataSource AS (\n  SELECT\n    lps.*,\n    CASE WHEN amount < 10 THEN transactionid END AS fail_id,\n    CASE WHEN amount >= 10 THEN transactionid END AS pass_id\n  FROM last_per_station lps\n  WHERE rn = 1\n),\nCalculated AS (\n  SELECT\n    ds.*,\n    MIN(fail_id) OVER (PARTITION BY customerid) AS earliest_fail_id,\n    MAX(pass_id) OVER (PARTITION BY customerid) AS last_pass_id\n  FROM DataSource ds\n)\nSELECT\n  customerid,\n  transactionid,\n  date,\n  time,\n  gasstationid,\n  productid,\n  amount,\n  price\nFROM Calculated\nWHERE\n  (earliest_fail_id IS NOT NULL AND fail_id = earliest_fail_id)\n  OR\n  (earliest_fail_id IS NULL AND pass_id = last_pass_id);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_68", "sol_sql": ["WITH RECURSIVE linked_list(id, parent_id, depth) AS (SELECT id, parent_id, 0 FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id, ll.depth + 1 FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id WHERE depth < 10000) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_69", "sol_sql": ["SELECT * FROM user_actions AS a WHERE a.action = 'SEARCH' AND NOT EXISTS (SELECT 1 FROM user_actions WHERE user_id = a.user_id AND action = 'BUY' AND action_time > a.action_time AND (action_time < (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) OR (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) IS NULL));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_70", "sol_sql": ["SELECT cte.id, c.name FROM (SELECT card_order FROM decks WHERE id = 1) d  CROSS JOIN UNNEST(d.card_order) WITH ORDINALITY cte(id, idx)  INNER JOIN cards c ON c.id = cte.id ORDER BY cte.idx;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_71", "sol_sql": ["SELECT ord.*, prd.price FROM order_cards ord LEFT JOIN LATERAL (SELECT prd.* FROM card_prices prd WHERE prd.card_id = ord.card_id and prd.start_date <= ord.order_date ORDER BY start_date DESC LIMIT 1) prd ON TRUE"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_72", "sol_sql": ["SELECT player_id, cols ->> 'goals' AS goals, cols ->> 'assists' AS assists, cols ->> 'yellow_cards' AS yellow_cards, cols ->> 'red_cards' AS red_cards FROM (SELECT player_id, (SELECT jsonb_object_agg(k, v) FROM unnest(string_to_array(stats_keys, ','), string_to_array(stats_values, ',')) AS x(k, v)) AS cols FROM player_stats) x ORDER BY player_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_73", "sol_sql": ["UPDATE teams_config t SET configurations = (SELECT jsonb_agg(a.elem) FROM jsonb_array_elements(t.configurations) AS a(elem) WHERE (a.elem ->> 'id' = '101') IS NOT TRUE) WHERE t.configurations @> '[{\"id\":101}]';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_sqls_result = execute_queries([\"SELECT * FROM teams_config;\"], db_name, conn)[0]\n    assert test_pred_sqls_result[0][0] == [{'id': 100, 'name': 'testOne', 'settings': 'settingOne'}], f'Expected the object with id = 101 is deleted and only the object with id = 100 is left in the configurations column. But got: {test_pred_sqls_result[0][0]}'\n"]}
{"instance_id": "PostgreSQL_74", "sol_sql": ["SELECT begin_date, end_date, (DATE_PART('year', end_date) - DATE_PART('year', begin_date)) * 12 + DATE_PART('month', end_date) - DATE_PART('month', begin_date) - CASE WHEN begin_date > date_trunc('month', begin_date) THEN 1 ELSE 0 END AS full_calendar_months FROM race_dates;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_75", "sol_sql": ["\n    INSERT INTO new_attendance (\n        link_to_event, \n        link_to_member, date\n    ) VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET\n        date = NOW();\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls,db_name,conn)\n    queries = [\"SELECT * FROM new_attendance WHERE link_to_event = 'reciRZdAqNIKuMC96' AND link_to_member = 'recL94zpn6Xh6kQii';\"]\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    ori_date = res[0][-1]\n    execute_queries(pred_sqls,db_name,conn)\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    new_date = res[0][-1]\n    assert ori_date != new_date\n    "]}
{"instance_id": "PostgreSQL_76", "sol_sql": ["\n        CREATE FUNCTION pg_try_advisory_lock_with_timeout(key bigint) RETURNS boolean\n        SET lock_timeout TO '1s'\n        AS $$\n        BEGIN\n        PERFORM pg_advisory_lock(key);\n        RETURN true;\n        EXCEPTION\n        WHEN lock_not_available OR deadlock_detected THEN\n            RETURN false;\n        END;\n        $$\n        LANGUAGE plpgsql;          \n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT pg_try_advisory_lock_with_timeout(12345);\"]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    print(res)\n    assert res[0][0] == True or res[0][0] == False\n    "]}
{"instance_id": "PostgreSQL_77", "sol_sql": ["\n        SELECT\n            link_to_member,\n            ROUND(SUM(hours)::NUMERIC, -1) AS rounded_hours,\n            RANK() OVER (ORDER BY ROUND(SUM(hours)::NUMERIC, -1) DESC) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_78", "sol_sql": ["\n        SELECT \n            CASE \n                WHEN EXISTS (\n                    SELECT 1 \n                    FROM pg_indexes \n                    WHERE tablename = 'account' \n                    AND indexname = 'ix_account'\n                ) THEN TRUE\n                ELSE FALSE\n            END AS index_exists;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == True\n    queries = [\"DROP INDEX ix_account;\"]\n    execute_queries(queries,db_name,conn)\n    res, _, _ = execute_queries(pred_sqls,db_name,conn)\n    assert res[0][0] == False\n    "]}
{"instance_id": "PostgreSQL_79", "sol_sql": ["\n        drop view findcount;\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n        \"\"\"\n        SELECT \n            CASE \n                WHEN pg_type.typname = 'float8' THEN TRUE \n                ELSE FALSE \n            END AS is_float\n        FROM pg_attribute\n        JOIN pg_class ON pg_attribute.attrelid = pg_class.oid\n        JOIN pg_type ON pg_attribute.atttypid = pg_type.oid\n        WHERE pg_class.relname = 'findcount' \n        AND pg_attribute.attname = 'team_count'\n        AND pg_attribute.attnum > 0;\n        \"\"\"\n    ]\n    \n    res, _, _ = execute_queries(queries,db_name,conn)\n    assert res[0][0] == True\n    "]}
{"instance_id": "PostgreSQL_80", "sol_sql": ["\n        select posttypeid,\n        sum(case when tags like '%bayesian%'\n                or tags like '%distributions%'\n            then 1 else 0 end) as keyword_count\n        from posts\n        group by posttypeid\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == 2\n    assert pred_query_result[0][1] == 1\n    assert pred_query_result[1][0] == 1\n    assert pred_query_result[1][1] == 2\n    "]}
{"instance_id": "PostgreSQL_81", "sol_sql": ["SELECT customerid, transaction, FIRST_VALUE(transaction) OVER (PARTITION BY customerid, transactionid ORDER BY transaction RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS first_transaction, amount, type, transactionid FROM transaction_info WHERE customerid = 1 ORDER BY customerid, transaction"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_82", "sol_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id, MAX(last_update) DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_83", "sol_sql": ["SELECT entity_id, coalesce(height, lag(height, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS height, coalesce(weight, lag(weight, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS weight, updated_at FROM (SELECT entity_id, MAX(CASE WHEN column_id = 'height' THEN value::int END) AS height, MAX(CASE WHEN column_id = 'weight' THEN value::int END) AS weight, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) AS changes;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = 0 if any('json_object_agg' in sql.lower() for sql in pred_sqls) else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": "PostgreSQL_84", "sol_sql": ["WITH RECURSIVE qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL), qr(item, subgroup) AS (SELECT * FROM qr1 UNION ALL SELECT * FROM qr2), cte(item, other, items) AS (SELECT item, item, ARRAY[item] FROM qr UNION ALL SELECT cte.item, g.item, cte.items || g.item FROM cte JOIN qr ON qr.item = cte.other JOIN qr g ON g.subgroup = qr.subgroup WHERE g.item <> ALL (cte.items)) SELECT item, MIN(qr1.subgroup) AS sg1, MIN(qr2.subgroup) AS sg2, DENSE_RANK() OVER (ORDER BY MIN(other)) AS grp FROM cte LEFT JOIN qr1 USING (item) LEFT JOIN qr2 USING (item) GROUP BY item ORDER BY item;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_85", "sol_sql": ["select * from superhero where publisher_id = 1 union select * from superhero where id in (select superhero_id from hero_access f where '{1}' && read_acl) order by id limit 10;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_86", "sol_sql": ["WITH r AS (SELECT id, date_of_visit, sum(sessions) as sessions, sum(pageviews) as pageviews, sum(bounces) as bounce, coalesce(utm_campaign, '') as utm_campaign, coalesce(utm_source, '') as utm_source, coalesce(utm_medium, '') as utm_medium, coalesce(utm_content, '') as utm_content, coalesce(utm_term, '') as utm_term FROM report as r GROUP BY id, date_of_visit, cube(6, 7, 8, 9, 10)) SELECT r.* FROM r JOIN utm as u ON r.id = u.row_id AND (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT DISTINCT FROM (u.utm_campaign, u.utm_source, u.utm_medium, u.utm_content, u.utm_term) WHERE 'NA' IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT TRUE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count = sum('union' in sql.lower() for sql in pred_sqls)\n    result = 0 if count > 3 else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": "PostgreSQL_87", "sol_sql": ["SELECT\n    c.id,\n    c.text,\n    (\n        SELECT array_agg(matches[1])\n        FROM regexp_matches(\n            c.text,\n            '(\\{[^{}]*\\})',\n            'g'\n        ) AS matches\n    ) AS bracketed_tokens\nFROM cards AS c;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "PostgreSQL_88", "sol_sql": ["WITH ranked_races AS (SELECT gender_id, race_id, COUNT(*) AS count, DENSE_RANK() OVER (PARTITION BY gender_id ORDER BY COUNT(*) DESC) AS rank FROM superhero GROUP BY gender_id, race_id) SELECT gender_id, race_id, count FROM ranked_races WHERE rank <= 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_89", "sol_sql": ["SELECT r.* FROM unnest(ARRAY['6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628']::uuid[]) AS p(uuid) CROSS JOIN LATERAL (SELECT id, date, text, uuid FROM rulings r WHERE r.uuid = p.uuid::varchar ORDER BY date DESC LIMIT 3) r ORDER BY uuid, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_90", "sol_sql": ["WITH riders AS ( SELECT DISTINCT id, name, total_points FROM racers), places AS (SELECT id, name, RANK() OVER (ORDER BY total_points DESC) AS place FROM riders) SELECT p.place, r.*  FROM places p JOIN racers r ON (r.id, r.name) = (p.id, p.name);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_91", "sol_sql": ["SELECT s.cds, s.cds IN (SELECT cdscode FROM frpm) AS frpm_exists FROM satscores s order by cds"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_92", "sol_sql": ["WITH first_purchase AS (SELECT customer_id, MIN(month_year) AS first_month FROM orders GROUP BY customer_id) SELECT o.month_year, COUNT(DISTINCT o.customer_id) AS repeat_customers FROM orders o JOIN first_purchase fp ON o.customer_id = fp.customer_id WHERE o.month_year > fp.first_month GROUP BY o.month_year ORDER BY o.month_year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_93", "sol_sql": ["SELECT player_name, event_date AS joined_date, (SELECT MIN(event_date) FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) AS left_date FROM player_movements pm WHERE event = 'Join'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_94", "sol_sql": ["SELECT id, ((gk_diving + gk_handling + gk_kicking + gk_positioning + gk_reflexes) - GREATEST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes) - LEAST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes)) / 3.0 AS adjusted_average FROM player_attributes ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_95", "sol_sql": ["CREATE INDEX idx_a ON trans (account_id, date DESC, trans_id);", "SELECT DISTINCT ON (t.account_id) t.trans_id, t.account_id, t.date, t.type, t.amount, t.balance FROM trans t;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_96", "sol_sql": ["\n        select account_id, date, \n        sum(amount) OVER w as total_amount, \n        sum(balance) OVER w as total_balance, \n        count(trans_id) OVER w as total_transactions\n        from trans WINDOW w AS (PARTITION BY account_id, date);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    \n    lower_sqls = ' '.join(pred_sqls)\n    lower_sqls = lower_sqls.lower()\n    keyword_count = lower_sqls.count('partition by')\n    assert keyword_count == 1, f\"You need to just use one PARTITION definition.\"\n    "]}
{"instance_id": "PostgreSQL_97", "sol_sql": ["\n        SELECT * FROM transactions_1k WHERE Date < '2012-08-24' OR (Date = '2012-08-24' AND Time > '10:00:00') OR (Date = '2012-08-24' AND Time = '10:00:00' AND Amount < 20);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_98", "sol_sql": ["\n        SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_99", "sol_sql": ["select session_id, post_id, max(case when event_name='view_start' then ts end) start_time, max(case when event_name='view_end' then ts end) end_time, case when max(case when event_name='view_end' then ts end) - max(case when event_name='view_start' then ts end) > 3 and max(view_perc) > 0.8 then 'yes' else 'no' end as has_impact from (select *, row_number() over (partition by session_id, post_id order by ts) rn from view_logs) t group by session_id, post_id, (rn-1)/ 2 order by session_id, post_id, min(ts);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_100", "sol_sql": ["WITH deleted_rows AS (DELETE FROM superhero WHERE id = 999 RETURNING 1) SELECT COALESCE((SELECT * FROM deleted_rows), 0)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 1, f'Expected 1 row, but found {len(pred_sqls_result)} rows'"]}
{"instance_id": "PostgreSQL_101", "sol_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $$ BEGIN IF s IS NULL AND v IS NULL THEN RETURN NULL; ELSIF v IS NULL THEN RETURN s; ELSE RETURN v; END IF; END; $$;", "CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);", "SELECT id, str, val, GapFill(val) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS valx FROM example;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_102", "sol_sql": ["UPDATE table_A SET is_active = false WHERE parent_id IS NULL AND is_active = true AND id = ANY (SELECT a2.parent_id FROM table_A a2 JOIN table_B b ON a2.foreign_id = b.id WHERE b.deleted = true) RETURNING *"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_103", "sol_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 0), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 0), 2) AS pct_change_month_prior FROM transactions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # results = execute_queries(['SELECT * FROM transactions;'], db_name, conn)[0]\n    # assert 1== 0, f'{results}'\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_104", "sol_sql": ["SELECT name, convertedManaCost, ROUND(avg(convertedManaCost::numeric) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW), 2) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_105", "sol_sql": ["WITH approved_counts AS (SELECT hero_id, attribute_id, COUNT(CASE WHEN (value->>'approved')::boolean THEN 1 END) AS approved_cnt FROM hero_attribute a CROSS JOIN LATERAL jsonb_array_elements(a.ss) AS value GROUP BY hero_id, attribute_id) SELECT a.hero_id, a.attribute_id, jsonb_array_length(a.ss) AS ss_cnt, ac.approved_cnt FROM hero_attribute a JOIN approved_counts ac ON a.hero_id = ac.hero_id AND a.attribute_id = ac.attribute_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_106", "sol_sql": ["SELECT * FROM trans WHERE EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(DAY FROM date) = EXTRACT(DAY FROM CURRENT_DATE) ORDER BY date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_107", "sol_sql": ["\n    select set_translations.language, \n    CASE\n        WHEN EXISTS (select *\n                    from foreign_data\n                    where foreign_data.language = set_translations.language)\n        THEN 'common'\n        ELSE 'not common'\n    END\n    from\n    set_translations\n   "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_108", "sol_sql": ["\n    DO $$ \n    DECLARE \n        i integer; \n        j integer; \n        k text; \n    BEGIN \n        FOR i, j, k IN \n            SELECT unnest(ARRAY[11, 20]::integer[]), \n                   unnest(ARRAY[505942, 155782]::integer[]), \n                   unnest(ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[])\n        LOOP \n            UPDATE Player_Attributes \n            SET overall_rating = i \n            WHERE player_api_id = j \n            AND date = k; \n        END LOOP; \n    END $$;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 505942 AND date = '2016-02-18 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    test_pred_query_result_2 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 155782 AND date = '2015-10-16 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    assert len(test_pred_query_result_1) == 1, 'There should be exactly one record for player_api_id = 505942 and date = 2016-02-18.'\n    assert test_pred_query_result_1[0][4] == 11, 'Player 505942 overall_rating should be updated to 11.'\n    \n    assert len(test_pred_query_result_2) == 1, 'There should be exactly one record for player_api_id = 155782 and date = 2015-10-16.'\n    assert test_pred_query_result_2[0][4] == 20, 'Player 155782 overall_rating should be updated to 20.'\n"]}
{"instance_id": "PostgreSQL_109", "sol_sql": ["\nSELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected at least one result with fastestLapTime = 1:35.405, but found none.'\n    assert all(row[0] is not None for row in test_pred_query_result_1), 'Expected all resultIds to be valid, but found NULL values.'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_2) == 1, f'Expected exactly 1 result with fastestLapTime = 1:35.405, but found {len(test_pred_query_result_2)} results.'\n    assert test_pred_query_result_2[0][0] == 23, f'Expected resultId to be 23, but found {test_pred_query_result_2[0][0]}.'\n"]}
{"instance_id": "PostgreSQL_110", "sol_sql": ["\nSELECT raceId,\n       jsonb_object_agg(COALESCE(position::text, 'Unknown') , COALESCE(cnt::text, '0')) AS json_count\nFROM (\n    SELECT raceId,\n           position,\n           COUNT(*) AS cnt\n    FROM results\n    GROUP BY raceId, position\n) AS aggregated_counts\nGROUP BY raceId\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 1;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_1[0][0] == 1, f'Expected count of position 1 in race 19 to be 1, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 2;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_2[0][0] == 1, f'Expected count of position 2 in race 19 to be 1, but found {test_pred_query_result_2[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 3;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_3[0][0] == 1, f'Expected count of position 3 in race 19 to be 1, but found {test_pred_query_result_3[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) > 0, 'Expected at least one row in the result, but found none.'\n    assert isinstance(pred_query_result[0][1], dict), 'Expected json_count to be a dictionary, but found something else.'\n    assert '1' in pred_query_result[0][1], 'Expected position 1 to be included in the json_count for raceId 1.'\n"]}
{"instance_id": "PostgreSQL_111", "sol_sql": ["\nSELECT * FROM Match WHERE (match_api_id, date, id) < (492473, '2008-08-17 00:00:00', 1) ORDER BY match_api_id DESC, date DESC, id DESC LIMIT 3;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 3, f'Expected 3 rows, but found {len(test_pred_query_result_1)} rows'\n    assert test_pred_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_pred_query_result_1[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) == 3, f'Expected 3 rows, but found {len(test_sol_query_result_1)} rows'\n    assert test_sol_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_sol_query_result_1[0][0]}'\n    "]}
{"instance_id": "PostgreSQL_112", "sol_sql": ["\nSELECT s.School FROM schools s WHERE s.County IN ('Alameda', 'Contra Costa') \nGROUP BY s.School HAVING COUNT(DISTINCT s.County) = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_pred_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_pred_query_result_1[2][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_sol_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_sol_query_result_1[1][0]}'\n    assert test_sol_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_sol_query_result_1[2][0]}'\n    "]}
{"instance_id": "PostgreSQL_113", "sol_sql": ["SELECT DISTINCT ON (name) raceid, name, date FROM races ORDER BY name, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_114", "sol_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) CROSS JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'european_football_2', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'european_football_2', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_115", "sol_sql": ["\nWITH RankedFRPM AS (\n    SELECT *, \n           ROW_NUMBER() OVER (\n               PARTITION BY \"County Code\" \n               ORDER BY \"Enrollment (K-12)\" DESC NULLS LAST\n           ) AS rn \n    FROM frpm\n    WHERE \"County Code\" IS NOT NULL AND \"Enrollment (K-12)\" IS NOT NULL\n) \nSELECT * \nFROM RankedFRPM \nWHERE rn = 2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_116", "sol_sql": ["WITH RECURSIVE expanded AS (\n    SELECT \n        name, \n        price_per_unit, \n        ROW_NUMBER() OVER (ORDER BY price_per_unit, name) AS row_number\n    FROM race_materials\n    CROSS JOIN generate_series(1, quantity)\n), \npurchased (name, remaining, next_row_number) AS (\n    SELECT \n        NULL::TEXT AS name, \n        100 AS remaining, \n        1::BIGINT AS next_row_number\n    UNION ALL\n    SELECT \n        expanded.name, \n        purchased.remaining - expanded.price_per_unit, \n        expanded.row_number + 1\n    FROM purchased\n    JOIN expanded \n        ON expanded.row_number = purchased.next_row_number\n    WHERE expanded.price_per_unit <= purchased.remaining\n)\nSELECT COUNT(name) AS qty\nFROM purchased;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert int(pred_query_result[0][0]) == 32, f\"Value returned {int(pred_query_result[0][0])} but expected 32\"\n"]}
{"instance_id": "PostgreSQL_117", "sol_sql": ["SELECT d.forename, d.surname, r.race_results\nFROM (\n   SELECT driverid, \n          jsonb_agg(jsonb_build_object('laps', r.laps, 'position', r.position)) AS race_results\n   FROM results r\n   WHERE EXISTS (\n      SELECT 1 \n      FROM results r1\n      WHERE r1.driverid = r.driverid\n      AND   r1.laps = 56\n      AND   r1.position = 1\n   )\n   GROUP BY driverid\n) r\nJOIN drivers d ON d.driverid = r.driverid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(sol_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_118", "sol_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id, STRING_AGG(overall_rating::TEXT, ',') AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT player_api_id FROM historical_rating WHERE player_fifa_api_id = 227760;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 582500, f'Expected player_api_id to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT grouped_rating FROM historical_rating WHERE player_api_id = 306507;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == '64,64,64,64,64,63,63,63,63,64,64,64,62,62', f'Expected grouped_rating to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": "PostgreSQL_119", "sol_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score\nFROM (\n  SELECT p.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE p.score >= 20\n  UNION ALL\n  SELECT c.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE NOT p.score >= 20 AND c.score >= 20\n) x;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_120", "sol_sql": ["SELECT DISTINCT s.id \nFROM superhero s \nWHERE s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Flight'\n    )\n) \nAND s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Telepathy'\n    )\n) \nAND s.id NOT IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id NOT IN (\n        (SELECT id FROM superpower WHERE power_name = 'Flight'), \n        (SELECT id FROM superpower WHERE power_name = 'Telepathy')\n    )\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_121", "sol_sql": ["WITH card_activity AS (\n  SELECT \n    to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date,\n    to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date,\n    dp.set_name,\n    dp.set_code,\n    fe.set_key\n  FROM fact_collection fe\n  INNER JOIN dim_set dp ON fe.set_key = dp.set_key\n)\nSELECT \n  date_trunc('month', month_series) AS month,\n  COUNT(DISTINCT fe.card_key) AS existing_cards,\n  sa.set_name\nFROM (\n  SELECT \n    generate_series(\n      (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection), \n      '2100-12-31', \n      INTERVAL '1 month'\n    ) AS month_series\n) AS months\nLEFT JOIN card_activity sa ON \n  sa.start_date <= month_series AND \n  (sa.end_date IS NULL OR sa.end_date >= month_series)\nLEFT JOIN fact_collection fe ON \n  fe.set_key = sa.set_key \n  AND fe.start_date_key <= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 31\n  AND (fe.end_date_key IS NULL OR fe.end_date_key >= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 1)\nGROUP BY month, sa.set_name\nLIMIT 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_122", "sol_sql": ["WITH data AS (  SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start ), mark_gaps AS ( SELECT hero_id, mission_start, mission_end,  COALESCE(LAG(mission_end) OVER w < mission_start, true) AS is_end_grp FROM data WINDOW w AS (PARTITION BY hero_id ORDER BY mission_start) ), numbered_groups AS ( SELECT hero_id, SUM(is_end_grp::int) OVER (PARTITION BY hero_id  ORDER BY mission_start) AS grp_num, mission_start, mission_end FROM mark_gaps ) SELECT hero_id, MIN(mission_start) AS v_start, MAX(mission_end) AS v_stop FROM numbered_groups GROUP BY hero_id, grp_num  ORDER BY hero_id, v_start; "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_123", "sol_sql": ["SELECT to_timestamp(percentile_cont(0.5) within group (ORDER by cast (extract(epoch from releasedate) as integer)))::date FROM sets"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_124", "sol_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL, incident_description VARCHAR(30) NOT NULL CHECK(CASE incident_type WHEN 'Engine failure' THEN incident_description IN ('Piston failure', 'Cylinder head gasket') WHEN 'Collision' THEN incident_description IN ('High-speed impact', 'Low-speed impact') END));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Piston failure');\"], db_name, conn)[0];\n    assert test_pred_query_result_1 == None, f'Expected 0 rows, but found {test_pred_query_result_1}'\n    test_pred_query_result_2 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'High-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_2 == None, f'Expected 0 rows, but found {test_pred_query_result_2}'\n    test_pred_query_result_3 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Cylinder head gasket');\"], db_name, conn)[0];\n    assert test_pred_query_result_3 == None, f'Expected 0 rows, but found {test_pred_query_result_3} rows'\n    test_pred_query_result_4 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Low-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_4 == None, f'Expected 0 rows, but found {test_pred_query_result_4}'\n    test_pred_query_result_5 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Piston failure');\"], db_name, conn)[1];\n    assert test_pred_query_result_5 == True, f'There should be constraint viloation error.'\n"]}
{"instance_id": "PostgreSQL_125", "sol_sql": ["UPDATE latest_trans a SET (amount, trans_id) = (SELECT amount, trans_id FROM trans t WHERE t.account_id = a.account_id ORDER BY t.trans_id DESC LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"select max(trans_id) from trans where account_id = 1;\"], db_name, conn)[0]\n    test_pred_query_result_2 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 1;\"], db_name, conn)[0]\n    assert test_pred_query_result_2 == test_pred_query_result_1, f\"Expected equal but got {test_pred_query_result_1} {test_pred_query_result_2}\"\n\n    test_pred_query_result_3 = execute_queries([\"select max(trans_id) from trans where account_id = 107;\"], db_name, conn)[0]\n    test_pred_query_result_4 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 107;\"], db_name, conn)[0]\n    assert test_pred_query_result_3 == test_pred_query_result_4, f\"Expected equal but got {test_pred_query_result_3} {test_pred_query_result_4}\"\n\n    test_pred_query_result_5 = execute_queries(['SELECT COUNT(*) FROM latest_trans;'], db_name,conn)[0]\n    assert test_pred_query_result_5[0][0] == 4500, 'The total number of records in the attendance table should remain unchanged after the update.'\n"]}
{"instance_id": "PostgreSQL_126", "sol_sql": ["WITH RECURSIVE recuree AS (SELECT id AS league_id, name FROM League UNION ALL SELECT L.id AS league_id, L.name FROM League L JOIN recuree R ON L.id = R.league_id) SELECT * FROM recuree LIMIT 50;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_127", "sol_sql": ["CREATE OR REPLACE FUNCTION get_superhero_ids()\n  RETURNS SETOF jsonb\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    cols   text;    -- Will hold the comma-separated list of matching columns\n    sqlstr text;    -- Will hold the final SQL statement\nBEGIN\n    SELECT string_agg(quote_ident(column_name), ', ')\n      INTO cols\n      FROM information_schema.columns\n     WHERE table_name = 'superhero'\n       AND column_name LIKE '%_id';\n\n    IF cols IS NULL THEN\n        -- No columns matched; return nothing\n        RETURN;\n    END IF;\n\n    sqlstr := format(\n        'SELECT to_jsonb(row) \n         FROM (SELECT %s \n               FROM %I) AS row',\n        cols,\n        'superhero'\n    );\n    RETURN QUERY EXECUTE sqlstr;\nEND;\n$$;", "SELECT get_superhero_ids();"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "PostgreSQL_128", "sol_sql": ["CREATE TYPE availability_enum AS ENUM (\n  'mtgo,paper',\n  'paper-only',\n  'mtgo-only'\n);", "CREATE OR REPLACE FUNCTION force_availability_default()\n  RETURNS TRIGGER\n  LANGUAGE plpgsql\nAS $$\nBEGIN\n  -- If the inserted row has availability = NULL, override it with the default\n  NEW.availability := 'mtgo,paper';\n  RETURN NEW;\nEND;\n$$;", "CREATE TRIGGER cards_before_insert\nBEFORE INSERT ON cards\nFOR EACH ROW\nWHEN (NEW.availability IS NULL)  -- only fires if availability is actually NULL\nEXECUTE FUNCTION force_availability_default();", "INSERT INTO cards (availability, borderColor)\nVALUES (NULL, 'black');"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    test_result = execute_queries([\"SELECT availability, borderColor FROM cards ORDER BY id DESC LIMIT 1;\"],db_name,conn)\n    assert test_result is not None and test_result[0] == [('mtgo,paper', 'black')]\n    return 1"]}
{"instance_id": "PostgreSQL_129", "sol_sql": ["CREATE OR REPLACE FUNCTION f_next_free_date(\n    _input_date date\n)\nRETURNS date\nLANGUAGE plpgsql STABLE STRICT\nAS $func$\nDECLARE\n    _candidate date := _input_date;\nBEGIN\n    LOOP\n        IF NOT EXISTS (\n            SELECT 1\n              FROM races\n             WHERE date = _candidate\n        )\n        THEN\n            RETURN _candidate;\n        END IF;\n        \n        _candidate := _candidate + INTERVAL '1 day';\n    END LOOP;\nEND;\n$func$;", "INSERT INTO seasons (year, url)\nVALUES (2023, 'http://example.com');", "SELECT f_next_free_date('2023-04-01');\n\nINSERT INTO races (raceid, year, round, circuitid, name, date, time, url)\nVALUES (\n    999,\n    2023,\n    1,\n    2,\n    'Test Grand Prix',\n    f_next_free_date('2023-04-01'),\n    '12:00:00',\n    'http://example.com'\n)RETURNING raceid, year, round, circuitid, name, date, time, url;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    \n    test_result = execute_queries([\n        \"SELECT COUNT(*) FROM races WHERE date = '2023-04-01'\"\n    ], db_name, conn)\n    assert test_result and test_result[0][0][0] == 1, f\"Expect 1 row, but get {test_result[0][0][0]} rows\"\n    \n    return 1"]}
{"instance_id": "PostgreSQL_130", "sol_sql": ["SELECT r.name, r.date, ARRAY_AGG(lt.milliseconds ORDER BY lt.lap) AS lap_times FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId WHERE lt.driverId = 1 GROUP BY r.name, r.date ORDER BY r.date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "PostgreSQL_131", "sol_sql": ["WITH LatestLabs AS (SELECT ID, \"Examination Date\", Thrombosis, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY \"Examination Date\" DESC) AS rn FROM Examination) SELECT ID, MAX(CASE WHEN rn = 1 THEN Thrombosis END) AS Thrombosis_1, MAX(CASE WHEN rn = 2 THEN Thrombosis END) AS Thrombosis_2 FROM LatestLabs WHERE rn <= 2 GROUP BY ID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_132", "sol_sql": ["with connections as ( select atom_id as atom from connected union all select atom_id2 as atom from connected ) select atom as id, count(*) as num from connections group by atom having count(*) = (select max(cnt) from (select count(*) as cnt from connections group by atom) as max_connections);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_133", "sol_sql": ["CREATE OR REPLACE FUNCTION trigger_function()\nRETURNS TRIGGER\nAS $BODY$\nBEGIN\n    INSERT INTO public.destination_table (\n        created_at,\n        match_id,\n        player_id,\n        event_type,\n        url,\n        user_id\n    )\n    VALUES (\n        NEW.created_at,\n        NEW.match_id,\n        NEW.player_id,\n        NEW.event_type,\n        split_part(NEW.url::text, '?', 1),\n        ((NEW.data -> 'local_storage') -> 'data') ->> 'user_id'\n    );\n\n    RETURN NEW;\nEND;\n$BODY$\nLANGUAGE plpgsql;", "CREATE TRIGGER after_insert_source\nAFTER INSERT ON public.source_table\nFOR EACH ROW\nEXECUTE PROCEDURE trigger_function();", "INSERT INTO public.source_table (\n    created_at,\n    match_id,\n    player_id,\n    event_type,\n    url,\n    data\n)\nVALUES (\n    NOW(),                     -- created_at\n    101,                       -- match_id\n    202,                       -- player_id\n    'goal',                    -- event_type\n    'http://example.com?foo=bar', -- url\n    '{\n        \"local_storage\": {\n            \"data\": {\n                \"user_id\": \"u12345\"\n            }\n        }\n    }'::jsonb                  -- data\n);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    test_result = execute_queries([\"SELECT * FROM public.destination_table;\"], db_name, conn)\n    assert test_result and test_result[0][0][-1] == 'u12345'\n    assert test_result and test_result[0][0][-2] == 'http://example.com'\n    assert test_result and test_result[0][0][-3] == 'goal'\n    return 1"]}
{"instance_id": "PostgreSQL_134", "sol_sql": ["WITH main AS (\n    SELECT DISTINCT ON (main_request_uuid)\n           id,\n           superhero_id,\n           superpower_id,\n           status,\n           created_at\n    FROM public.superhero_requests\n    ORDER BY main_request_uuid, retry_number DESC, id DESC\n)\nSELECT\n    m.superhero_id AS \"superheroId\",\n    p.power_name   AS \"power\",\n    COUNT(*) AS \"totalRequests\",\n    SUM(CASE WHEN m.status = 'success' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS \"successRate\"\nFROM main m\nJOIN public.superpower p\n    ON m.superpower_id = p.id\nWHERE m.created_at >= CURRENT_DATE - INTERVAL '30 days'\n  AND m.created_at <= CURRENT_DATE\nGROUP BY\n    m.superhero_id,\n    p.power_name\nLIMIT 10;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_135", "sol_sql": ["SELECT raceId, name, year, COUNT(*) OVER (PARTITION BY year) as same_year_races FROM races;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_136", "sol_sql": ["CREATE INDEX IF NOT EXISTS price_uuid_time_desc ON card_prices (uuid ASC, timestamp DESC) INCLUDE (price) WHERE price > 0;;", "SELECT LEAST ((SELECT min(price) FROM card_prices WHERE timestamp >= '2022-07-12T15:30:00-00:00' AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' AND price > 0), (SELECT price FROM card_prices WHERE timestamp < '2022-07-12T15:30:00-00:00' AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' AND price > 0 ORDER BY timestamp DESC LIMIT 1));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_137", "sol_sql": ["with hero_attribute_data (hero_id, attribute_id, max_score, year_1, year_2, year_3, year_4, year_5) as (values (1, 1, 80, 80, 80, 80, null, 80), (2, 2, 90, 90, 85, 90, 88, 90), (3, 3, 75, 75, 70, null, 75, 75), (4, 4, 60, null, 60, 60, 60, null)), score_check as (select *, case when (coalesce(year_1::character, 'x') || coalesce(year_2::character, 'x') || coalesce(year_3::character, 'x') || coalesce(year_4::character, 'x') || coalesce(year_5::character, 'x') ~ '\\d+x\\d+' or year_1 <> max_score or year_2 <> max_score or year_3 <> max_score or year_4 <> max_score or year_5 <> max_score) then false else true end is_a_match from hero_attribute_data) select * from score_check where is_a_match is false;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_138", "sol_sql": ["WITH RECURSIVE cte AS (SELECT item_id, item_price, quantity, resource_id, resource_price FROM store UNION ALL SELECT s.item_id, s.item_price, c.quantity, c.resource_id, c.resource_price FROM store s INNER JOIN cte c ON c.item_id = s.uses_item_id), full_craft_prices AS (SELECT item_id, sum(coalesce(resource_price * quantity, 0)) AS full_craft_price FROM cte GROUP BY item_id) SELECT s.item_id, s.item_price AS retail_price, sum(coalesce(uses_item_price, 0) * quantity) + sum(coalesce(resource_price * quantity, 0)) AS partial_craft_price, f.full_craft_price FROM store s LEFT JOIN full_craft_prices f ON s.item_id = f.item_id GROUP BY s.item_id, s.item_price, f.full_craft_price;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_139", "sol_sql": ["UPDATE superhero s SET full_name = 'Superman' FROM team_member_superhero tms JOIN team_member tm ON tms.team_member_id = tm.id WHERE s.id = tms.superhero_id AND tm.team_id = 91;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT full_name FROM superhero WHERE id = 1;\"], db_name, conn)[0]\n    assert test_sql_result[0][0] == \"Superman\", f'Expected the full name is updated to Superman, but found {test_sql_result[0][0]}'"]}
{"instance_id": "PostgreSQL_140", "sol_sql": ["WITH norm_matches AS ( SELECT id AS match_id, home_team_api_id AS team_id, home_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'W' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'L' END AS outcome FROM match UNION ALL SELECT id AS match_id, away_team_api_id AS team_id, away_team_goal AS goals, CASE WHEN home_team_goal > away_team_goal THEN 'L' WHEN home_team_goal = away_team_goal THEN 'D' WHEN home_team_goal < away_team_goal THEN 'W' END AS outcome FROM match ), points (outcome, value) AS ( VALUES ('W', 3), ('D', 1), ('L', 0) ) SELECT t.team_long_name, count(1) AS matches, count(1) filter (WHERE m.outcome = 'W') AS victories, count(1) filter (WHERE m.outcome = 'L') AS defeats, count(1) filter (WHERE m.outcome = 'D') AS draws, sum(p.value) AS score FROM team t JOIN norm_matches m ON m.team_id = t.team_api_id JOIN points p ON p.outcome = m.outcome GROUP BY t.team_long_name ORDER BY t.team_long_name"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_141", "sol_sql": ["SELECT id, COALESCE(MAX(CASE WHEN diagnosis = 'SLE' THEN 'TRUE' END), 'FALSE') AS SLE, COALESCE(MAX(CASE WHEN diagnosis = 'PSS' THEN 'TRUE' END), 'FALSE') AS PSS, COALESCE(MAX(CASE WHEN diagnosis = 'RA susp.' THEN 'TRUE' END), 'FALSE') AS RA_susp FROM examination GROUP BY id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    global pred_query_result\n    assert len(pred_query_result) == 70, f'Expected 70 rows, but found {len(pred_query_result)} rows.'\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_142", "sol_sql": ["SELECT COALESCE(hbi.id, hbialt.id) as id, COALESCE(hbi.hero_name, hbialt.hero_name) as name, COALESCE(hbialt.date_of_birth, hbi.birthdate) AS birthdate FROM hero_birth_info hbi FULL OUTER JOIN hero_birth_info_alt hbialt ON hbi.id = hbialt.id order by COALESCE(hbi.id, hbialt.id)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_143", "sol_sql": ["CREATE OR REPLACE FUNCTION reindex_superhero_ids(IN BIGINT) RETURNS VOID LANGUAGE plpgsql AS $proc$ BEGIN IF EXISTS ( SELECT FROM pg_catalog.pg_class WHERE  relname = 'id_seq_temp' AND relnamespace = pg_my_temp_schema() AND relkind = 'S') THEN ALTER SEQUENCE id_seq_temp RESTART; ELSE CREATE TEMP SEQUENCE id_seq_temp; END IF; UPDATE superhero SET hair_colour_id = hair_colour_id + 2000 WHERE publisher_id = $1; UPDATE superhero SET hair_colour_id = nextval('id_seq_temp') WHERE publisher_id = $1; END $proc$;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"SELECT reindex_superhero_ids(9)\"], db_name, conn)\n    test_sql_result = execute_queries([\"SELECT hair_colour_id FROM superhero WHERE publisher_id = 9;\"], db_name, conn)[0]\n    assert test_sql_result == [(1,), (1,), (1,), (1,)], f'Expected hair_color_id to be 1, 1, 1, 1, but found {test_sql_result}.'\n"]}
{"instance_id": "PostgreSQL_144", "sol_sql": ["ALTER TABLE card_versions  DROP CONSTRAINT pk_card_versions, ADD  CONSTRAINT pk_card_versions PRIMARY KEY (defn_id, attr_id, seqnr) DEFERRABLE", "UPDATE card_versions SET seqnr = seqnr + 1 WHERE defn_id = 100 AND attr_id = 100 AND seqnr >= 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT seqnr FROM card_versions;\"], db_name, conn)[0]\n    assert test_sql_result == [(2,), (3,), (4,), (5,), (6,)], f'Expected the seqrs are updated to 2, 3, 4, 5, 6, but found {test_sql_result}'"]}
{"instance_id": "PostgreSQL_145", "sol_sql": ["WITH table_jsonb AS (SELECT id, jsonb_insert('{}','{buildupplayspeed}',to_jsonb(buildupplayspeed)) as attributes FROM team_attributes WHERE team_api_id = 1773) UPDATE team_attributes SET attributes_jsonb = table_jsonb.attributes FROM table_jsonb WHERE team_attributes.id = table_jsonb.id AND team_attributes.team_api_id = 1773 RETURNING team_attributes.id, team_attributes.attributes_jsonb;", "SELECT id, attributes_jsonb FROM team_attributes WHERE team_api_id = 1773 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_146", "sol_sql": ["WITH RECURSIVE atom_ancestors AS ( SELECT atom_id, parent_id, enabled FROM connection WHERE atom_id = 4 UNION ALL SELECT c.atom_id, c.parent_id, c.enabled FROM connection c INNER JOIN atom_ancestors aa ON c.atom_id = aa.parent_id) SELECT * FROM atom_ancestors WHERE NOT EXISTS (SELECT 1 FROM atom_ancestors WHERE enabled = false)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_147", "sol_sql": ["\nselect\n  preference_data.customerid,\n  jsonb_object_agg(preference_data.key, case when preference_data.key = 'dis' then preference_data.value else preference_data.value->0 end) as final_json\nfrom (\n    select\n      mt.customerid,\n      props.key,\n      jsonb_agg(distinct coalesce(j.dis, props.value)) as value\n    from card_preference as mt\n    cross join jsonb_each(mt.preference) as props\n    left join jsonb_array_elements(case when props.key = 'dis' then props.value end) as j(dis) on 1=1\n    group by\n      mt.customerid,\n      props.key\n) preference_data\ngroup by\n  preference_data.customerid;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    assert isinstance(concatenated_json, dict), f'Expected result to be a dictionary, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    expected_values = {\n        \"dir\": 1,\n        \"dis\": [\"bye\", \"close\", \"hello\"],\n        \"purpose\": {\"text\": \"hi\", \"score\": 0.1}\n    }\n\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'"]}
{"instance_id": "PostgreSQL_148", "sol_sql": ["\nSELECT hero_id, attribute_value AS Difference FROM hero_attribute \nJOIN attribute ON hero_attribute.attribute_id = attribute.id GROUP BY hero_id, attribute_value \nHAVING COUNT(DISTINCT attribute_value) > 1 UNION ALL SELECT hero_id, attribute_value AS Difference \nFROM hero_attribute JOIN attribute ON hero_attribute.attribute_id = attribute.id \nGROUP BY hero_id, attribute_value HAVING COUNT(DISTINCT attribute_id) > 1 \nOR (COUNT(attribute_id) != COUNT(*) AND COUNT(DISTINCT attribute_id) > 0)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'error_sql query did not return any records with attribute differences.'\n    assert test_pred_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_pred_query_result_1[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, 'sol_sql query did not return any records with attribute differences.'\n    assert test_sol_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_sol_query_result_1[0][1]}'\n"]}
{"instance_id": "PostgreSQL_149", "sol_sql": ["INSERT INTO member(member_id, first_name, last_name, link_to_major) VALUES ('new_member_id', 'John', 'Doe', 'rec06DF6vZ1CyPKpc') ON CONFLICT (member_id) DO UPDATE SET first_name=excluded.first_name, last_name=excluded.last_name, link_to_major=member.link_to_major;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_0 = execute_queries([\"SELECT member_id, first_name, last_name, link_to_major FROM member WHERE member_id = 'new_member_id';\"], db_name, conn)[0]; \n\n    assert test_pred_query_result_0[0][0] == 'new_member_id', f'Expected member_id to be new_number_id, but found {test_pred_query_result_0[0][0]}'\n    assert test_pred_query_result_0[0][1] == 'John', f'Expected first_name to be John, but found {test_pred_query_result_0[0][1]}'\n    assert test_pred_query_result_0[0][2] == 'Doe', f'Expected last_name to be Doe, but found {test_pred_query_result_0[0][2]}'\n    assert test_pred_query_result_0[0][3] == 'rec06DF6vZ1CyPKpc', f'Expected link_to_major to be rec06DF6vZ1CyPKpc, but found {test_pred_query_result_0[0][3]}'\n\n    "]}
{"instance_id": "PostgreSQL_150", "sol_sql": ["SELECT COUNT(*) AS streak_count, 'April Meeting' AS event_name, 'MST' AS timezone, MIN(min_ts) AS start_date, MAX(max_ts) AS end_date FROM ( SELECT *, the_day - row_number() OVER (ORDER BY the_day)::INT AS streak FROM ( SELECT (event_date::TIMESTAMP AT TIME ZONE 'UTC' AT TIME ZONE 'MST')::date AS the_day , count(*) AS ct, min(event_date) AS min_ts, max(event_date) AS max_ts FROM event WHERE event_name = 'April Meeting' GROUP  BY 1) sub1) sub2 GROUP  BY streak ORDER  BY end_date DESC LIMIT  1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_query_result_1[0][1] == 'April Meeting', 'The event name should be April Meeting.'\n    assert pred_query_result_1[0][2] == 'MST', 'The timezone should be MST.'\n    assert pred_query_result_1[0][0] > 0, 'The streak count should be greater than 0.'\n    test_pred_query_result_1 = execute_queries([\"SELECT MIN(event_date) AS start_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][3] == str(test_pred_query_result_1[0][0]), f'Expected start_date to be {test_pred_query_result_1[0][0]}, but found {pred_query_result_1[0][3]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT MAX(event_date) AS end_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][4] == str(test_pred_query_result_2[0][0]), f'Expected end_date to be {test_pred_query_result_2[0][0]}, but found {pred_query_result_1[0][4]}'\n    \n    "]}
{"instance_id": "PostgreSQL_151", "sol_sql": ["SELECT DATE_TRUNC('day', to_timestamp(transaction_timestamp / 1000000000.0)), COUNT(*) FROM pitstops GROUP BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_152", "sol_sql": ["select id, date, got, gpt from (select lab1.*, row_number() over (partition by lab1.id order by lab1.date) as rn from laboratory lab1 join (select id, date, got, gpt from (select lab.*, row_number() over (partition by lab.id order by lab.date desc) rn from laboratory lab) lab where rn = 1 ) lab2 on lab2.id = lab1.id and lab1.got = lab2.got and lab1.gpt = lab2.gpt) lab where rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_153", "sol_sql": ["WITH constructor_roles AS ( SELECT 18 race_id, 1 constructor_id, false customer_billing, true commander, true agent UNION ALL SELECT 18, 2, true, false, false ), tmp AS ( SELECT n.race_id id, array_agg( ARRAY[ CASE WHEN n.customer_billing = TRUE THEN 'AR (Customer Billing)' END, CASE WHEN n.commander = TRUE THEN 'AP (Commander)' END, CASE WHEN n.agent = TRUE THEN 'AP (Agent)' END ] ) AS finance_array FROM constructor_roles n WHERE n.race_id = 18 AND (n.customer_billing = TRUE or n.commander = TRUE or n.agent = TRUE) GROUP BY race_id ) SELECT id, array_to_string(array(select distinct e from unnest(finance_array) as a(e)), ', ') FROM tmp"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_154", "sol_sql": ["SELECT sub.firstName, jsonb_agg(jsonb_build_object('yearId', sub.yearId, 'classes', sub.classes)) AS years FROM (SELECT s.id, s.firstName, cy.yearId, jsonb_agg(jsonb_build_object('classId', cy.classId)) AS classes FROM users3 s LEFT JOIN classYearStudents cys ON cys.studentId = s.id LEFT JOIN classYears cy ON cy.id = cys.classYearId GROUP BY s.id, cy.yearId) sub GROUP BY sub.firstName, sub.id order by sub.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_155", "sol_sql": ["WITH RECURSIVE EmpMgrCTE AS (SELECT id, bossid, salary, 0 as EmployeeLevel, id as baseId, salary as baseSalary FROM staff WHERE bossid IS NOT NULL UNION ALL SELECT emp.id, emp.bossid, emp.salary, mgr.EmployeeLevel + 1 as EmployeeLevel, mgr.baseId, mgr.baseSalary FROM staff emp INNER JOIN EmpMgrCTE mgr ON emp.id = mgr.bossid WHERE baseSalary * 2 > mgr.salary) SELECT emp.baseId, emp.baseSalary, EmployeeLevel, emp.id as bossid, emp.salary as bossSalary FROM EmpMgrCTE emp WHERE baseSalary * 2 <= salary order by baseId;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_156", "sol_sql": ["select distinct rarity, first_value(id) over(partition by rarity order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc) from cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_157", "sol_sql": ["DROP TABLE IF EXISTS card, account, disp CASCADE; CREATE TABLE account ( account_id INT PRIMARY KEY NOT NULL, district_id INT NOT NULL, frequency TEXT NOT NULL, date DATE NOT NULL ); CREATE TABLE disp ( disp_id INT PRIMARY KEY NOT NULL, client_id INT NOT NULL, account_id INT NOT NULL, type TEXT NOT NULL, FOREIGN KEY (account_id) REFERENCES account(account_id) ON UPDATE CASCADE ON DELETE CASCADE ); CREATE OR REPLACE FUNCTION check_account_disp() RETURNS TRIGGER AS $$ BEGIN IF NOT EXISTS (SELECT 1 FROM disp WHERE account_id = OLD.account_id) THEN RAISE EXCEPTION 'Every account has at least one disposition. '; END IF; RETURN OLD; END; $$ LANGUAGE plpgsql; CREATE TRIGGER ensure_account_has_disp BEFORE DELETE ON disp FOR EACH ROW EXECUTE FUNCTION check_account_disp();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    account_results = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 1, 'MONTHLY', '2020-01-01'), (2, 2, 'MONTHLY', '2024-01-01'), (3, 3, 'MONTHLY', '2024-01-01') RETURNING *;\"], db_name, conn)[0]\n    disp_results = execute_queries([\"INSERT INTO disp (disp_id, client_id, account_id, type) VALUES (1, 1, 1, 'OWNER'), (2, 2, 2, 'OWNER'), (3, 3, 3, 'OWNER') RETURNING *;\"],db_name,conn)[0]\n\n    assert len(account_results) == 3, f'Expected 3 rows, but found {len(account_results)} rows'\n    assert account_results[0][0] == 1, f'Expected account_id to be 1, but found {account_results[0][0]}'\n    assert account_results[1][0] == 2, f'Expected account_id to be 2, but found {account_results[1][0]}'\n    assert account_results[2][0] == 3, f'Expected account_id to be 3, but found {account_results[2][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM disp WHERE account_id = 1;\"],db_name,conn)[0]\n    assert disp_results[0][1] == test_pred_query_result_1[0][0], f'Expected disp count for account_id 1 to be {test_pred_query_result_1[0][0]}, but found {disp_results[0][1]}'\n\n\n    "]}
{"instance_id": "PostgreSQL_158", "sol_sql": ["SELECT COALESCE (ARRAY_AGG (json_build_object ('client_id', client.client_id, 'gender', client.gender, 'birth_date', client.birth_date)) FILTER (WHERE client.client_id IS NOT NULL), ARRAY[]::json[]) AS clients FROM client;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0];\n    assert pred_query_result_1[0][0] != '[null]', 'Expected an empty array instead of [null] when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n    assert isinstance(pred_query_result_1[0][0], list), 'Expected the result to be a list, but found {type(pred_query_result_1[0][0])}'\n    if len(pred_query_result_1[0][0]) == 0:\n        assert pred_query_result_1[0][0] == '[]', 'Expected an empty array when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n\n    if len(pred_query_result_1[0][0]) > 0:\n        for item in pred_query_result_1[0][0]:\n            assert 'client_id' in item, 'Each result should have client_id'\n            assert 'gender' in item, 'Each result should have gender'\n            assert 'birth_date' in item, 'Each result should have birth_date'\n            assert item['client_id'] is not None, 'client_id should not be NULL'\n\n\n    "]}
{"instance_id": "PostgreSQL_159", "sol_sql": ["\nDELETE FROM transactions_1k a\nUSING transactions_1k b\nWHERE a.productid = '5' \n  AND b.productid = '2'\n  AND a.date = b.date\n  AND a.cardid = b.cardid\n  AND a.gasstationid = b.gasstationid;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM transactions_1k e WHERE EXISTS (SELECT 1 FROM transactions_1k e2 WHERE e.date = e2.date AND e.time = e2.time AND e.cardid = e2.cardid AND e.gasstationid = e2.gasstationid AND e.productid = '2' AND e2.productid = '5') ORDER BY e.date ASC;\"], db_name,conn)[0]\n    assert len(test_pred_query_result_1) == 0, f'Expected 0 row, but found {len(test_pred_query_result_1)}'\n    "]}
{"instance_id": "PostgreSQL_160", "sol_sql": ["\nWITH RECURSIVE cte AS (\n    SELECT id, \n           amount, \n           amount AS cum_sum, \n           1 AS bucket\n    FROM transfer\n    WHERE id = 1\n    UNION ALL\n    SELECT transfer.id,\n           transfer.amount,\n           CASE \n               WHEN cte.cum_sum + transfer.amount > 20 THEN transfer.amount\n               ELSE cte.cum_sum + transfer.amount\n           END AS cum_sum,\n           CASE \n               WHEN cte.cum_sum + transfer.amount > 20 THEN cte.bucket + 1\n               ELSE cte.bucket\n           END AS bucket\n    FROM cte \n    JOIN transfer ON transfer.id = cte.id + 1\n)\nSELECT id, amount, cum_sum, bucket\nFROM cte \n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = any(row[2] > 20 for row in pred_query_result)\n    assert test_pred_query_result_1 == False, f'Expected not to find any value in cum_sum that is larger than 20, but the result is {test_pred_query_result_1}'\n    ", "\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import random\n    random_num = random.randint(2, len(pred_query_result))\n    diff = pred_query_result[random_num][2] - pred_query_result[random_num-1][2]\n    assert (diff == pred_query_result[random_num][1] or pred_query_result[random_num][2] == pred_query_result[random_num][1]), f'Expected to find the cum_sum equal to value or the difference of values, but found {diff}, {pred_query_result[random_num][1]} and {pred_query_result[random_num][2]}'\n    "]}
{"instance_id": "PostgreSQL_161", "sol_sql": ["SELECT raceid, laps AS modal_laps FROM (SELECT raceid, laps, COUNT(*) AS freq, MIN(resultid) AS first_occurrence, ROW_NUMBER() OVER (PARTITION BY raceid ORDER BY COUNT(*) DESC, MIN(resultid) ASC) AS rn FROM results GROUP BY raceid, laps) sub WHERE rn = 1 ORDER BY raceid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_162", "sol_sql": ["SELECT CASE WHEN t1.table_name IS NULL THEN 'extra' ELSE 'missing' END AS kind, table_name FROM required_tables t1 FULL JOIN (SELECT table_name FROM information_schema.tables WHERE  table_schema='public') t2 USING (table_name) WHERE (t1.table_name IS NULL OR t2.table_name IS NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_163", "sol_sql": ["ALTER TABLE dependency DROP CONSTRAINT dependency_match1_stage1_fkey, DROP CONSTRAINT dependency_match2_stage2_fkey;", "ALTER TABLE dependency ADD CONSTRAINT dependency_match1_stage1_fkey FOREIGN KEY (match1, stage1) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE, ADD CONSTRAINT dependency_match2_stage2_fkey FOREIGN KEY (match2, stage2) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE;", "UPDATE match SET stage = stage + 1 WHERE id = 'match1';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries([\"SELECT * FROM match WHERE id = 'match1';\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result[0][1] == 2, 'The update does not happen.'\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM dependency;\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result_1[0][1] == 2, 'The update does not happen in dependency.'\n    "]}
{"instance_id": "PostgreSQL_164", "sol_sql": ["create index idx_a on superhero_events (start_time, end_time) include (event_id, hero_id);", "SELECT * from superhero_events WHERE start_time >= Now()::timestamp - INTERVAL '3 days' AND end_time < now()+'5 hours'::interval ORDER BY CASE WHEN now()+'5 hours'::interval > Now()::timestamp AND start_time < Now()::timestamp THEN 1 WHEN start_time < Now()::timestamp THEN 2 ELSE 3 END;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_165", "sol_sql": ["with hero_attribute(hero_id, attribute_id, attribute_value) as ( values (1, 1, 80), (2, 1, 75), (3, 1, 95), (4, 1, 85), (5, 1, 90), (6, 1, 70) ), running as ( select hero_id, sum(attribute_value) over (order by hero_id rows between 2 preceding and 3 following) from hero_attribute) select sum from running where (hero_id-1) % 2 = 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_166", "sol_sql": ["select id, name, jsonb_path_query_array(skills::jsonb,'$[*].description') as skill from player_skills;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    for row in pred_query_result:\n        if row[0] == 1:\n            skill = row[2]\n            assert skill == [\"Passing\", \"Shooting\"], \"ID 1 returns wrong skills.\"\n        elif row[0] == 2:\n            skill = row[2]\n            assert skill == [\"Defending\", \"Tackling\"], \"ID 2 returns wrong skills.\"\n        else:\n            skill = row[2]\n            assert skill == [], \"ID 3 returns wrong skills.\"\n    "]}
{"instance_id": "PostgreSQL_167", "sol_sql": ["select (select tt.value from json_array_elements(t.events) as tt where tt->>'id' = '2') FROM match_events as t;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert pred_query_result[0][0] == {\"id\": 2, \"description\": \"Yellow Card\"}, \"Wrong result 1.\"\n    assert pred_query_result[1][0] == {\"id\": 2, \"description\": \"Goal\"}, \"Wrong result 2.\"\n    "]}
{"instance_id": "PostgreSQL_168", "sol_sql": ["SELECT DISTINCT ON (examination_year) c, \"ANA Pattern\", examination_year FROM (SELECT COUNT(\"ANA Pattern\") AS c, \"ANA Pattern\", EXTRACT(YEAR FROM \"Examination Date\") AS examination_year FROM examination WHERE EXTRACT(YEAR FROM \"Examination Date\") BETWEEN 1993 AND 1996 GROUP BY EXTRACT(YEAR FROM \"Examination Date\"), \"ANA Pattern\") AS sub ORDER BY examination_year, c DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 4, f'Expected 4 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_169", "sol_sql": ["WITH player_names AS (SELECT 1 AS source, ROW_NUMBER() OVER (ORDER BY player_name) AS row_number, CONCAT(player_name, '(', LEFT(birthday, 4), ')') AS dest FROM player_table), birth_year_summary AS (SELECT 2 AS source, ROW_NUMBER() OVER (ORDER BY COUNT(*), LEFT(birthday, 4)) AS row_number, CONCAT('There are a total of ', COUNT(*), ' player', CASE WHEN COUNT(*) > 1 THEN 's' ELSE '' END, ' born in ', LEFT(birthday, 4), '.') AS dest FROM player_table GROUP BY LEFT(birthday, 4)) SELECT dest FROM (SELECT * FROM player_names UNION ALL SELECT * FROM birth_year_summary) AS combined_results ORDER BY source, row_number;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    for i in range(len(sol_query_result)):\n        assert pred_query_result[i] == sol_query_result[i], 'Wrong order.' \n        return\n    "]}
{"instance_id": "PostgreSQL_170", "sol_sql": ["SELECT rs.raceId as race_id, (SELECT string_agg(constructorId::TEXT, ',' ORDER BY res.resultId) FROM results res WHERE res.raceId = rs.raceId) as constructor_ids, (SELECT string_agg(p.stop::TEXT, ', ' ORDER BY p.raceId) FROM pitstops p WHERE rs.raceId = p.raceId) AS stops FROM races rs"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_171", "sol_sql": ["SELECT r.* FROM route r WHERE EXISTS(SELECT 1 FROM route_detail rd WHERE r.id = rd.route_id AND rd.visit_status = 5) AND NOT EXISTS(SELECT 1 FROM route_detail rd INNER JOIN route_event e ON rd.id = e.route_detail_id WHERE r.id = rd.route_id AND e.event_type = 3);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 2, f\"Expected 2 rows in pred_result but found {len(pred_sqls_result)} rows.\"\n    assert pred_sqls_result[0][0] == 4, f'Expected route 4, but found route {pred_sqls_result[0][0]}'\n    assert pred_sqls_result[1][0] == 5, f'Expected route 5, but found route {pred_sqls_result[1][0]}'"]}
{"instance_id": "PostgreSQL_172", "sol_sql": ["CREATE OR REPLACE FUNCTION update_team_attributes_eff_to() RETURNS TRIGGER AS $$ BEGIN UPDATE team_attributes SET eff_to = subquery.next_date FROM ( SELECT id, team_api_id, COALESCE(LEAD(TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE, 1) OVER (PARTITION BY team_api_id ORDER BY TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE ASC), TO_DATE('6000-00-00', 'YYYY-MM-DD')) - 1 AS next_date FROM team_attributes ) AS subquery WHERE team_attributes.team_api_id = subquery.team_api_id AND team_attributes.id = subquery.id; RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE TRIGGER after_insert_team_attributes AFTER INSERT ON team_attributes FOR EACH ROW EXECUTE PROCEDURE update_team_attributes_eff_to();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"INSERT INTO team_attributes (team_api_id, date) VALUES (9930, '2010-09-08 00:00:00'), (9930, '2014-09-08 00:00:00'), (9930, '2015-09-08 00:00:00')\"], db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT date, eff_to FROM team_attributes WHERE team_api_id = 9930;\"], db_name, conn)[0]\n    assert set((str(date), str(eff_to)) for date, eff_to in pred_sqls_result) == set((str(date), str(eff_to)) for date, eff_to in [(\"2014-09-08 00:00:00\", \"2014-09-18\"), (\"2015-09-08 00:00:00\", \"2015-09-09\"), (\"2010-02-22 00:00:00\", \"2010-09-07\"), (\"2010-09-08 00:00:00\", \"2014-09-07\"), (\"2014-09-19 00:00:00\", \"2015-09-07\"), (\"2015-09-10 00:00:00\", \"5999-12-31\")]), f\"Expected pred_result and sol_result to be the same, but pred_result is {pred_sqls_result} and sol_result is [('2014-09-08 00:00:00', '2014-09-18'), ('2015-09-08 00:00:00', '2015-09-09'), ('2010-02-22 00:00:00', '2010-09-07'), ('2010-09-08 00:00:00', '2014-09-07'), ('2014-09-19 00:00:00', '2015-09-07'), ('2015-09-10 00:00:00', '5999-12-31')].\""]}
{"instance_id": "PostgreSQL_173", "sol_sql": ["select position, array_agg(driverid) as driverids from results where driverid not in (select max(driverid) from results group by position) group by position order by position;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_174", "sol_sql": ["DO $do$ DECLARE _max_depth int := (SELECT max(length(id::text)) - 1 FROM superhero2); _depth int; BEGIN FOR _depth IN REVERSE _max_depth .. 1 LOOP UPDATE superhero2 p SET color = c.color FROM (SELECT parent_id AS parent, CASE WHEN min(color) = max(color) THEN min(color) ELSE 'gray' END AS color FROM superhero2 WHERE length(id::text) = _depth + 1 GROUP BY parent_id) c WHERE p.id = c.parent AND p.color IS DISTINCT FROM c.color; END LOOP; END $do$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    assert set(pred_sqls_result) == set(sol_sqls_result), f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_175", "sol_sql": ["SELECT * \nFROM (\n  SELECT gender_id, COUNT(*) as cnt1 \n  FROM superhero \n  WHERE gender_id IN (1, 2) \n  GROUP BY gender_id\n) AS g1\nFULL OUTER JOIN (\n  SELECT alignment_id, COUNT(*) as cnt2 \n  FROM superhero \n  WHERE alignment_id IN (1, 2) \n  GROUP BY alignment_id\n) AS a1\nON g1.gender_id = a1.alignment_id\nWHERE COALESCE(g1.gender_id, a1.alignment_id) IN (1, 2);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_176", "sol_sql": ["SELECT artist, setcode, COUNT(setcode) AS counter\nFROM cards\nGROUP BY artist, setcode\nORDER BY MAX(COUNT(*)) OVER (PARTITION BY artist) DESC, artist, COUNT(*) DESC, setcode;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_177", "sol_sql": ["SELECT match_id, current_lineup, next_lineup, (SELECT COUNT(DISTINCT arr) FROM unnest(current_lineup) arr WHERE arr = ANY(next_lineup)) AS overlapping_players FROM match_lineups;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)       \n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_178", "sol_sql": ["SELECT rec.circuitid, rec.name FROM circuit_json, jsonb_to_record(circuit_id_name::jsonb) AS rec(circuitid int, name text);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)       \n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_179", "sol_sql": ["INSERT INTO hero_attribute_bifurcation (hero_id, attribute_id, attribute_chunk, is_bifurcated) SELECT ha.hero_id,\n       ha.attribute_id,\n       CASE \n           WHEN (g.c + 1) * 50 > ha.attribute_value \n           THEN ha.attribute_value - g.c * 50\n           ELSE 50\n       END AS attribute_chunk,\n       CAST(ha.attribute_value > 50 AS integer) AS is_bifurcated\nFROM hero_attribute AS ha\nCROSS JOIN LATERAL generate_series(0, (ha.attribute_value - 1) / 50) AS g(c)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT attribute_chunk, is_bifurcated FROM hero_attribute_bifurcation WHERE hero_id = 1 and attribute_id = 1;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 50, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[0][1] == 1, f'Expected is_bifurcated to match, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][0] == 30, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[1][1] == 1, f'Expected name to match, but found {test_pred_query_result_1[1][1]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT attribute_chunk, is_bifurcated FROM hero_attribute_bifurcation WHERE hero_id = 748 and attribute_id = 6;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 45, f'Expected attribute_chunk to match, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[0][1] == 0, f'Expected is_bifurcated to match, but found {test_pred_query_result_1[0][1]}'\n"]}
{"instance_id": "PostgreSQL_180", "sol_sql": ["SELECT y.district_id, \n       array_agg(y.loan_id) FILTER (WHERE y.status IN ('A', 'B')) AS type_A_B, \n       array_agg(y.loan_id) FILTER (WHERE y.status = 'C') AS type_C\nFROM (\n  SELECT x.district_id, l.loan_id, l.status\n  FROM loan l\n  JOIN account x ON l.account_id = x.account_id\n) y\nGROUP BY 1\nORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f'Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}'\n"]}
{"instance_id": "PostgreSQL_181", "sol_sql": ["WITH labeled_ends AS (SELECT lag(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts - interval '5' minute IS NOT TRUE AS begins_period, sa.ts, lead(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts + interval '5' minute IS NOT TRUE AS ends_period, sa.superhero_id, sa.activity_code FROM superhero_activities sa), periods AS (SELECT labeled_ends.ts, CASE WHEN labeled_ends.ends_period THEN labeled_ends.ts ELSE lead(labeled_ends.ts) OVER (PARTITION BY labeled_ends.superhero_id, labeled_ends.activity_code ORDER BY labeled_ends.ts) END AS period_end, labeled_ends.superhero_id, labeled_ends.activity_code, labeled_ends.begins_period FROM labeled_ends WHERE labeled_ends.begins_period OR labeled_ends.ends_period) SELECT tstzrange(periods.ts, periods.period_end, '[]') AS valid_interval, periods.superhero_id, periods.activity_code FROM periods WHERE periods.begins_period ORDER BY periods.superhero_id, periods.activity_code, periods.ts;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_182", "sol_sql": ["SELECT COUNT(DISTINCT tournament_id) FROM card_matches WHERE player1_id IN (SELECT id FROM card_players WHERE type = 'Pro') OR player2_id IN (SELECT id FROM card_players WHERE type = 'Pro')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_183", "sol_sql": ["SELECT league_id, season, STRING_AGG(DISTINCT id::TEXT, ',') as match_ids, STRING_AGG(DISTINCT date:: TEXT, ',') AS match_dates FROM match WHERE season IS NOT NULL AND league_id IS NOT NULL AND date IS NOT NULL GROUP BY league_id, season order by league_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_184", "sol_sql": ["SELECT row_id, MAX(CASE WHEN col_name = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' THEN value ELSE NULL END) AS card1, MAX(CASE WHEN col_name = '56f4935b-f6c5-59b9-88bf-9bcce20247ce' THEN value ELSE NULL END) AS card2, MAX(CASE WHEN col_name = '6d268c95-c176-5766-9a46-c14f739aba1c' THEN value ELSE NULL END) AS card3 FROM (SELECT uuid as col_name, text as value, ROW_NUMBER() OVER (PARTITION BY uuid ORDER BY id) as row_id FROM ruling) r group by row_id order by row_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_185", "sol_sql": ["\nSELECT c.*\nFROM cards_info c\nWHERE NOT EXISTS (\n    SELECT * \n    FROM card_choice cc\n    WHERE cc.non_valid_cards::jsonb @> to_jsonb(c.id)\n    AND cc.card_id = c.id\n);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT * FROM card_choice cc WHERE cc.card_id = {pred_query_result[i][0]} AND cc.non_valid_cards::jsonb @> to_jsonb({pred_query_result[i][0]});\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0]\n        assert test_pred_query_result_1 == [], f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    "]}
{"instance_id": "PostgreSQL_186", "sol_sql": ["\nWITH RECURSIVE RCTE_NODES AS (\n  SELECT\n    uuid\n  , card_name AS name\n  , uuid as root_uuid\n  , card_name as root_name\n  , 1 as lvl\n  , ARRAY[]::uuid[] as children\n  , true as has_next\n  FROM card_type\n  WHERE parent_uuid IS null\n\n  UNION ALL\n\n  SELECT\n    cat.uuid\n  , cat.card_name AS name\n  , cte.root_uuid\n  , cte.root_name\n  , cte.lvl+1\n  , cte.children || cat.uuid\n  , (exists(select 1 from card_type cat2 where cat2.parent_uuid = cat.uuid))\n  FROM RCTE_NODES cte\n  JOIN card_type cat\n    ON cat.parent_uuid = cte.uuid\n)\nSELECT root_uuid as uuid, root_name as name\n, array_agg(children) as children\nFROM RCTE_NODES\nWHERE has_next = false\nGROUP BY root_uuid, root_name\nORDER BY root_uuid;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT parent_uuid FROM card_type WHERE card_name = '{pred_query_result[0][1]}';\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0][0]\n        assert test_pred_query_result_1[0] is None, f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    "]}
{"instance_id": "PostgreSQL_187", "sol_sql": ["SELECT d.the_day AS \"Date\", COUNT(DISTINCT e.event_id) AS \"Number of Events\", AVG(b.avg_remaining) AS \"Avg Remaining Budget\" FROM (SELECT ts::date AS the_day FROM generate_series('2020-01-01'::timestamp, '2020-03-31'::timestamp, '1 day'::interval) AS ts) d LEFT JOIN \"event\" e ON e.event_date::date = d.the_day AND e.status IN ('Open', 'Closed') LEFT JOIN (SELECT link_to_event, SUM(remaining) as avg_remaining FROM budget GROUP BY link_to_event) b ON b.link_to_event = e.event_id GROUP BY d.the_day ORDER BY d.the_day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) == 91, f'Expected 91 rows, but found {len(pred_query_result_1)} rows'\n    assert str(pred_query_result_1[0][0]) == '2020-01-01', f'Expected the first date to be 2020-01-01, but found {pred_query_result_1[0][0]}'\n    assert str(pred_query_result_1[-1][0]) == '2020-03-31', f'Expected the last date to be 2020-03-31, but found {pred_query_result_1[-1][0]}'\n    assert pred_query_result_1[13][1] == 2, f'Expected the number of events on 2020-01-14 day to be 2, but found {pred_query_result_1[13][1]}'\n    assert pred_query_result_1[27][2] > 0, f'Expected the average remaining budget on 2020-01-28 day to be greater than 0, but found {pred_query_result_1[27][2]}'\n    assert pred_query_result_1[41][1] == 1, f'Expected the number of events on 2020-02-11 day to be 1, but found {pred_query_result_1[41][1]}'\n    assert pred_query_result_1[33][2] is None or pred_query_result_1[33][2] >= 0, f'Expected the average remaining budget on 2020-02-02 day to be 0 or NULL, but found {pred_query_result_1[33][2]}'\n\n    "]}
{"instance_id": "PostgreSQL_188", "sol_sql": ["SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1997 THEN trans.amount ELSE 0 END) AS a1997, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1998 THEN trans.amount ELSE 0 END) AS a1998 FROM trans WHERE trans.date >= '1997-01-01' AND trans.date < '1999-01-01' GROUP BY month ORDER BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    print(pred_query_result_1)\n    assert len(pred_query_result_1) == 12, f'Expected 12 rows (one for each month), but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == '01', 'The first month should be January (01).'\n    assert pred_query_result_1[-1][0] == '12', 'The last month should be December (12).'\n    assert pred_query_result_1[0][2] is not None, 'The sum of transactions for January 1998 should not be None.'\n    test_pred_query_result_1 = execute_queries([\"SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(trans.amount) AS total FROM trans WHERE EXTRACT(YEAR FROM trans.date) = 1997 GROUP BY month ORDER BY month;\"], db_name, conn)[0]\n    assert pred_query_result_1[0][1] == test_pred_query_result_1[0][1], f'Expected the sum of transactions for January 1997 to be {test_pred_query_result_1[0][1]}, but found {pred_query_result_1[0][1]}.'\n\n    "]}
{"instance_id": "PostgreSQL_189", "sol_sql": ["SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) > 0, 'Expected at least one circuit within the given distance, but found none.'\n    assert pred_query_result_1[0][2] == 'Hungaroring', 'Expected the first circuit to be Hungaroring, but found a different one.'\n    assert pred_query_result_1[2][2] == 'Zeltweg', 'Expected the first circuit to be Zeltweg, but found a different one.'\n    test_pred_query_result_1 = execute_queries([\"SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));\"], db_name, conn)[0]\n    assert pred_query_result_1[0][0] == test_pred_query_result_1[0][0], f'Expected circuit count to match, but found {pred_query_result_1[0][0]} instead of {test_pred_query_result_1[0][0]}.'\n\n    "]}
{"instance_id": "PostgreSQL_190", "sol_sql": ["SELECT resultid FROM results where driverid in (3, 4) order by resultid DESC LIMIT 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_191", "sol_sql": ["CREATE OR REPLACE FUNCTION words_get_uid(in_social integer, in_sid text) RETURNS integer AS $func$ SELECT uid FROM words_social WHERE social = in_social AND sid = in_sid; $func$ LANGUAGE sql IMMUTABLE;", "CREATE OR REPLACE FUNCTION words_get_chat(in_gid integer, in_uid integer) RETURNS TABLE (out_mine integer, out_msg text) AS $func$ SELECT CASE WHEN c.uid = in_uid THEN 1 ELSE 0 END, c.msg FROM words_chat c JOIN words_games g USING (gid) JOIN words_users opponent ON (opponent.uid IN (g.player1, g.player2) AND opponent.uid <> in_uid) WHERE c.gid = in_gid AND (c.uid = in_uid OR NOT opponent.muted) ORDER BY c.created ASC; $func$ LANGUAGE sql;", "SELECT words_get_chat(10, words_get_uid(100, 'abc')) AS nice_user;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_192", "sol_sql": ["WITH cte AS (SELECT driverid, points, (points * 100) as earnings FROM driverstandings) SELECT driverid, points, earnings, CASE WHEN earnings > 5000 THEN earnings * 0.2 WHEN earnings > 3000 THEN earnings * 0.15 ELSE null END AS bonus FROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count_price_times = sum(sql.lower().count('points * 100') for sql in pred_sqls)\n    assert count_price_times <= 3, f'Expected at most 3 occurrences of \"price * 100\" in the query, but got {count_price_times}.'\n"]}
{"instance_id": "PostgreSQL_193", "sol_sql": ["with dataset as (\n  SELECT \n      date,\n      COUNT(*) as rows_added\n  FROM\n      team_attributes\n  WHERE \n      date between '2010-01-01 00:00:00'\n      AND '2015-12-31 00:00:00'\n  GROUP BY \n      date\n )\nSELECT\n    COUNT(*) as total_days_in_result_set,\n    COUNT(DISTINCT rows_added) as total_days_w_distinct_record_counts,\n    COUNT(*) - COUNT(DISTINCT rows_added) as total_days_w_duplicate_record_counts,\n    COUNT(*) - COUNT(DISTINCT date) as duplicate_dates\nFROM dataset"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_194", "sol_sql": ["insert into card_counters (card_name, counters) values ('Lightning Bolt', array[2,0,2,1]) on conflict (card_name) do update set counters = (select array_agg(e1 + e2) from unnest(card_counters.counters, excluded.counters) as u(e1, e2))"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries([\"SELECT * FROM card_counters;\"], db_name, conn)[0]\n    sol_sqls_result = [('Lightning Bolt', [3, 3, 3, 1])]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_195", "sol_sql": ["CREATE OR REPLACE FUNCTION f_special_running_sum() RETURNS TABLE(id int, result numeric(10,6)) LANGUAGE plpgsql AS $func$ DECLARE t record; BEGIN DROP TABLE IF EXISTS pg_temp.result; CREATE TEMP TABLE result (id int, trx int, result float8) ON COMMIT DROP; FOR t IN TABLE sales_transactions ORDER BY id LOOP INSERT INTO result(id, trx, result) SELECT t.id, t.trx, (COALESCE(sum(r.trx + r.result), 0) + t.trx) * t.event FROM result r; END LOOP; RETURN QUERY SELECT r.id, r.result::numeric(10,6) FROM result r; END $func$;", "SELECT * FROM f_special_running_sum();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_196", "sol_sql": ["WITH cte_funding_count AS (SELECT fundingtype, COUNT(*) AS count FROM schools GROUP BY fundingtype), p as( SELECT fundingtype,  count,  ROUND(count*100./(SELECT SUM(count) FROM cte_funding_count),0) AS percent FROM cte_funding_count ) select fundingtype, count, case(row_number() over(order by percent desc)) when 1  then 100 - sum(percent) over(order by percent desc rows between 1 following and unbounded following)  else percent end pp from p"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    total = sum([item[2] for item in pred_sqls_result])\n    assert total == 100, f'Expected the total percentage is 100, but found {total}'"]}
{"instance_id": "PostgreSQL_197", "sol_sql": ["WITH RankedLabs AS (SELECT lab.date AS firstActivity, pat.ID as id, ROW_NUMBER() OVER (PARTITION BY pat.id ORDER BY lab.date ASC) AS rn FROM patient pat JOIN laboratory lab ON lab.id = pat.id AND lab.date <= pat.description AND lab.date > pat.\"First Date\" WHERE pat.sex = 'F') SELECT firstActivity, id FROM RankedLabs WHERE rn = 1 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_198", "sol_sql": ["CREATE or replace FUNCTION f_arr_except_arr(a1 text[], a2 text[])  RETURNS text[] LANGUAGE SQL IMMUTABLE PARALLEL SAFE BEGIN ATOMIC SELECT ARRAY (SELECT unnest(a1) EXCEPT ALL SELECT unnest(a2)); END;", "SELECT id, f_arr_except_arr(string_to_array(c.keywords, ',')::text[], s.RemoveKeywords) AS updated_keywords FROM  cards c JOIN (SELECT id, RemoveKeywords FROM SelectQuery) s USING (id) order by id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_199", "sol_sql": ["SELECT week_start, count(*) AS count, AVG(\"CL\") AS cl, AVG(\"C\") AS c FROM (SELECT generate_series('2021-01-07 00:00:00'::timestamp, '2022-01-06 23:59:59'::timestamp, '7 days'::interval) AS week_start) gs INNER JOIN \"Experiment\" e ON e.\"TIMESTAMP\" >= gs.week_start AND e.\"TIMESTAMP\" < gs.week_start + '7 days'::interval GROUP BY week_start ORDER BY week_start ASC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_200", "sol_sql": ["\n    CREATE FUNCTION calculate_loan_status() \n    RETURNS SETOF loan_last\n    AS $$\n    BEGIN\n    CREATE TABLE  IF NOT EXISTS temp_table AS\n    SELECT loan_id, status\n    FROM loan_first;\n    INSERT INTO loan_last SELECT loan_id, status FROM temp_table; \n    DROP TABLE temp_table;\n    END;\n    $$ LANGUAGE plpgsql;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"DROP FUNCTION IF EXISTS calculate_loan_status;\"], db_name, conn)\n    res, exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert exec_err == False\n    "]}
{"instance_id": "PostgreSQL_201", "sol_sql": ["SELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite, EXISTS (SELECT 1 FROM frpm WHERE frpm.cdscode = schools.cdscode) AS has_frpm_data FROM schools LEFT OUTER JOIN satscores ON schools.cdscode = satscores.cds WHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_202", "sol_sql": ["UPDATE superhero SET total_powers = (SELECT COUNT(power_id) FROM hero_power WHERE hero_id = superhero.id)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\""]}
{"instance_id": "PostgreSQL_203", "sol_sql": ["SELECT id,\n       date,\n       got,\n       gpt\nFROM (\n    SELECT t.*,\n           ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY t.date DESC) AS rn,\n           COUNT(*) OVER (PARTITION BY t.id) AS cnt\n    FROM Laboratory t\n) AS sub\nWHERE rn = 1\n  AND cnt > 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_204", "sol_sql": ["SELECT combined_score, combined_score as total_score FROM satscores, LATERAL(SELECT (avgscrread + avgscrmath + avgscrwrite)) AS subquery(combined_score);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    equation = \"avgscrread + avgscrmath + avgscrwrite\"\n    count = pred_sqls[0].count(equation)\n    assert count == 1, f\"sol_sqls returned {count} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_205", "sol_sql": ["with u as (select *, row_number() over(order by circui_name_A1, circui_name_A2, circui_name_A3, circui_name_B1, circui_name_B2, circui_name_B3) as rn from race_info), v as (select circui_name_A1 AS A, circui_name_B1 as B, rn from u union all select circui_name_A2 AS A, circui_name_B2 as B, rn from u union all select circui_name_A3 AS A, circui_name_B3 as B, rn from u) select string_agg(A, ' ' order by A) as A, string_agg(B, ' ' order by B) as B from v group by rn"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_206", "sol_sql": ["WITH day_min_time AS (SELECT Min(date_value) min_time, Date(date_value) dt, card_id FROM card_prices GROUP BY Date(date_value), card_id), day_max_time AS (SELECT Max(cp.date_value) max_time, Date(cp.date_value) dt, cp.card_id FROM card_prices cp JOIN day_min_time dmt ON cp.card_id = dmt.card_id AND Date(cp.date_value) = dmt.dt WHERE cp.date_value <= dmt.min_time + interval '15 minutes' GROUP BY date(cp.date_value), cp.card_id) SELECT card_id, round(avg(price_difference)) average_difference FROM (SELECT max(cp.price)-min(cp.price) price_difference, cp.card_id, date(cp.date_value) FROM card_prices cp INNER JOIN day_min_time min_dmt ON min_dmt.card_id = cp.card_id AND date(cp.date_value) = min_dmt.dt INNER JOIN day_max_time max_dmt ON max_dmt.card_id = cp.card_id AND date(cp.date_value) = max_dmt.dt WHERE cp.date_value BETWEEN min_dmt.min_time AND max_dmt.max_time GROUP BY cp.card_id, date(cp.date_value)) final_inline_view GROUP BY card_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_207", "sol_sql": ["SELECT bond_id as current_bond, LEAD(bond_id) OVER (ORDER BY bond_id) as next_bond, bond_type as bond_type FROM bond b"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_208", "sol_sql": ["SELECT timestamp, avg(strength) over (partition by (date_trunc('hour', timestamp - interval '1 minute'))) as avg_strength FROM bond_strength WHERE timestamp >= date_trunc('hour', '2023-10-01 02:30:00'::timestamp) - INTERVAL '1 hour' AND timestamp < date_trunc('hour', '2023-10-01 02:30:00'::timestamp)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_209", "sol_sql": ["select jsonb_set(t.data, '{purchaseurls}', (select jsonb_agg(case when v.value::text ~ 'tcgplayer' or v.value::text ~ 'cardKingdom' then v.value::text else md5(v.value::text) end) from jsonb_array_elements(t.data -> 'purchaseurls') v)) from cards_info t"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_210", "sol_sql": ["select t1.product_id, t1.sales_value - t2.sales_value from sales_data t1 join sales_data t2 on t1.product_id = t2.product_id and t2.date_num = 567 where t1.date_num = 123"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_211", "sol_sql": ["DROP TABLE IF EXISTS temp_superhero;", "CREATE TABLE temp_superhero (id int);", "CREATE OR REPLACE FUNCTION insert_and_return(int) RETURNS int AS $$ BEGIN INSERT INTO temp_superhero VALUES ($1); RETURN $1; END; $$ LANGUAGE plpgsql;", "table temp_superhero union all select insert_and_return(10);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_212", "sol_sql": ["SELECT count(*) FROM (SELECT DISTINCT molecule_id FROM bond WHERE bond_type != '-') AS molecule_without_bond_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_213", "sol_sql": ["create or replace function setup_vector_store(table_name text) returns void language plpgsql as $f1$ begin execute format($dynsql$ create table %1$I (id bigint primary key generated always as identity, description text, metadata jsonb); drop function if exists match_strategies(int, jsonb); create function match_strategies (match_count int default null, filter jsonb default '{}'::jsonb) returns table (id bigint, description text, metadata jsonb, similarity float) language plpgsql as $f2$ begin return query select id, description, metadata, 1 as similarity from %1$I where metadata @> filter limit match_count; end; $f2$; $dynsql$, table_name); end; $f1$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    execute_queries([\"SELECT setup_vector_store('my_strategy');\"], db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'my_strategy';\"], db_name, conn)[0]\n    execute_queries(sol_sqls, db_name, conn)\n    execute_queries([\"DROP TABLE IF EXISTS my_strategy\"], db_name, conn)\n    execute_queries([\"SELECT setup_vector_store('my_strategy');\"], db_name, conn)\n    sol_sqls_result = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'my_strategy';\"], db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_214", "sol_sql": ["SELECT sd.name AS \"Country\", td.years AS \"Year\", bt.name AS \"ProductType\", pl.name AS \"Language\", g.name AS \"Genre\", COALESCE(SUM(dp.value), 0) AS \"sum\" FROM spatial_dimension sd CROSS JOIN time_dimension td CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'ProductType')) bt CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'publishing_language')) pl CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'genre')) g LEFT JOIN datapoints dp ON dp.spatial_dimension_id = sd.id AND dp.time_dimension_id = td.id AND EXISTS (SELECT 1 FROM datapoint_variablevalue dv WHERE dv.datapoint_id = dp.id AND dv.variablevalue_id IN (bt.id, pl.id, g.id) GROUP BY dv.datapoint_id HAVING COUNT(DISTINCT dv.variablevalue_id) = 3) GROUP BY sd.name, td.years, bt.name, pl.name, g.name ORDER BY \"Year\" DESC, \"Country\", \"ProductType\", \"Language\", \"Genre\";"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_215", "sol_sql": ["SELECT relname, pg_size_pretty(pg_relation_size(relid)) AS table_size FROM pg_stat_user_tables ORDER BY pg_relation_size(relid) DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_216", "sol_sql": ["WITH booking_days AS (SELECT *, CASE WHEN start_at::time = '00:00:00' THEN start_at ELSE date_trunc('day', start_at) + interval '1 day' END AS start_at_next_day, date_trunc('day', end_at) AS end_at_whole_day FROM stadium_bookings) SELECT booking_id, stadium_id, start_at, end_at FROM booking_days WHERE end_at_whole_day < start_at_next_day UNION ALL SELECT booking_id, stadium_id, start_at_next_day, end_at_whole_day FROM booking_days WHERE end_at_whole_day > start_at_next_day UNION ALL SELECT booking_id, stadium_id, start_at, start_at_next_day FROM booking_days WHERE end_at_whole_day >= start_at_next_day AND start_at::time > '00:00:00' UNION ALL SELECT booking_id, stadium_id, end_at_whole_day, end_at FROM booking_days WHERE end_at_whole_day >= start_at_next_day AND end_at::time > '00:00:00' ORDER BY booking_id, stadium_id, start_at;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    le = len(pred_sqls[0])\n    assert le <= 1212, f\"pred_sqls length is {le}, which is not simpler.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_217", "sol_sql": ["SELECT string_agg(token, '#') AS result FROM (SELECT token, idx, row_number() OVER (ORDER BY idx) AS rn FROM match_events, string_to_table(event_description, '#') WITH ORDINALITY AS a(token, idx) GROUP BY token, idx HAVING count(token) = (SELECT count(*) FROM match_events) ORDER BY idx) sub WHERE  idx = rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_218", "sol_sql": ["SELECT player_api_id, player_name FROM player WHERE id = (SELECT MAX(id) FROM player WHERE player_name LIKE 'Ale%' AND player_fifa_api_id > 220000);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_219", "sol_sql": ["SELECT match_id, match_date FROM detail WHERE jsonb_path_exists (match_details, '$.player_stats[*] ? (@.player_id == $playerId && @.goals > 0)', jsonb_build_object('playerId', 103));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_220", "sol_sql": ["SELECT country, predicate_code, MAX(value) FILTER (WHERE metric_code = 'metric_1') AS metric_1, MAX(value) FILTER (WHERE metric_code = 'metric_2') AS metric_2 FROM (SELECT country, metric_code, 'male' AS predicate_code, male AS value FROM data_detail UNION ALL SELECT country, metric_code, 'female', female FROM data_detail UNION ALL SELECT country, metric_code, 'pensioners', pensioners FROM data_detail UNION ALL SELECT country, metric_code, 'teenagers', teenagers FROM data_detail) AS unpivoted GROUP BY country, predicate_code ORDER BY country, predicate_code;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n\n    "]}
{"instance_id": "PostgreSQL_221", "sol_sql": ["WITH t AS (SELECT bond_id AS id, j.val, SUM((j.val ->> 'time')::numeric) OVER (partition by bond_id) AS s FROM bond CROSS JOIN LATERAL jsonb_each(bond_stat_) AS j(k, val)) SELECT id, val FROM t WHERE val ->> 'type' = 'Unknown' AND (val ->> 'time')::numeric > 0.1 * s;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows.'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n   pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]   \n   for i in range(2):\n      if pred_query_result[i][0] == \"TR000_1_2\":\n         assert pred_query_result[i][1] == {\"time\": 500, \"type\": \"Unknown\", \"complete\": 100.0}, \"Wrong result 1.\"  \n      elif pred_query_result[i][0] == \"TR000_2_4\":\n         assert pred_query_result[i][1] == {\"time\": 55, \"type\": \"Unknown\", \"complete\": 100.0}, \"Wrong result 2.\"\n      else:\n         assert False, \"Wrong ID.\"\n    "]}
{"instance_id": "PostgreSQL_222", "sol_sql": ["CREATE OR REPLACE FUNCTION public.corrected_function(type text DEFAULT 'Unknown'::text) RETURNS SETOF bond LANGUAGE sql STABLE AS $function$ select * from bond where bond_stat_ @? '$.** ? (@ == \"Unknown\")'; $function$", "SELECT bond_id FROM corrected_function();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_223", "sol_sql": ["CREATE OR REPLACE FUNCTION check_conditional_unique() RETURNS TRIGGER AS $f$ BEGIN IF EXISTS (SELECT FROM match_results t2 WHERE (t2.match_id,t2.team_id) = (NEW.match_id,NEW.team_id) AND t2.score <> NEW.score) THEN RAISE EXCEPTION 'New values in score for the same match_id and team_id combination.'; END IF; IF EXISTS (SELECT FROM match_results t2 WHERE (t2.match_id,t2.team_id) <> (NEW.match_id,NEW.team_id) AND t2.score = NEW.score) THEN RAISE EXCEPTION 'Duplicate values in score for different match_id and team_id combination.'; END IF; RETURN NEW; END; $f$ LANGUAGE plpgsql;", "CREATE OR REPLACE TRIGGER check_unique_score_per_match_team BEFORE INSERT OR UPDATE ON match_results FOR EACH ROW EXECUTE FUNCTION check_conditional_unique();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    q1 = [\"INSERT INTO match_results (match_id, team_id, score) VALUES (1, 101, 7);\"]\n    execute_queries(q1, db_name, conn)\n    test = [\"SELECT * FROM match_results;\"]\n    pred_query_result = execute_queries(test, db_name, conn)[0]\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows.'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    q2 = [\"INSERT INTO match_results (match_id, team_id, score) VALUES (3, 101, 2);\"]\n    execute_queries(q2, db_name, conn)\n    test = [\"SELECT * FROM match_results;\"]\n    pred_query_result = execute_queries(test, db_name, conn)[0]\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows.'\n    "]}
{"instance_id": "PostgreSQL_224", "sol_sql": ["WITH RECURSIVE monthly_periods AS (SELECT rate, lower(time_span) AS start_date, upper(time_span) AS end_date FROM budgets UNION ALL SELECT rate, (start_date + interval '1 month')::date, end_date FROM monthly_periods WHERE start_date + interval '1 month' <= now() OR (end_date IS NOT NULL AND start_date + interval '1 month' < end_date)), daily_rates AS (SELECT rate, start_date, LEAST((start_date + interval '1 month')::date, CASE WHEN end_date IS NULL THEN now()::date ELSE end_date::date END) as period_end FROM monthly_periods ), days_in_period AS (SELECT rate, start_date, period_end, EXTRACT(DAY FROM (period_end - start_date)) as days_in_period FROM daily_rates), daily_series AS (SELECT rate, start_date, period_end, generate_series(start_date, period_end, '1 day'::interval) as day FROM days_in_period WHERE days_in_period > 0) SELECT day::date, rate / EXTRACT(DAY FROM (period_end - start_date)) as daily_rate FROM daily_series ORDER BY day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "PostgreSQL_225", "sol_sql": ["CREATE OR replace FUNCTION to_number(argument text, default_result integer default -1) RETURNS integer LANGUAGE plpgsql AS $$  BEGIN RETURN argument::integer; EXCEPTION WHEN OTHERS THEN RETURN default_result; END $$; SELECT attribute_name, to_number(attribute_name) FROM attribute;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_226", "sol_sql": ["SELECT molecule_id, COUNT(*) AS total_bonds FROM bond GROUP BY molecule_id HAVING COUNT(*) > 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_227", "sol_sql": ["WITH range_values AS ( SELECT date_trunc('week', min(date)) as minval, date_trunc('week', max(date)) as maxval FROM laboratory ), week_range AS ( SELECT generate_series(date_trunc('week', '1991-01-01'::date), now(), '1 week') as week FROM range_values ), grouped_labs AS ( SELECT date_trunc('week', date) as week, count(id) as total_tests FROM laboratory WHERE date >= '1991-01-01' GROUP BY 1 ) SELECT week_range.week, COALESCE(sum(total_tests)::integer, 0) AS total_labs FROM week_range LEFT OUTER JOIN grouped_labs on week_range.week = grouped_labs.week GROUP BY 1 ORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_228", "sol_sql": ["DROP FUNCTION IF EXISTS update_school_inventory_after_supply() CASCADE; CREATE OR REPLACE FUNCTION update_school_inventory_after_supply() RETURNS TRIGGER LANGUAGE plpgsql AS $trigger$ BEGIN UPDATE school_inventory AS s SET quantity = s.quantity - coalesce(OLD.quantity,0) + coalesce(NEW.quantity,0)WHERE s.cdscode = NEW.cdscode AND s.supply_name = NEW.supply_name; RETURN NEW; END; $trigger$; DROP TRIGGER IF EXISTS trigger_insert_supply ON school_supplies; CREATE TRIGGER trigger_insert_supply AFTER INSERT ON school_supplies FOR EACH ROW EXECUTE FUNCTION update_school_inventory_after_supply();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT cdscode, coalesce(ncesschool, '0') FROM schools ORDER BY cdscode LIMIT 1;\"], db_name,conn)\n    res_cdscode, res_nces = res[0][0], res[0][1]\n    check_sql = [f\"INSERT INTO school_inventory (cdscode, supply_name, quantity) VALUES ('{res_cdscode}', 'Pencils', {res_nces});\"]\n    execute_queries(check_sql, db_name,conn)\n    check_sql = [f\"INSERT INTO school_supplies (cdscode, supply_name, quantity) VALUES ('{res_cdscode}', 'Pencils', 100);\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT cdscode, quantity FROM school_inventory WHERE cdscode = '{res_cdscode}' LIMIT 1;\"], db_name,conn)\n    res_cdscode, quantity = res[0][0], res[0][1]\n    assert quantity == int(res_nces)+100, f\"The trigger does not work.\"\n"]}
{"instance_id": "PostgreSQL_229", "sol_sql": ["SELECT s.cname AS county, sch.school, AVG(s.avgscrread + s.avgscrmath + s.avgscrwrite) / 3 AS avg_total_sat FROM satscores s JOIN schools sch ON s.cds = sch.cdscode WHERE s.cname IN (SELECT s.cname FROM satscores s GROUP BY s.cname ORDER BY AVG(s.avgscrread + s.avgscrmath + s.avgscrwrite) / 3 DESC nulls last LIMIT 5) GROUP BY s.cname, sch.school ORDER BY s.cname, avg_total_sat DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_230", "sol_sql": ["WITH vars AS (SELECT max(date) AS vars_id FROM laboratory) SELECT * FROM laboratory l JOIN vars ON l.date = vars.vars_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_231", "sol_sql": ["\nSELECT * FROM match_location\nWHERE ST_DWithin(\n    location::geography, \n    ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography,\n    2 * 1609.34\n);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases(\"SELECT id, ST_AsText(location) AS location, ST_Distance(location::geography, ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography) AS distance_in_meters FROM match_location WHERE ST_Distance(location::geography, ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography) <= 2 * 1609.34;\", db_name)[0]\n    assert len(test_pred_query_result_2) == len(pred_query_result), f'Expected {len(test_pred_query_result_2)} rows, but found {test_pred_query_result_2} rows'\n    "]}
{"instance_id": "PostgreSQL_232", "sol_sql": ["SELECT column_name\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE table_name = 'learners' AND\n      character_maximum_length = 15;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "PostgreSQL_233", "sol_sql": ["SELECT\n    x.curriculum_id,\n    COUNT(DISTINCT x.elem) AS distinct_count\nFROM\n(\n    -- First SELECT: unnest text columns (cast them to text if needed)\n    SELECT\n        c.curriculum_id,\n        unnest(ARRAY[e.\"Content_Type\", e.\"Platform_Used\"]::text[]) AS elem\n    FROM curriculum_resources cr\n    JOIN educational_resources e\n      ON cr.resource_key = e.resource_key\n    JOIN curricula c\n      ON c.curriculum_id = cr.curriculum_id\n\n    UNION\n\n    -- Second SELECT: unnest and cast boolean column to text\n    SELECT\n        c2.curriculum_id,\n        unnest(ARRAY[cr2.recommended::text]) AS elem\n    FROM curriculum_resources cr2\n    JOIN curricula c2\n      ON c2.curriculum_id = cr2.curriculum_id\n) AS x\nGROUP BY x.curriculum_id;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_234", "sol_sql": ["BEGIN;\n\n-- 1) Add a 'status' column to both tables IF it doesn't exist already.\n--    (PostgreSQL doesnt have \"IF NOT EXISTS\" for columns pre-v15, so we do a safe check.)\n\nDO $$\nBEGIN\n    -- Check if \"status\" column exists in \"curricula\".\n    IF NOT EXISTS (\n        SELECT 1 \n        FROM information_schema.columns\n        WHERE table_name = 'curricula'\n          AND column_name = 'status'\n    ) THEN\n        EXECUTE 'ALTER TABLE curricula ADD COLUMN status TEXT NOT NULL DEFAULT ''installed''';\n    END IF;\n\n    -- Check if \"status\" column exists in \"educational_resources\".\n    IF NOT EXISTS (\n        SELECT 1 \n        FROM information_schema.columns\n        WHERE table_name = 'educational_resources'\n          AND column_name = 'status'\n    ) THEN\n        EXECUTE 'ALTER TABLE educational_resources ADD COLUMN status TEXT NOT NULL DEFAULT ''installed''';\n    END IF;\nEND$$;\n\n-- 2) Recursively gather all curricula connected to your target (e.g. curriculum_id=1) \n--    via shared resources, then update them in one pass. Then also update resources.\n\nWITH RECURSIVE connected_curricula AS (\n    -- Base case: pick the single curriculum you want to upgrade\n    SELECT c.curriculum_id\n    FROM curricula c\n    WHERE c.curriculum_id = 1           -- set as needed\n      AND c.status = 'installed'        -- only if you want to filter by 'installed'\n    \n    UNION  -- (not UNION ALL) to avoid duplicates and infinite loops\n\n    -- Recursive step: find other curricula that share any resource\n    SELECT cr2.curriculum_id\n    FROM connected_curricula cte\n    JOIN curriculum_resources cr1 \n         ON cr1.curriculum_id = cte.curriculum_id\n    JOIN curriculum_resources cr2 \n         ON cr2.resource_key = cr1.resource_key\n    WHERE cr2.curriculum_id <> cte.curriculum_id\n),\nupdated_curricula AS (\n    UPDATE curricula\n    SET status = 'to upgrade'\n    WHERE curriculum_id IN (SELECT curriculum_id FROM connected_curricula)\n    RETURNING curriculum_id\n),\nupdated_resources AS (\n    UPDATE educational_resources er\n    SET status = 'to upgrade'\n    WHERE er.resource_key IN (\n      SELECT cr.resource_key\n      FROM curriculum_resources cr\n      JOIN connected_curricula cc \n        ON cr.curriculum_id = cc.curriculum_id\n    )\n    RETURNING resource_key\n)\n\n-- 3) Provide a final SELECT of counts, so psycopg2 has results to fetch\nSELECT\n    (SELECT COUNT(*) FROM updated_curricula) AS curricula_updated,\n    (SELECT COUNT(*) FROM updated_resources) AS resources_updated;\n\nCOMMIT;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    1) Execute all queries in pred_sqls.\n    2) Verify that the update(s) in pred_sqls actually changed at least one row to 'to upgrade'.\n       - If not, raise an error.\n    3) Optionally execute all queries in sol_sqls (your reference solution).\n    4) Print a message or raise errors accordingly.\n    \"\"\"\n\n    # 1) Execute the \"predicted\" SQL statements (the user's attempt).\n    execute_queries(pred_sqls, db_name, conn)\n\n    # 2) Test whether the update actually changed rows to 'to upgrade'.\n    #    For example, check if there's at least one row in `curricula` with status='to upgrade'.\n    #    (You can adapt this check if you also need to verify `educational_resources` or other tables.)\n    result = execute_queries(\n        [\"SELECT COUNT(*) FROM curricula WHERE status = 'to upgrade'\"],\n        db_name,\n        conn\n    )\n    count_updated = result[0][0][0] if result else 0\n\n    # Raise an error if no rows were updated to 'to upgrade'\n    if count_updated < 1:\n        raise AssertionError(\n            \"No rows were updated to 'to upgrade'. Your pred_sqls did not achieve the expected result.\"\n        )\n    else:\n        return 1"]}
{"instance_id": "PostgreSQL_235", "sol_sql": ["WITH working_hours AS (\n    SELECT \n        ru.learner_code, \n        ru.resource_key, \n        ru.start_timestamp, \n        ru.end_timestamp,\n        CASE\n            WHEN date_part('isodow', ru.start_timestamp) IN (1, 2, 3, 4, 5) THEN ru.start_timestamp + INTERVAL '9 hours'\n            ELSE NULL\n        END AS working_start,\n        CASE\n            WHEN date_part('isodow', ru.end_timestamp) IN (1, 2, 3, 4, 5) THEN ru.end_timestamp + INTERVAL '18 hours'\n            ELSE NULL\n        END AS working_end\n    FROM event_usage ru\n)\nSELECT \n    working_hours.learner_code, \n    working_hours.resource_key, \n    SUM(EXTRACT(EPOCH FROM (ru.end_timestamp - ru.start_timestamp))) AS total_time_spent_in_working_hours\nFROM working_hours\nJOIN event_usage ru\n    ON ru.learner_code = working_hours.learner_code\n    AND ru.resource_key = working_hours.resource_key\n    AND ru.start_timestamp = working_hours.start_timestamp\n    AND ru.end_timestamp = working_hours.end_timestamp\nWHERE\n    (ru.start_timestamp + INTERVAL '9 hours') < working_hours.working_end\n    AND (ru.end_timestamp + INTERVAL '18 hours') > working_hours.working_start\nGROUP BY working_hours.learner_code, working_hours.resource_key;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_236", "sol_sql": ["SELECT \n  last_value(rating) OVER (\n    PARTITION BY learner_code, resource_key \n    ORDER BY usage_date \n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS filled_rating, \n  learner_code, \n  resource_key \nFROM \n  resource_usage_2\nORDER BY \n  learner_code, usage_date;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_237", "sol_sql": ["select d::date, extract(epoch from ((case when T.incident_end::date = d::date then T.incident_end else d::date + interval '1 day' end)))/60 from race_incidents T cross join generate_series(T.incident_start, T.incident_end, interval '1 day') d;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_238", "sol_sql": ["SELECT p.id AS PatientID, MAX(CASE WHEN l.rn = 1 THEN l.ldh     END) AS PatientLDH1, MAX(CASE WHEN l.rn = 1 THEN l.alp END) AS PatientALP1, MAX(CASE WHEN l.rn = 2 THEN l.ldh END) AS PatientLDH2, MAX(CASE WHEN l.rn = 2 THEN l.alp END) AS PatientALP2,  MAX(CASE WHEN l.rn = 3 THEN l.ldh END) AS PatientLDH3, MAX(CASE WHEN l.rn = 3 THEN l.alp END) AS PatientALP3 FROM  patient p LEFT JOIN  (SELECT *, ROW_NUMBER() OVER(PARTITION BY id ORDER BY date) AS rn FROM laboratory) l ON p.id = l.id GROUP BY PatientID ORDER BY PatientID"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_239", "sol_sql": ["select driverid, time, rank, (CASE WHEN prno=1 THEN points::varchar ELSE '' END )AS points from(select DISTINCT driverid, time, rank, points, prno from (select driverid, 1, null, null, null, points::varchar, 1 as prno from results union all select driverid, 2, driverid::varchar, time, rank, points::varchar, 2 as prno from results) temp1 (xid, xord, driverid, time, rank,points,prno) order by points, prno) as temp2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_240", "sol_sql": ["select * from results r inner join drivers d on r.driverid = d.driverid where r.grid = 21 order by r.points desc limit 10;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_241", "sol_sql": ["INSERT INTO customer_orders(name, title) SELECT COALESCE(uo.name, co.name), COALESCE(uo.title, co.title) FROM customer_orders co LEFT OUTER JOIN updated_orders uo ON uo.id = co.id UNION ALL SELECT COALESCE(co.name, uo.name), COALESCE(uo.title, co.title) FROM customer_orders co LEFT OUTER JOIN updated_orders uo ON uo.id = co.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM customer_orders WHERE id = 2;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'new_test', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM customer_orders WHERE id=3;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'test', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": "PostgreSQL_242", "sol_sql": ["SELECT * FROM crosstab('SELECT superhero_name || ''-'' || performance_date AS category, attribute_name, MAX(result) FROM superhero_performance GROUP BY superhero_name, performance_date, attribute_name ORDER BY superhero_name, performance_date', 'SELECT DISTINCT attribute_name FROM superhero_performance ORDER BY attribute_name') AS ct(heroName_date TEXT, Intelligence text, Speed text, Strength text);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_243", "sol_sql": ["WITH set_date AS (SELECT MIN(date) AS mindt FROM laboratory), month_days AS (SELECT generate_series(date_trunc('month', mindt::date), date_trunc('month', mindt::date) + INTERVAL '1 month' - INTERVAL '1 day', INTERVAL '1 day') AS dt FROM set_date), admin_weeks AS (SELECT dt, (EXTRACT(DOW FROM dt) = 1 OR dt = date_trunc('month', dt)) AS week_start, SUM((EXTRACT(DOW FROM dt) = 1 OR dt = date_trunc('month', dt))::int) OVER (ORDER BY dt ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS week_number FROM month_days) SELECT * FROM admin_weeks ORDER BY dt;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_244", "sol_sql": ["select '2010-10-31' reporting_date, count(case when OpenDate<'2010-10-31' and ClosedDate>='2010-10-31' then 1 end) from schools;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "PostgreSQL_245", "sol_sql": ["WITH cte AS (SELECT category, amount, sum(amount)  OVER w AS cum_amount, row_number() OVER w AS count FROM budget WINDOW w AS (PARTITION BY category ORDER BY amount, budget_id)), foo AS (SELECT category, MAX(count) as count, MAX(cum_amount) as cum_amount FROM cte WHERE category = 'Food' AND cum_amount <= 500 GROUP BY category), adv AS (SELECT category, MAX(count) as count, MAX(cum_amount) as cum_amount FROM cte WHERE category = 'Advertisement' AND cum_amount <= (SELECT 500 - cum_amount FROM foo)GROUP BY category)SELECT category, count FROM foo UNION ALL SELECT category, count FROM adv"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result_1) == 2, f'Expected 2 rows, but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == 'Food', 'The first row category should be Food.'\n    assert pred_query_result_1[1][0] == 'Advertisement', 'The second row category should be Advertisement.'\n    assert pred_query_result_1[0][1] == 9, f'Expected count to be 9, but found {pred_query_result_1[0][1]}'\n    assert pred_query_result_1[1][1] == 1, f'Expected count to be 1, but found {pred_query_result_1[1][1]}'\n\n\n    "]}
{"instance_id": "PostgreSQL_246", "sol_sql": ["WITH non_1 AS (SELECT * FROM client WHERE district_id <> 1 LIMIT 900), district_1 AS (SELECT * FROM client WHERE district_id = 1 LIMIT 100) SELECT * FROM non_1 UNION ALL SELECT * FROM district_1 LIMIT 1000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result_1) == 1000, f'Expected 1000 rows, but found {len(pred_query_result_1)} rows'\n    assert sum(1 for row in pred_query_result_1 if row[3] == 1) <= 100, f'Expected maximum 100 district_id=1, but found {sum(1 for row in pred_query_result_1 if row[3]==1)}'\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) FROM client WHERE district_id <> 1\"], db_name, conn)[0]\n    assert len([row for row in pred_query_result_1 if row[3] != 1]) == min(900, test_pred_query_result_1[0][0]), f'Expected 900 non-1 district_id, but found {len([row for row in pred_query_result_1 if row[3]==1])}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) FROM client WHERE district_id = 1\"], db_name, conn)[0]\n    assert len([row for row in pred_query_result_1 if row[3] == 1]) == min(100, test_pred_query_result_2[0][0]), f'Expected 100 1-district_id, but found {len([row for row in pred_query_result_1 if row[3]]==1)}'\n    assert all(isinstance(row[0], int) and isinstance(row[3], int) for row in pred_query_result_1), 'All rows should have a integer client_id and a integer district_id'\n\n\n    "]}
{"instance_id": "PostgreSQL_247", "sol_sql": ["UPDATE card c SET type = (SELECT type FROM disp d WHERE d.disp_id = c.disp_id ORDER BY client_id LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT type FROM card WHERE card_id = 345;\"], db_name, conn)[0]\n    assert test_pred_query_result_1[0][0] == 'OWNER' or pred_query_result_1[0][0] == 'DISPONENT', f'The updated type of card_id 345 should be OWNER or DISPONENT, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT type FROM card;\"], db_name, conn)[0]\n    assert sum(1 for row in test_pred_query_result_3 if row[0] == \"OWNER\") == 892, f'Expected 892 OWNER, but found {sum(1 for row in test_pred_query_result_3 if row[0] == \"OWNER\")}'\n\n\n    "]}
{"instance_id": "PostgreSQL_248", "sol_sql": ["CREATE TABLE loan (loan_id SERIAL PRIMARY KEY, account_id INT, date DATE, amount INT, duration INT, payment INT, status CHARACTER); CREATE TABLE card (card_id SERIAL PRIMARY KEY, loan_id INT UNIQUE, type TEXT NOT NULL, issued DATE NOT NULL, CONSTRAINT fk_loan_id FOREIGN KEY (loan_id) REFERENCES loan(loan_id) ON DELETE CASCADE);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    set_up_1 = execute_queries([\"INSERT INTO card (card_id, type, issued) VALUES (1, 'gold', '2000-09-03'), (2, 'classic', '1997-09-03'), (3, 'platinum', '1995-09-03') RETURNING *;\"], db_name, conn)[0]\n    set_up_2 = execute_queries([\"INSERT INTO loan (loan_id, account_id, amount, duration, status, payments) VALUES (1, 1, 1000, 12, 'A', 100), (2, 1, 2000, 12, 'A', 200), (3, 1, 3000, 12, 'A', 300) RETURNING *;\"], db_name, conn)[0]\n    test_cases = [\n            {\n                \"query\": \"INSERT INTO card (loan_id, type, issued) VALUES (1, 'GOLD', '2024-01-01')\",\n                \"should_fail\": True,\n                \"error_message\": \"it should fail because the loan_id is already in the card table\"\n            },\n            \n            {\n                \"query\": \"INSERT INTO card (loan_id, type, issued) VALUES (999, 'GOLD', '2024-01-01')\",\n                \"should_fail\": True,\n                \"error_message\": \"it should fail because the loan_id is not in the loan table\"\n            },\n            \n            {\n                \"query\": \"DELETE FROM loan WHERE loan_id = 1\",\n                \"should_fail\": False,\n                \"verification_query\": \"SELECT COUNT(*) FROM card WHERE loan_id = 1\",\n                \"expected_count\": 0,\n                \"error_message\": \"it should be 0 because the loan_id was deleted\"\n            },\n            \n            {\n                \"query\": \"DELETE FROM card WHERE loan_id = 2\",\n                \"should_fail\": False,\n                \"verification_query\": \"SELECT loan_id FROM loan WHERE loan_id = 2\",\n                \"expected_result\": None,\n                \"error_message\": \"it should be none because the card is deleted\"\n            }\n        ]\n    \n    for test_case in test_cases:\n            try:\n                execute_queries([test_case[\"query\"]], db_name, conn)\n                \n                if test_case[\"should_fail\"]:\n                    assert False, f\"{test_case['error_message']}\"\n                \n                if \"verification_query\" in test_case:\n                    result = execute_queries([test_case[\"verification_query\"]], db_name, conn)[0]\n                    \n                if \"expected_count\" in test_case:\n                    assert result[0][0] == test_case[\"expected_count\"], (\n                        f\"{test_case['error_message']}\"\n                    )    \n                    \n                if \"expected_result\" in test_case:\n                    assert result == [], (\n                        f\"{test_case['error_message']}\",\n                        f\"but the result is {result}\"\n                    )\n                \n            except Exception as e:\n                if test_case[\"should_fail\"]:\n                    assert str(e).find(test_case[\"error_message\"]) != -1, (\n                        f\"{test_case['error_message']}\"\n                    )\n                else:\n                    raise\n\n    "]}
{"instance_id": "PostgreSQL_249", "sol_sql": ["\nDO $do$\nDECLARE\n    var RECORD;\nBEGIN \n    var := ROW(\n        ARRAY[NULL]::transactions_1k[],\n        ARRAY[NULL]::customers[]\n    );\n    SELECT ARRAY(SELECT t FROM transactions_1k t LIMIT 1) INTO var.f1;\n    SELECT ARRAY(SELECT c FROM customers c LIMIT 1) INTO var.f2;\n    RAISE NOTICE 'Transaction: %', var.f1[1];\n    RAISE NOTICE 'Customer: %', var.f2[1];\nEND $do$;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query = \"\"\"\n    DO $do$\n    DECLARE\n        var RECORD;\n    BEGIN \n        var := ROW(\n            ARRAY[NULL]::transactions_1k[],\n            ARRAY[NULL]::customers[]\n        );\n        \n        SELECT ARRAY(SELECT t FROM transactions_1k t LIMIT 1) INTO var.f1;\n        SELECT ARRAY(SELECT c FROM customers c LIMIT 1) INTO var.f2;\n        \n        IF array_length(var.f1, 1) IS NULL THEN\n            RAISE EXCEPTION 'Transactions array is empty';\n        END IF;\n        \n        IF array_length(var.f2, 1) IS NULL THEN\n            RAISE EXCEPTION 'Customers array is empty';\n        END IF;\n        RAISE NOTICE 'Validation passed: Arrays initialized and populated correctly';\n\n        IF var.f1[1].transactionid <> 1 THEN\n            RAISE EXCEPTION 'Transaction information is wrong';\n        END IF;\n\n        IF var.f2[1].customerid <> 3 THEN\n            RAISE EXCEPTION 'Customer information is wrong';\n        END IF;\n    END $do$;\n    \"\"\"\n    try:\n        execute_queries([test_query], db_name, conn)\n        return True\n    except Exception as e:\n        print(f\"Failed test: {str(e)}\")\n        raise\n    "]}
{"instance_id": "PostgreSQL_250", "sol_sql": ["\nWITH upd AS (\n   UPDATE loan l\n   SET  status = 'A',\n        date = '2010-12-23',\n        amount = '10000'\n   WHERE  l.loan_id = 4959\n   AND l.status = 'A'\n   RETURNING 1\n)\nSELECT COALESCE(\n   (SELECT 'UPDATE_APPLIED' FROM upd),\n   (SELECT 'VERSION_CONFLICT' FROM loan WHERE loan_id = 4959),\n   'ENTITY_NOT_FOUND'\n) AS result;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_cases = [\n        {\n            \"loan_id\": 4959,\n            \"current_status\": \"A\",\n            \"expected_result\": \"UPDATE_APPLIED\"\n        },\n        {\n            \"loan_id\": 4961,\n            \"current_status\": \"A\",\n            \"expected_result\": \"VERSION_CONFLICT\"\n        },\n        {\n            \"loan_id\": 9999,\n            \"current_status\": \"A\",\n            \"expected_result\": \"ENTITY_NOT_FOUND\"\n        }\n    ]\n\n    for test_case in test_cases:\n        update_query = f\"\"\"\n        WITH upd AS (\n            UPDATE loan l\n            SET status = 'A',\n                date = '2010-12-23',\n                amount = '10000'\n            WHERE l.loan_id = {test_case['loan_id']}\n            AND l.status = '{test_case['current_status']}'\n            RETURNING 1\n        )\n        SELECT COALESCE(\n            (SELECT 'UPDATE_APPLIED' FROM upd),\n            (SELECT 'VERSION_CONFLICT' FROM loan \n            WHERE loan_id = {test_case['loan_id']}),\n            'ENTITY_NOT_FOUND'\n        ) AS result;\n        \"\"\"\n        result = execute_queries([update_query], db_name, conn)[0]\n        if result is None:\n            assert test_case['loan_id'] == 9999, (\n                f\"Failed test: loan_id={test_case['loan_id']}, \"\n                f\"Expected result = {test_case['expected_result']}, \"\n                f\"But found = None\"\n            )\n        else:\n            assert result[0][0] == test_case['expected_result'], (\n                f\"Failed test: loan_id={test_case['loan_id']}, \"\n                f\"Expected result = {test_case['expected_result']}, \"\n                f\"But found = {result[0][0]}\"\n            )\n        if test_case['expected_result'] == 'UPDATE_APPLIED':\n            verify_query = f\"\"\"\n            SELECT status, date, amount \n            FROM loan \n            WHERE loan_id = {test_case['loan_id']}\n            \"\"\"\n            verify_result = execute_queries([verify_query], db_name, conn)[0]\n            UPDATE_VALUES = {\n                'status': 'A',\n                'date': '2010-12-23',\n                'amount': '10000'\n            }\n            assert verify_result[0][0] == UPDATE_VALUES['status'], \"The status is not updated\"\n            assert str(verify_result[0][1]) == str(UPDATE_VALUES['date']), \"The date is not updated\"\n            assert str(verify_result[0][2]) == UPDATE_VALUES['amount'], \"The amount is not updated\"\n\n    "]}
{"instance_id": "PostgreSQL_251", "sol_sql": ["\nSELECT\n  (jsonb_agg(patients)) as result\nFROM\n  (SELECT\n    *\n   FROM\n    patients\n  ) as patients\n\nUNION\n\nSELECT \n  (jsonb_agg(doctors)) as doctors  \nFROM \n   (\n     SELECT\n       *\n     FROM\n       doctors\n   ) AS doctors\n\nUNION\n\nSELECT \n  (jsonb_agg(appointments)) as appointments\nFROM \n   (\n    SELECT\n      *\n    FROM\n      appointments\n   ) AS appointments;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT coalesce(json_agg(doctors), '[]'::json) as doctors FROM (SELECT * FROM doctors) as doctors\", db_name)[0][0]\n    assert test_pred_query_result_1 in pred_query_result[:3], f'Expected to find the doctors information, but found {test_pred_query_result_1} and {pred_query_result[1]}'\n    "]}
{"instance_id": "PostgreSQL_252", "sol_sql": ["\nUPDATE patients_info SET general_info = jsonb_set(general_info, '{accept_appointments}', 'false') WHERE NOT EXISTS(SELECT 1 FROM appointments WHERE patients_info.id = appointments.patient_id AND appointments.hide_in_online_scheduling = false)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT a.patient_id FROM appointments a GROUP BY a.patient_id HAVING COUNT(*) = COUNT(CASE WHEN a.hide_in_online_scheduling = TRUE THEN 1 END);\", db_name)[0]\n    # result should be [('a8a7f85e-6d45-4a53-8e38-3156c3f1a8f1',), ('c57e1f8b-0f60-475b-b1fa-8c4e2ab9e2db',)] \n    for i in range(len(test_pred_query_result_1)):\n        query = f\"SELECT general_info FROM patients_info WHERE id = '{test_pred_query_result_1[i][0]}';\"\n        test_pred_query_result_2 = perform_query_on_postgresql_databases(query, db_name)[0][0]\n        #print(test_pred_query_result_2)\n        assert test_pred_query_result_2[0].get('accept_appointments') is False, f'Expected to find accept_appointments, but found {test_pred_query_result_2[0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_3 = perform_query_on_postgresql_databases(\"SELECT a.patient_id FROM appointments a GROUP BY a.patient_id HAVING COUNT(*) > COUNT(CASE WHEN a.hide_in_online_scheduling = TRUE THEN 1 END);\", db_name)[0]\n    \n    for i in range(len(test_pred_query_result_3)):\n        query = f\"SELECT general_info FROM patients_info WHERE id = '{test_pred_query_result_3[i][0]}';\"\n        test_pred_query_result_4 = perform_query_on_postgresql_databases(query, db_name)[0][0]\n        #print(test_pred_query_result_4)\n        assert test_pred_query_result_4[0].get('accept_appointments') is True, f'Expected to find accept_appointments, but found {test_pred_query_result_4[0]}'\n    "]}
{"instance_id": "PostgreSQL_253", "sol_sql": ["WITH atomic_operation AS (SELECT *, usd_total / molecules::DECIMAL(10,2) AS usd, COUNT(*) OVER (PARTITION BY molecule_id, sell ORDER BY date, n) AS nth_operation FROM transaction CROSS JOIN LATERAL generate_series(1, molecules) AS g(n)) SELECT purchase.molecule_id, purchase.date AS buy_date, sale.date AS sell_date, COUNT(*) AS molecules, SUM(purchase.usd)::DECIMAL(10,2) AS buy_usd_total, SUM(sale.usd)::DECIMAL(10,2) AS sell_usd_total FROM atomic_operation AS purchase JOIN atomic_operation AS sale USING(nth_operation, molecule_id) WHERE purchase.sell IS FALSE AND sale.sell IS TRUE GROUP BY 1,2,3 ORDER BY 1,2,3;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_254", "sol_sql": ["SELECT DISTINCT s.superhero_name, sp.power_name FROM superhero s INNER JOIN hero_power hp ON hp.hero_id = s.id INNER JOIN superpower sp ON sp.id = hp.power_id WHERE s.id = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 4, f\"The the result is {pred_sqls_result}, but the length is expected to be 4.\"\n"]}
{"instance_id": "PostgreSQL_255", "sol_sql": ["WITH RECURSIVE dates AS (SELECT CURRENT_DATE::date AS date UNION ALL SELECT (date + INTERVAL '1 day')::date FROM dates WHERE date < CURRENT_DATE + INTERVAL '59 days'), schedule_blocks_with_dates AS (SELECT sb.block_id, sb.user_id, d.date AS block_date, sb.start_time, sb.end_time FROM schedule_blocks sb JOIN dates d ON TRIM(sb.day_of_week) = TRIM(to_char(d.date, 'Day')) WHERE sb.is_available = TRUE AND d.date >= CURRENT_DATE AND d.date <= CURRENT_DATE + INTERVAL '2 months') SELECT block_id, user_id, block_date AS date, start_time, end_time FROM schedule_blocks_with_dates ORDER BY date, user_id, start_time;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_256", "sol_sql": ["SELECT id, sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as a, sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as b FROM team_attributes limit 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_257", "sol_sql": ["\n    CREATE VIEW overview AS\n    SELECT \n        (SELECT COUNT(*) FROM learners) AS learners_count, \n        (SELECT COUNT(*) FROM institutions) AS institutions_count, \n        (SELECT COUNT(*) FROM curricula) AS curricula_count;\n\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query = execute_queries([\"SELECT * FROM overview\"], db_name, conn)[0]\n    assert len(test_query) == 1, f'Expected 1 row, but found {len(test_query)} rows'\n    assert test_query[0][0] == 42681, f'Expected learners_count to be 42681, but found {test_query[0][0]}'\n    assert test_query[0][1] == 42681, f'Expected institutions_count to be 42681, but found {test_query[0][1]}'\n    assert test_query[0][2] == 42681, f'Expected curricula_count to be 42681, but found {test_query[0][2]}'\n    assert all(isinstance(value, int) for value in test_query[0]), f'All values in the result should be integers: {test_query[0]}'\n\n    "]}
{"instance_id": "PostgreSQL_258", "sol_sql": ["\n    SELECT \n    patients.patient_id, \n    demographics.height, \n    treatment_and_followup.primary_pathology_karnofsky_performance_score, \n    MIN(primary_pathology_karnofsky_performance_score) AS min_performance_score \n    FROM patients \n    JOIN treatment_and_followup ON patients.patient_id = treatment_and_followup.patient_id \n    JOIN demographics ON patients.patient_id = demographics.patient_id \n    WHERE informed_consent_verified = TRUE AND treatment_and_followup.primary_pathology_karnofsky_performance_score IS NOT NULL\n    GROUP BY patients.patient_id, demographics.height, treatment_and_followup.primary_pathology_karnofsky_performance_score\n    ORDER BY patients.patient_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty when there are patients with informed consent verified.'\n    first_row = test_result[0]\n    assert isinstance(first_row[0], int), f'Expected patient_id to be an integer, but found {type(first_row[0])}'\n    assert all(isinstance(row[2], int) for row in test_result), 'Karnofsky Performance Score must be not null.'\n    test_min_scores = execute_queries([\"SELECT patients.patient_id, MIN(primary_pathology_karnofsky_performance_score) FROM treatment_and_followup JOIN patients ON treatment_and_followup.patient_id = patients.patient_id WHERE informed_consent_verified = TRUE  AND treatment_and_followup.primary_pathology_karnofsky_performance_score IS NOT NULL GROUP BY patients.patient_id ORDER BY patients.patient_id\"], db_name, conn)[0]\n    assert sorted((row[0], row[2]) for row in test_result) == sorted((row[0], row[1]) for row in test_min_scores), 'The minimum Karnofsky scores should match with the expected result from the database.'\n    assert len(set(row[0] for row in test_result)) == len(test_result), 'Each patient_id should appear only once in the results.'\n\n    "]}
{"instance_id": "PostgreSQL_259", "sol_sql": ["\n    WITH RECURSIVE A(GroupNum, n, RollingSum, id) AS (\n     SELECT 1, \n     P.\"Performance_Prediction\",\n  \t CAST(P.\"Performance_Prediction\" AS NUMERIC(5,2)), P.prediction_code\n    FROM (\n        SELECT * FROM performance_predictions ORDER BY prediction_code ASC LIMIT 1\n    ) AS P\n    UNION ALL\n    SELECT \n        CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200 \n            THEN GroupNum + 1 \n            ELSE GroupNum \n        END,\n        P.\"Performance_Prediction\",\n        CAST(\n            CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200\n                THEN P.\"Performance_Prediction\"\n                ELSE RollingSum + P.\"Performance_Prediction\"\n            END \n        AS NUMERIC(5,2)), \n        P.prediction_code\n    FROM A\n    JOIN performance_predictions AS P ON A.id+1 = P.prediction_code\n)\n    SELECT GroupNum, n, SUM(n) OVER (PARTITION BY GroupNum) AS group_sum\n    FROM A\n    ORDER BY GroupNum, n;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    groups_num = execute_queries(['''\n        WITH RECURSIVE A(GroupNum, n, RollingSum, id) AS (\n            SELECT 1, \n            P.\"Performance_Prediction\",\n            CAST(P.\"Performance_Prediction\" AS NUMERIC(5,2)), P.prediction_code\n            FROM (\n                SELECT * FROM performance_predictions ORDER BY prediction_code ASC LIMIT 1\n            ) AS P\n            UNION ALL\n            SELECT \n                CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200 \n                    THEN GroupNum + 1 \n                    ELSE GroupNum \n                END,\n                P.\"Performance_Prediction\",\n                CAST(\n                    CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200\n                        THEN P.\"Performance_Prediction\"\n                        ELSE RollingSum + P.\"Performance_Prediction\"\n                    END \n                AS NUMERIC(5,2)), \n                P.prediction_code\n            FROM A\n            JOIN performance_predictions AS P ON A.id+1 = P.prediction_code\n        )\n        SELECT COUNT(DISTINCT GroupNum) \n        FROM A;\n    '''], db_name, conn)[0]\n    \n    assert groups_num[0][0] == 19871, f\"Expected 19871 groups, but found {groups_num} groups.\"\n    \n    group_sums = {}\n    for row in test_result:\n        group_num = row[0]\n        group_sum = row[2] \n        if group_num not in group_sums:\n            group_sums[group_num] = group_sum\n        assert group_sum <= 200, f\"Sum of group {group_num} = {group_sum} exceeds 200\"\n"]}
{"instance_id": "PostgreSQL_260", "sol_sql": ["\nSELECT \n    TransactionID, \n    Date, \n    Time, \n    CustomerID, \n    CardID, \n    GasStationID, \n    ProductID, \n    Amount, \n    Price, \n    CASE \n        WHEN (Date >= '2012-08-25'::date AND Amount > 0) THEN 1\n        ELSE 0\n    END AS transaction_baseline\nFROM transactions_1k\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 1000, 'Expected 1000 rows, but found {len(test_pred_query_result_1)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1000, f'Expected 1000 rows, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[488][9] == 1, f'Expect to be 1, but found {test_sol_query_result[0][0]}'\n    assert test_sol_query_result[594][9] == 0, f'Expect to be 0, but found {test_sol_query_result[1][0]}'\n    "]}
{"instance_id": "PostgreSQL_261", "sol_sql": ["\nSELECT a.*, l.* FROM account a LEFT JOIN loan l ON a.account_id = l.account_id WHERE a.account_id = 1;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 1, 'Expected 1 row, but found {len(test_pred_query_result_1)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expected 1 row, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == 18, f'Expect to be 18, but found {test_sol_query_result[0][0]}'\n    "]}
{"instance_id": "PostgreSQL_262", "sol_sql": ["\nSELECT DISTINCT A.client_id AS child FROM client A JOIN client B \nON A.district_id = B.district_id WHERE A.birth_date + INTERVAL '16 years' < B.birth_date ORDER BY A.client_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected rows, but found {len(test_pred_query_result_1)}'\n    assert test_pred_query_result_1[0][0] == 2, f'Expect to be 2, but found {test_pred_query_result_1[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expected rows, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 2, f'Expect to be 2, but found {test_sol_query_result[0][0]}'\n    excluded_client_ids = [1, 37]\n    for row in test_sol_query_result:\n        client_id = row[0] \n        assert client_id not in excluded_client_ids, f'client_id {client_id} should not be in the result'\n    sorted_client_ids = sorted(row[0] for row in test_sol_query_result)\n    assert sorted_client_ids == [row[0] for row in test_sol_query_result], 'Results are not sorted by client_id'\n"]}
{"instance_id": "PostgreSQL_263", "sol_sql": ["\nSELECT DISTINCT g.GasStationID\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nGROUP BY g.GasStationID, t.CustomerID\nHAVING SUM(t.Amount * t.Price) >= 0.7 * (\n    SELECT SUM(t2.Amount * t2.Price)\n    FROM transactions_1k t2\n    WHERE t2.CustomerID = t.CustomerID\n) LIMIT 100\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected rows, but found {len(test_pred_query_result_1)}'\n    assert test_pred_query_result_1[0][0] == 48, f'Expect to be 48, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 64, f'Expect to be 64, but found {test_pred_query_result_1[1][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expected rows, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 48, f'Expect to be 48, but found {test_sol_query_result[0][0]}'\n    assert test_sol_query_result[1][0] == 64, f'Expect to be 64, but found {test_sol_query_result[1][0]}'\n"]}
{"instance_id": "PostgreSQL_264", "sol_sql": ["\nSELECT CASE WHEN c.type = 'gold' THEN 'Gold' ELSE 'Non-Gold' \nEND AS card_type_group, COUNT(l.loan_id) AS loan_count FROM loan l JOIN disp d \nON l.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id GROUP BY card_type_group\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 2, f'Expect to be 2, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == 154, f'Expect to be 154, but found {test_pred_query_result[0][1]}'\n    assert test_pred_query_result[1][1] == 16, f'Expect to be 16, but found {test_pred_query_result[1][1]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 2, f'Expect to be 2, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == 154, f'Expect to be 154, but found {test_sol_query_result[0][1]}'\n    assert test_sol_query_result[1][1] == 16, f'Expect to be 16, but found {test_sol_query_result[1][1]}'\n"]}
{"instance_id": "PostgreSQL_265", "sol_sql": ["\nWITH member_events AS (\n    SELECT \n        link_to_member, \n        link_to_event, \n        COUNT(1) AS total,\n        ROW_NUMBER() OVER (PARTITION BY link_to_member ORDER BY COUNT(1) DESC) AS rank,\n        'Member Top 2' AS result_type\n    FROM attendance\n    GROUP BY link_to_member, link_to_event\n),\nevent_members AS (\n    SELECT \n        link_to_member, \n        link_to_event, \n        COUNT(1) AS total,\n        ROW_NUMBER() OVER (PARTITION BY link_to_event ORDER BY COUNT(1) DESC) AS rank,\n        'Event Top 1' AS result_type\n    FROM attendance\n    GROUP BY link_to_member, link_to_event\n)\nSELECT \n    link_to_member, \n    link_to_event, \n    total,\n    result_type\nFROM member_events\nWHERE rank <= 2\n\nUNION ALL\n\nSELECT \n    link_to_member, \n    link_to_event, \n    total,\n    result_type\nFROM event_members\nWHERE rank = 1\n\nORDER BY result_type, link_to_member, link_to_event\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[0][2] == 1, f'Expect to be 1, but found {test_pred_query_result[0][1]}'\n    assert test_pred_query_result[5][2] == 1, f'Expect to be 1, but found {test_pred_query_result[1][1]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[0][2] == 1, f'Expect to be 1, but found {test_sol_query_result[0][1]}'\n    assert test_sol_query_result[5][2] == 1, f'Expect to be 1, but found {test_sol_query_result[1][1]}'\n"]}
{"instance_id": "PostgreSQL_266", "sol_sql": ["\nSELECT DISTINCT ON (CustomerID) CustomerID, Date, Time\nFROM transactions_1k\nORDER BY CustomerID, Date DESC\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[0][0] == 96, f'Expect to be 96, but found {test_pred_query_result[0][0]}'\n    assert test_pred_query_result[6][0] == 2183, f'Expect to be 2183, but found {test_pred_query_result[6][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[0][0] == 96, f'Expect to be 96, but found {test_sol_query_result[0][0]}'\n    assert test_sol_query_result[6][0] == 2183, f'Expect to be 2183, but found {test_sol_query_result[6][0]}'\n"]}
{"instance_id": "PostgreSQL_267", "sol_sql": ["\n    DELETE FROM treatment_and_followup_latest b USING treatment_and_followup_backup a WHERE NOT EXISTS (\n    SELECT 1\n    FROM treatment_and_followup_backup a\n    WHERE a.patient_id = b.patient_id\n);\n    DELETE FROM treatment_and_followup_backup b USING treatment_and_followup_latest a WHERE b.patient_id = a.patient_id;\n    INSERT INTO treatment_and_followup_backup (SELECT * FROM treatment_and_followup_latest);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries([\"SELECT * FROM treatment_and_followup_backup;\"], db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least one row, but found none. The query did not return any rows.'\n    expected_len = execute_queries(['SELECT COUNT(*) FROM treatment_and_followup;'], db_name, conn)[0]\n    assert expected_len[0][0] == len(test_result), 'The number of rows in the result should match the number of rows in the treatment_and_followup table.'\n    details_query_result = execute_queries(['SELECT patient_id FROM treatment_and_followup'], db_name, conn)[0];\n    expected_details = {(row[0]) for row in details_query_result};\n    actual_details = {(row[1]) for row in test_result};\n    assert expected_details == actual_details, f'Details do not match. Expected {expected_details}, but got {actual_details}.'\n    updated_result = execute_queries(['SELECT * FROM treatment_and_followup_backup WHERE patient_id = 1'], db_name, conn)[0];\n    assert updated_result[0][2] == 0, f'Expected followup_no to be 0, but got {updated_result[0][2]}.'\n\n    "]}
{"instance_id": "PostgreSQL_268", "sol_sql": ["\n    SELECT learner_code, unnest(engagement_history) AS engagement \n    FROM learners_array \n    WHERE engagement_history IS NOT NULL\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == 10, f'Expected 10 rows, but found {len(test_result)} rows'\n    assert test_result[0] == (1, 5), f'Expected first row to be (1, 5), but found {test_result[0]}'\n    assert test_result[-1] == (4, 30), f'Expected last row to be (4, 30), but found {test_result[-1]}'\n    expected_results = [(1, 5), (1, 10), (1, 15), (2, 3), (2, 6), (3, 8), (4, 12), (4, 18), (4, 25), (4, 30)]\n    assert all(row in test_result for row in expected_results), f'Expected all rows {expected_results} to be in result, but found {test_result}'\n    assert len(set(test_result)) == len(test_result), 'Found duplicate rows in result'    \n\n    "]}
{"instance_id": "PostgreSQL_269", "sol_sql": ["\n    SELECT t.\"Engagement_Level\",\n\t    NUMRANGE(min(r.rating), max(r.rating), '[]')\n    FROM resource_usage as r\n    JOIN target_labels as t\n    ON r.learner_code = t.learner_code \n    GROUP BY t.\"Engagement_Level\"\n    ORDER BY t.\"Engagement_Level\" ASC\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty.'\n    assert all(row[0] in ['High', 'Low', 'Medium'] for row in test_result), 'Engagement levels should be among High, Low, or Medium.'\n    assert test_result[0][1].lower <= test_result[0][1].upper, 'Minimum rating should be less than or equal to maximum rating for each engagement level.'\n    assert test_result[1][1].lower == 1.0, 'Minimum rating should be equal to 1.0 for each engagement level.'\n    assert test_result[1][1].upper == 5.0, 'Maximum rating should be equal to 5.0 for each engagement level.'\n\n    "]}
{"instance_id": "PostgreSQL_270", "sol_sql": ["\n    SELECT learner_code, rating, usage_date \n    FROM resource_usage \n    WHERE (learner_code, usage_date) \n    IN (SELECT learner_code, \n        max(usage_date) as latest_usage_date \n        FROM resource_usage \n        GROUP BY learner_code) \n    ORDER BY learner_code, usage_date DESC\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty.'\n    assert all(test_result[i][0] <= test_result[i + 1][0] for i in range(len(test_result) - 1)), \"learner_code should be ordered in ascending order.\"\n    expected_latest_dates = ['2025-04-01', '2025-05-01']\n    expected_ratings = [3.0, 4.0]\n    assert str(test_result[0][2]) == expected_latest_dates[0], f'For learner_code {test_result[0][0]}, expected latest date: 2025-04-01, but found: {test_result[0][2]}.'\n    assert str(test_result[1][2]) == expected_latest_dates[1], f'For learner_code {test_result[1][0]}, expected latest date: 2025-05-01, but found: {test_result[1][2]}.'\n    assert test_result[0][1] == expected_ratings[0], f'For learner_code {test_result[0][0]}, expected latest rating: {expected_ratings[0]}, but found: {test_result[0][1]}.'\n    assert test_result[1][1] == expected_ratings[1], f'For learner_code {test_result[1][0]}, expected latest rating: {expected_ratings[1]}, but found: {test_result[1][1]}.'\n    learner_ids = [row[0] for row in test_result]  \n    unique_learner_ids = set(learner_ids)  \n    assert len(learner_ids) == len(unique_learner_ids), f\"Expected all learner_codes to be unique, but found duplicates. Total: {len(learner_ids)}, Unique: {len(unique_learner_ids)}.\"\n\n    "]}
{"instance_id": "PostgreSQL_271", "sol_sql": ["\n    SELECT learners.learner_code,\n    CASE WHEN \"Language_Proficiency\" = 'Basic' \n        THEN '0' \n        WHEN \"Language_Proficiency\" = 'Intermediate'\n        THEN '1' \n        ELSE '2' END as language_proficiency_level,\n    AVG(\"Pre_Test_Score\") AS average_pre_test_score \n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female'\n        AND \"Language_Proficiency\" = CASE \n        WHEN \"Geographic_Location\" = 'Urban' THEN 'Advanced' \n        WHEN \"Geographic_Location\" = 'Rural' THEN 'Basic' \n        ELSE 'Intermediate' END \n    GROUP BY \"Language_Proficiency\", learners.learner_code\n    ORDER BY \"Language_Proficiency\" DESC, learners.learner_code\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least 1 row, but found no rows'\n    valid_proficiency_levels = {'0', '1', '2'}\n    assert all(str(row[1]) in valid_proficiency_levels for row in test_result), f\"All of the proficiency levels should be in {valid_proficiency_levels}\"\n    test_rural = execute_queries([\"\"\"\n    SELECT learners.learner_code,\n    0 as language_proficiency_level,\n    AVG(\"Pre_Test_Score\") AS average_pre_test_score \n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Rural' AND \"Language_Proficiency\" ='Basic'\n    GROUP BY learners.learner_code\n    ORDER BY learners.learner_code\"\"\"], db_name, conn)[0]\n    result_codes = set(row[0] for row in test_result)\n    rural_average_pre_test_scores = set(r[2] for r in test_rural)\n    result_average_pre_test_scores = set(row[2] for row in test_result)\n    assert rural_average_pre_test_scores.issubset(result_average_pre_test_scores), f'All of the average pre-test scores in test_rural should be in test_result'\n    all_in_result = execute_queries([\"\"\"\n    SELECT learners.learner_code\n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Rural' AND \"Language_Proficiency\" ='Basic'\n    GROUP BY learners.learner_code\n    UNION\n    SELECT learners.learner_code\n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Urban' AND \"Language_Proficiency\" ='Advanced'\n    GROUP BY learners.learner_code;\n    \"\"\"], db_name, conn)[0]\n    all_codes = set(row[0] for row in all_in_result)\n    assert all_codes == result_codes, 'All of the learner codes in test_rural should be in test_result'\n    "]}
{"instance_id": "PostgreSQL_272", "sol_sql": ["WITH src(id,geom) as (values (1, 'linestring(0 0, 0 10)'::geometry), (2, 'linestring(0 10, 0 11)'::geometry), (3, 'linestring(1 1, 0 5)'::geometry), (4, 'linestring(1 1, 2 2)'::geometry)) SELECT a.id, st_asText(st_intersection(a.geom, b.geom)) FROM src AS a JOIN src AS b on st_intersects(a.geom, b.geom) WHERE a.id != b.id AND st_contains(a.geom, st_intersection(a.geom, b.geom));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_273", "sol_sql": ["SELECT device_info::json ->> 'SerialNumber' AS \"SerialNumber\", (cto ->> 'ChannelId')::INT AS \"ChannelId\", cto ->> 'Name' AS \"ChannelName\" FROM device_details, json_array_elements(device_info::json ->'ChannelListDto') AS \"Channels\"(cto);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_274", "sol_sql": ["WITH start_ts AS (SELECT TIMESTAMP '2023-01-01 10:34:36' AS ts), end_ts AS (SELECT TIMESTAMP '2023-01-10 15:12:24' AS ts), weekends AS (SELECT ts.day, GREATEST(start_ts.ts, ts.day) AS overlap_start, LEAST(end_ts.ts, ts.day + interval '1 day') AS overlap_end FROM start_ts, end_ts, generate_series(date_trunc('day', start_ts.ts), date_trunc('day', end_ts.ts), interval '1 day') AS ts(day) WHERE EXTRACT(ISODOW FROM ts.day) IN (6, 7)), weekend_time AS (SELECT SUM(overlap_end - overlap_start) AS total_weekend FROM weekends WHERE overlap_start < overlap_end), work_duration AS (SELECT (end_ts.ts - start_ts.ts) - COALESCE((SELECT total_weekend FROM weekend_time), interval '0') AS duration FROM start_ts, end_ts) SELECT EXTRACT(DAY FROM duration) || ' days ' || EXTRACT(HOUR FROM duration) || ' hours ' || EXTRACT(MINUTE FROM duration) || ' minutes ' || ROUND(EXTRACT(SECOND FROM duration)) || ' seconds' AS time_diff FROM work_duration;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_275", "sol_sql": ["WITH links AS (SELECT GREATEST(link.source_cluster, link.target_cluster) AS big, LEAST(link.source_cluster, link.target_cluster) AS smol, link.type AS type FROM link) SELECT l.cluster AS left_id, l.cluster_type AS left_type, l.cluster_label AS left_label, r.cluster AS right_id, r.cluster_type AS right_type, r.cluster_label AS right_label, COUNT(DISTINCT l.article) AS articles, COALESCE(ARRAY_AGG(DISTINCT links.type) FILTER (WHERE links.type IS NOT NULL), '{}') AS link_types FROM tag AS l JOIN tag AS r ON l.article = r.article AND l.cluster > r.cluster LEFT JOIN links ON l.cluster = links.big AND r.cluster = links.smol GROUP BY l.cluster, l.cluster_label, l.cluster_type, r.cluster, r.cluster_label, r.cluster_type ORDER BY COUNT(DISTINCT l.article) DESC, left_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_276", "sol_sql": ["WITH RankedSchools AS (SELECT county, opendate, ROW_NUMBER() OVER (PARTITION BY county ORDER BY opendate) AS rn FROM schools) SELECT county, MIN(opendate) AS earliest_open_date, MAX(CASE WHEN rn = 4 THEN opendate END) AS fourth_open_date FROM RankedSchools GROUP BY county"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_277", "sol_sql": ["\nSELECT i.country, o.name, o.city, o.established FROM public.ismember i INNER JOIN \npublic.organization o ON o.abbreviation = i.organization WHERE i.type = 'member' \nAND i.country = 'CI' AND i.organization IN (SELECT organization FROM public.ismember \nWHERE country = 'CI' AND type = 'member' ORDER BY organization DESC LIMIT 1) \nORDER BY o.established DESC LIMIT 1\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == 'World Trade Organization', f\"Expect to be 'World Trade Organization', but found {test_pred_query_result[0][1]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == 'World Trade Organization', f\"Expect to be 'World Trade Organization', but found {test_sol_query_result[0][1]}\"\n"]}
{"instance_id": "PostgreSQL_278", "sol_sql": ["\nWITH CTE_PUBLIC AS (SELECT \"Pre_Test_Score\", dense_rank() OVER (ORDER BY \"Pre_Test_Score\" DESC) \nas score_rank FROM outcomes AS outcm JOIN enrollment AS enrl ON outcm.learner_code = enrl.learner_code \nJOIN institutions AS inst ON enrl.institution_key = inst.institution_key WHERE inst.\"Institution_Type\" = 'Public'), \nCTE_PRIVATE AS (SELECT \"Pre_Test_Score\", dense_rank() OVER (ORDER BY \"Pre_Test_Score\" DESC) as score_rank \nFROM outcomes AS outcm JOIN enrollment AS enrl ON outcm.learner_code = enrl.learner_code JOIN institutions \nAS inst ON enrl.institution_key = inst.institution_key WHERE inst.\"Institution_Type\" = 'Private') \nSELECT AVG(public_score) - AVG(private_score) AS score_diff FROM (SELECT \"Pre_Test_Score\" AS public_score \nFROM CTE_PUBLIC WHERE score_rank = 1) AS public_top, (SELECT \"Pre_Test_Score\" AS private_score \nFROM CTE_PRIVATE WHERE score_rank = 1) AS private_top\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 0.0000000000000000, f\"Expect to be 0.0000000000000000, but found {test_pred_query_result[0][1]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 0.0000000000000000, f\"Expect to be 0.0000000000000000, but found {test_sol_query_result[0][1]}\"\n"]}
{"instance_id": "PostgreSQL_279", "sol_sql": ["\nSELECT regexp_replace(\"Content_Type\", '(?i)' || substr(\"Content_Type\", 1, 1), '', 'g') \nFROM educational_resources\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[1][0] == 'ex', f\"Expect to be 'ex', but found {test_pred_query_result[1][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[1][0] == 'ex', f\"Expect to be 'ex', but found {test_sol_query_result[1][0]}\"\n"]}
{"instance_id": "PostgreSQL_280", "sol_sql": ["\nSELECT regexp_replace(regexp_replace(primary_pathology_histological_type, 'NOS$', \n'Not Otherwise Specified'), 'Adenocarcinoma', 'Adenoma Carcinoma') AS transformed_histological_type \nFROM pathology_and_surgery;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) > 0, f'Expect to have answer, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', f\"Expect to be 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', but found {test_pred_query_result[0][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expect to have answer, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', f\"Expect to be 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', but found {test_sol_query_result[0][0]}\"\n"]}
{"instance_id": "PostgreSQL_281", "sol_sql": ["\nSELECT ROUND((SELECT COUNT(*) FROM sp_artists WHERE pop > 50)::decimal / NULLIF((SELECT COUNT(*) FROM sp_artists), 0), 3)::float;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 0.036, f\"Expect to be 0.036, but found {test_pred_query_result[0][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 0.036, f\"Expect to be 0.036, but found {test_sol_query_result[0][0]}\"\n"]}
{"instance_id": "PostgreSQL_282", "sol_sql": ["\nSELECT CASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_neoplasm_histologic_grade END AS histologic_grade, \nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_days_to_initial_pathologic_diagnosis END AS days_to_initial_diagnosis, \nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_age_at_initial_pathologic_diagnosis END AS \nage_at_initial_diagnosis FROM pathology_and_surgery;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) > 0, f'Expect to have answer, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == None, f\"Expect to be None, but found {test_pred_query_result[0][1]}\"\n    assert test_pred_query_result[12][2] == 59, f\"Expect to be 59, but found {test_pred_query_result[12][2]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expect to have answer, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == None, f\"Expect to be None, but found {test_sol_query_result[0][1]}\"\n    assert test_sol_query_result[12][2] == 59, f\"Expect to be 59, but found {test_sol_query_result[12][2]}\"\n"]}
{"instance_id": "PostgreSQL_283", "sol_sql": ["\n    SELECT DISTINCT ON (alb, art, feat_arts) \n    alb, \n    art, \n    feat_arts, \n    FIRST_VALUE(start_date) OVER (PARTITION BY alb, art, feat_arts ORDER BY start_date) AS start_date,\n    LAST_VALUE(end_date) OVER (PARTITION BY alb, art, feat_arts ORDER BY start_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS end_date\n    FROM sp_album\n    ORDER BY alb, art, feat_arts, start_date DESC\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import json\n    from datetime import date\n    expected_result = [\n        (1, 100, json.loads('[]'), date(2023, 1, 1), date(2023, 1, 20)),\n        (1, 100, json.loads('[100]'), date(2023, 1, 21), None),\n        (2, 101, json.loads('[300]'), date(2023, 1, 1), date(2023, 1, 20)),\n        (3, 202, json.loads('[]'), date(2023, 1, 21), None)\n    ]\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == len(expected_result), f\"Expected {len(expected_result)} rows, but got {len(result)} rows\"\n    for res_row, exp_row in zip(test_result, expected_result):\n        assert res_row == exp_row, f\"Expected row {exp_row}, but got {res_row}\"\n    "]}
{"instance_id": "PostgreSQL_284", "sol_sql": ["\n    SELECT p.patient_id, p.patient_barcode, a.address_id, a.country_of_procurement, a.state_province_of_procurement\n    FROM patients p\n    JOIN patient_addresses a USING (patient_id)\n    WHERE p.patient_id = 1\n    ORDER BY a.address_id DESC\n    LIMIT 1;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == 1, f'Expected exactly 1 row, but found {len(test_result)} rows'\n    assert test_result[0][0] == 1, f'Expected patient_id to be 1, but found {test_result[0][0]}'\n    assert isinstance(test_result[0][1], str) and test_result[0][1].startswith('TCGA-2H-A9'), f'Expected patient_barcode to start with \"TCGA-2H-A9\", but found {test_result[0][1]}'\n    assert test_result[0][2] > 1, f'Expected address_id to be present and greater than 1, but found {test_result[0][2]}'\n    test_pred_query_result = execute_queries([\"SELECT country_of_procurement FROM (SELECT * FROM patient_addresses WHERE patient_id = 1 ORDER BY address_id DESC LIMIT 1) AS subquery;\"], db_name, conn)[0]; \n    assert test_result[0][3] == test_pred_query_result[0][0], f'Expected city_of_procurement to be {test_pred_query_result[0][0]}, but found {test_result[0][3]}'\n\n    "]}
{"instance_id": "PostgreSQL_285", "sol_sql": ["\nWITH filtered_learners AS (\n  SELECT learner_code, \"Age\", \"Previous_Academic_Performance\"\n  FROM public.learners_info\n  WHERE \"Age\" > 0 \n)\nSELECT \n  current_rec.learner_code, \n  current_rec.\"Age\", \n  current_rec.\"Previous_Academic_Performance\", \n  compare_rec.learner_code AS lower_performance_learner\nFROM filtered_learners current_rec\nLEFT JOIN filtered_learners compare_rec\n  ON current_rec.\"Age\" < compare_rec.\"Age\"\n  AND current_rec.\"Previous_Academic_Performance\" > compare_rec.\"Previous_Academic_Performance\"\nORDER BY current_rec.learner_code;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "PostgreSQL_286", "sol_sql": ["\n    WITH union_table as(\n    SELECT l.learner_code, l.\"Gender\", r.resource_key, 'Regular Feedback' as FeedbackType, r.feedback as UserFeedback \n    FROM learners l \n    INNER JOIN resource_usage r ON l.learner_code = r.learner_code \n    UNION ALL \n    SELECT l.learner_code, l.\"Gender\", 0 as resource_key, 'Synthetic Feedback' as FeedbackType, \n    CASE WHEN o.\"Learner_Satisfaction_Score\" < 3 \n    THEN 'Negative' ELSE 'Positive' END as UserFeedback\n    FROM learners l\n    INNER JOIN outcomes o ON l.learner_code = o.learner_code \n    ) \n    SELECT *\n    FROM union_table\n    WHERE UserFeedback = ANY(ARRAY['Negative']);\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The query result should have at least one row.'\n    assert all(len(row) == 5 for row in test_result), 'Each row in the query result should have 5 columns.'\n    assert all(row[3] in ('Regular Feedback', 'Synthetic Feedback') for row in test_result), 'FeedbackType should be either Regular Feedback or Synthetic Feedback in every row.'\n    Learner_Satisfaction = execute_queries(['SELECT learner_code FROM outcomes WHERE \"Learner_Satisfaction_Score\" < 3;'], db_name, conn)[0]\n    learner_satisfaction_array = [item[0] for i, item in enumerate(Learner_Satisfaction) if i < 5661]    \n    synthetic_case_code = [row[0] for row in test_result if row[3] == 'Synthetic Feedback'] \n    Learner_Satisfaction_set = set(learner_satisfaction_array)\n    synthetic_case_code_set = set(synthetic_case_code)\n    assert synthetic_case_code_set.issubset(Learner_Satisfaction_set), 'Some synthetic case codes are not in Learner Satisfaction'\n    assert Learner_Satisfaction_set.issubset(synthetic_case_code_set), 'Some learner satisfaction codes are not in synthetic case codes'\n    feedback_filter = ('Negative')\n    filtered_result = [row for row in test_result if row[4] in feedback_filter]\n    assert len(filtered_result) == len(test_result), 'All rows should match the feedback filter condition.'\n\n    "]}
{"instance_id": "PostgreSQL_287", "sol_sql": ["\n    SELECT * \n    FROM city\n    ORDER BY \n    CASE WHEN name ~ '^[A-Za-z]+' THEN 0 ELSE 1 END ASC,\n    name,\n    COALESCE(SUBSTRING(name FROM '^[A-Za-z]+'), ''),\n    COALESCE(SUBSTRING(name FROM '(?<=-)[0-9]+')::INTEGER, 0),\n    COALESCE(SUBSTRING(name FROM '(?<=\\()[0-9]+')::BIGINT, 0),\n    population;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    from decimal import Decimal\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    expected_result = [\n        ('Aachen', 'D', 'Nordrhein-Westfalen', Decimal('236420'), Decimal('50.78'), Decimal('6.08'), Decimal('173')),\n        ('Aachen-1', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-1(1)', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-1(2)', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-2', 'D', 'Nordrhein-Westfalen', None, None, None, None)\n    ]\n    subset_result = test_result[0:5]\n    assert len(test_result) == execute_queries(['SELECT COUNT(*) FROM city;'], db_name, conn)[0][0][0], f'Expected number of rows to match city count, but found {len(test_result)} rows'\n    assert subset_result == expected_result, f'Expected {expected_result} but got {subset_result}'\n    first_letter = execute_queries([\"SELECT name FROM city ORDER BY CASE WHEN name ~ '^[A-Za-z]' THEN 0 ELSE 1 END ASC, name;\"], db_name, conn)[0]\n    first_letter_array = [item[0][0] for item in first_letter]\n    first_letter_result = [row[0][0] for row in test_result]\n    assert first_letter_array == first_letter_result, f'Expected {first_letter} but got {first_letter_result}'\n\n    "]}
{"instance_id": "PostgreSQL_288", "sol_sql": ["\n    SELECT c.name, c.code, \n    array_agg(cn.othername) filter (where cn.othername is not null) AS alternative_names \n    FROM country c \n    LEFT JOIN countryothername cn ON c.code = cn.country \n    GROUP BY c.name, c.code \n    ORDER BY c.name ASC\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    countries_with_alternative_names = execute_queries([\"SELECT DISTINCT country FROM countryothername;\"], db_name, conn)[0]\n    expected_countries = {row[0] for row in countries_with_alternative_names}\n    expected_countries_set = set(expected_countries)\n    alternative_countries = {row[1] for row in test_result if row[2] is not None}\n    alternative_countries_set = set(alternative_countries)\n    assert alternative_countries_set.issubset(expected_countries_set), f'Expected countries with alternative names: {expected_countries}, but found: {alternative_countries}'\n    countries_without_alternative_names = execute_queries([\"SELECT c.code FROM country c LEFT JOIN countryothername cn ON c.code = cn.country WHERE cn.country IS NULL;\"], db_name, conn)[0]\n    print(countries_without_alternative_names)\n    expected_null_countries = {row[0] for row in countries_without_alternative_names}\n    null_name_countries = {row[1] for row in test_result if row[2] is None}\n    expected_null_countries_set = set(expected_null_countries)\n    null_name_countries_set = set(null_name_countries)\n    assert null_name_countries_set.issubset(expected_null_countries_set), f'Expected countries without alternative names: {expected_countries}, but found: {null_name_countries}'\n    assert len(test_result) == execute_queries([\"SELECT COUNT(*) FROM country;\"], db_name, conn)[0][0][0], f'Expected number of rows to be equal to the number of countries'\n\n    "]}
{"instance_id": "PostgreSQL_289", "sol_sql": ["\nSELECT ol.institution_name\nFROM institution_location ol\nJOIN learner_institution_location l ON ST_DWithin(ol.geom, l.geom, 1);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT COUNT(ol.institution_name) FROM institution_location ol JOIN learner_institution_location l ON ST_DWithin(ol.geom, l.geom, 1);\", db_name)[0][0]\n    assert len(pred_query_result) == test_pred_query_result_1[0], f'Expected {test_pred_query_result_1} neighboring institutions, but found {len(pred_query_result)}.'\n    "]}
{"instance_id": "PostgreSQL_290", "sol_sql": ["\n    select tissue_source_site, \n        count(*) cnt_total,\n        count(*) filter(where informed_consent_verified = TRUE) cnt_processed,\n        round(count(*) FILTER (WHERE informed_consent_verified = TRUE) * 100.0 / count(*), 2) AS percent\n    from patients\n    group by tissue_source_site\n    ORDER BY tissue_source_site;\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least one row in the result'\n    for row in test_result: assert type(row[0]) is str and type(row[1]) is int and type(row[2]) is int, 'Expected columns: str, int, int'\n    assert all(row[3] == 100.00 for row in test_result if row[1] == row[2]), 'For sites with eqaul total count and consent count, the percentage should be 100'\n    assert sum(1 for row in test_result if row[1] == row[2]) == len(test_result)-1, 'Expected all sites to have equal total and consent count except for the fisrt row'\n    first_row = test_result[0]\n    assert first_row[0] == '2H' and first_row[1] == 240 and first_row[2] == 230, 'Expected first row to be 2H, 240, 230'\n    assert str(first_row[3]) == '95.83', f'Expected first row percentage to be 95.83, but fount {first_row[3]}'\n\n    "]}
{"instance_id": "PostgreSQL_291", "sol_sql": ["WITH sales AS ( SELECT \"gasstationid\" AS \"GasstationId\", \"customerid\" AS \"CustomerId\", \"date\" AS \"SaleDate\", \"amount\" AS \"Amount\" FROM \"transactions_1k\" ), initial_purchase AS ( SELECT \"CustomerId\", MIN(CAST(\"SaleDate\" AS date)) AS \"FirstPurchaseDate\" FROM sales GROUP BY \"CustomerId\" ), customer_wages AS ( SELECT i.\"CustomerId\", s.* FROM sales s JOIN initial_purchase i ON s.\"CustomerId\" = i.\"CustomerId\" WHERE s.\"SaleDate\" >= i.\"FirstPurchaseDate\" ORDER BY i.\"CustomerId\" DESC ) SELECT * FROM customer_wages"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_292", "sol_sql": ["DO $$ DECLARE ddlsql TEXT; BEGIN FOR ddlsql IN (SELECT 'ALTER TABLE ' || quote_ident(c.table_schema) || '.' || quote_ident(c.table_name) || ' RENAME COLUMN \"' || c.column_name || '\" TO ' || quote_ident(lower(c.column_name)) || ';' FROM information_schema.columns As c WHERE c.table_schema = 'public' AND c.column_name <> lower(c.column_name)) LOOP EXECUTE ddlsql; END LOOP; END $$;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    column_names = execute_queries([\"SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'frpm' ORDER BY ordinal_position;\"], db_name, conn)[0]\n    assert column_names[0][0] == 'cdscode', f\"Expected the first column is 'cdscode', but found {column_names[0][0]}\"\n    assert column_names[1][0] == 'academic year', f\"Expected the first column is 'academic year', but found {column_names[1][0]}\"\n"]}
{"instance_id": "PostgreSQL_293", "sol_sql": ["SELECT product_id FROM (SELECT product_id, MIN(is_searchable::INT) OVER() AS minIsSearchable FROM product WHERE product_id IN (101, 103)) AS cte WHERE minIsSearchable = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "PostgreSQL_294", "sol_sql": ["SELECT * FROM orders WHERE customer_id = 1 OR product_id = 'P202' ORDER BY RANK() OVER(ORDER BY CASE WHEN customer_id = 1 THEN 1 ELSE 2 END) FETCH FIRST ROW WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_295", "sol_sql": ["WITH cte_dates AS (SELECT DISTINCT transaction_date AS \"date\" FROM sales_log), cte_names AS (SELECT DISTINCT salesperson_name AS \"name\" FROM sales_log) SELECT cte_dates.date, cte_names.name FROM cte_dates CROSS JOIN cte_names LEFT JOIN sales_log ON cte_dates.date = sales_log.transaction_date AND cte_names.name = sales_log.salesperson_name WHERE sales_log.amount IS NULL;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_296", "sol_sql": ["WITH ranked_items AS (SELECT m.*, ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY id DESC) AS rn, LAG(price,1) OVER (PARTITION BY product_id ORDER BY id ) as previous_price FROM ProductPrice AS m) SELECT p.product_id, p.product_name FROM Product p JOIN ranked_items r ON p.product_id = r.product_id WHERE r.rn = 1 AND price < previous_price"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_297", "sol_sql": ["SELECT cd.customer_id, sal.sal_cnt as total_sales_ctr_id, sal.tot_amount as total_sales_amount, com.eml_cnt as total_email_ctr_id, fb.fb_cnt as total_fb_ctr_id, fb.pcnt as total_positive_fb, fb.ncnt as total_negative_fb FROM customer_details cd LEFT JOIN (SELECT customer_id, SUM(amount) as tot_amount, count(*) as sal_cnt FROM sales GROUP BY customer_id) sal ON cd.customer_id = sal.customer_id LEFT JOIN (SELECT customer_id, count(*) as eml_cnt from communications group by customer_id) com on cd.customer_id = com.customer_id LEFT JOIN (SELECT customer_id, COUNT(*) as fb_cnt, count(*) filter (where feedback_type = 'positive') as pcnt, count(*) filter (where feedback_type = 'negative') as ncnt from feedback group by customer_id) fb ON cd.customer_id = fb.customer_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_298", "sol_sql": ["CREATE OR REPLACE FUNCTION fn_concat(first_name VARCHAR, last_name VARCHAR) RETURNS VARCHAR AS $$ BEGIN RETURN first_name || ' ' || last_name; END; $$ LANGUAGE plpgsql;", "SELECT *, fn_concat(f_name, l_name) AS full_name FROM cust;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "PostgreSQL_299", "sol_sql": ["SELECT * FROM orders o CROSS JOIN LATERAL regexp_split_to_table (o.delivery_zones, ',') AS z WHERE CASE WHEN strpos (z, '-') > 0 THEN '10015' BETWEEN split_part (z, '-', 1) AND split_part (z, '-', 2) ELSE z = '10015' END "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_0", "sol_sql": ["SELECT \n    (SELECT COUNT(*) FROM bond WHERE bond_id = 'TR000_1_2') AS bond_id_count,\n    bond_type,\n    COUNT(*) AS bond_type_count\nFROM bond\nGROUP BY bond_type WITH ROLLUP;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_1", "sol_sql": ["SELECT e.event_id FROM event e LEFT JOIN attendance a ON e.event_id = a.link_to_event WHERE a.link_to_event IS NULL;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_2", "sol_sql": ["UPDATE League t1\nINNER JOIN\n(\n    SELECT l.country_id\n    FROM League l\n    INNER JOIN Country c ON l.country_id = c.id\n    GROUP BY l.country_id\n    HAVING l.country_id > 1000\n) t2\n    ON t1.country_id = t2.country_id\nSET\n    name = concat('abc', ',', name);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\n        \"SELECT COUNT(*) FROM League WHERE country_id > 1000 AND name LIKE 'abc,%';\"\n    ], db_name, conn)[0]\n    \n    updated_count = result[0][0]\n    assert updated_count > 0, f\"Update did not occur. Found {updated_count} rows with updated name.\"\n    return updated_count\n    "]}
{"instance_id": "MySQL_3", "sol_sql": ["SELECT * FROM transactions_1k LEFT JOIN customers ON transactions_1k.CustomerID = customers.CustomerID LIMIT 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_4", "sol_sql": ["SELECT bond_id FROM bond WHERE bond_id RLIKE '^TR[1-3].*[45]$';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_5", "sol_sql": ["SELECT SUM(cost) as total_cost, link_to_member\nFROM expense\nGROUP BY link_to_member;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_6", "sol_sql": ["ALTER TABLE `member_privileges` ADD FOREIGN KEY (`member_id`) REFERENCES `member`(`member_id`);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT COUNT(*) FROM information_schema.KEY_COLUMN_USAGE WHERE TABLE_NAME = 'member_privileges' AND COLUMN_NAME = 'member_id' AND REFERENCED_TABLE_NAME = 'member' AND REFERENCED_COLUMN_NAME = 'member_id';\"]\n    result, exec_err, _, _ = execute_queries(queries, db_name, conn)  \n    assert exec_err == False, \"Failed to query foreign key information\"\n    assert result[0][0] > 0, \"Foreign key constraint not created properly\"\n    ", "def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query = \"SELECT EXISTS (SELECT 1 FROM information_schema.TABLE_CONSTRAINTS WHERE CONSTRAINT_TYPE = 'FOREIGN KEY' AND TABLE_NAME = 'member_privileges');\"\n    test_pred_query_result = execute_queries([test_pred_query], db_name, conn)[0]\n    assert test_pred_query_result[0][0] == 1, \"The foreign key wasn't added to the table\"\n    "]}
{"instance_id": "MySQL_7", "sol_sql": ["create trigger no_self_ref after insert on couple for each row begin \nif NEW.spouseid = NEW.id then \n  signal sqlstate '45000' set message_text = 'no self-referencing hierarchies'; \nend if; \nend;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Insert a valid record into 'couple' (this should succeed because id != spouseid)\n    execute_queries([\"INSERT INTO couple (spouseid) VALUES (NULL);\"], db_name, conn)\n    \n    # Verify that the valid record was inserted\n    valid_count_result = execute_queries([\"SELECT COUNT(*) FROM couple;\"], db_name, conn)[0]\n    valid_count = valid_count_result[0][0]\n    assert valid_count == 1, f\"Expected 1 valid record, but found {valid_count}.\"\n    \n    # Attempt to insert an invalid record where id equals spouseid.\n    # Although our execute_queries function logs the error, it does not raise an exception,\n    # so we rely on checking that the record count does not increase.\n    execute_queries([\"INSERT INTO couple (id, spouseid) VALUES (100, 100);\"], db_name, conn)\n    \n    # Verify that the invalid insert did not add a new record.\n    final_count_result = execute_queries([\"SELECT COUNT(*) FROM couple;\"], db_name, conn)[0]\n    final_count = final_count_result[0][0]\n    assert final_count == 1, f\"Invalid record was inserted, record count expected to remain 1 but found {final_count}.\"\n    "]}
{"instance_id": "MySQL_8", "sol_sql": ["SELECT Description, CONCAT_WS(', ', CONCAT(NULLIF(DATE_FORMAT(Description, '%H'), '00'), ' hours'), CONCAT(NULLIF(DATE_FORMAT(Description, '%i'), '00'), ' minutes'), CONCAT(NULLIF(DATE_FORMAT(Description, '%s'), '00'), ' seconds')) AS formatted_time FROM backup_colour;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_9", "sol_sql": ["CREATE TABLE `log_content` (\n  `log_id` int(11) NOT NULL AUTO_INCREMENT,\n  `content` varchar(32) NOT NULL,\n  `no_of_chars` int(4) AS (CHAR_LENGTH(`content`)),\n  PRIMARY KEY (`log_id`)\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Insert a record into 'log_content' with content 'hello'\n    execute_queries([\"INSERT INTO log_content (content) VALUES ('hello');\"], db_name, conn)\n    \n    # Retrieve the record and verify that the computed column 'no_of_chars' reflects the length of 'content'\n    result = execute_queries([\"SELECT content, no_of_chars FROM log_content;\"], db_name, conn)[0]\n    assert len(result) > 0, \"No records found in 'log_content'.\"\n    \n    for row in result:\n        content, no_of_chars = row\n        expected_length = len(content)\n        assert no_of_chars == expected_length, (\n            f\"Expected no_of_chars to be {expected_length} for content '{content}', but got {no_of_chars}.\"\n        )\n    "]}
{"instance_id": "MySQL_10", "sol_sql": ["SELECT * FROM atom LEFT JOIN molecule ON atom.molecule_id = molecule.molecule_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_11", "sol_sql": ["SELECT\n  t2.startDt,\n  t2.endDt,\n  COUNT(*) AS overlaps_count\nFROM\n(\n  SELECT\n    LAG(t1.dt) OVER (ORDER BY t1.dt) AS startDt,\n    t1.dt AS endDt\n  FROM\n  (\n    SELECT start AS dt FROM duration\n    UNION\n    SELECT end AS dt FROM duration\n  ) t1\n) t2\nJOIN duration d\n  ON t2.startDt < d.end AND t2.endDt > d.start\nGROUP BY t2.startDt, t2.endDt\nORDER BY t2.startDt;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_12", "sol_sql": ["SELECT t.trans_id, a.district_id, t.amount FROM trans t JOIN account a ON t.account_id = a.account_id ORDER BY t.trans_id ASC LIMIT 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_13", "sol_sql": ["(SELECT schools.CDSCode AS sch_CDSCode, frpm.CDSCode AS frpm_CDSCode FROM schools LEFT JOIN frpm ON schools.CDSCode = frpm.CDSCode) UNION ALL (SELECT schools.CDSCode AS sch_CDSCode, frpm.CDSCode AS frpm_CDSCode FROM schools RIGHT JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.CDSCode IS NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_14", "sol_sql": ["INSERT INTO products (ProductID, Description) VALUES (2, \"Special\") ON DUPLICATE KEY UPDATE Description = concat(Description, \",\", \"Special\");"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\"SELECT Description FROM products WHERE ProductID = 2;\"], db_name, conn)[0]\n    assert len(result) == 1, \"No product found with ProductID=2.\"\n    description = result[0][0]\n    assert description.endswith(\"Special\"), f\"Expected description to end with 'Special', but got '{description}'.\"\n    "]}
{"instance_id": "MySQL_15", "sol_sql": ["SELECT rr.*, (@rank := @rank + 1) AS ranking\nFROM (\n    SELECT r.*\n    FROM results AS r\n    JOIN drivers AS d\n    ON r.driverId = d.driverId\n    ORDER BY r.fastestLap ASC, d.dob ASC\n) rr\nCROSS JOIN (SELECT @rank := 0) params\nLIMIT 10;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_16", "sol_sql": ["ALTER TABLE users MODIFY COLUMN Reputation INT UNSIGNED;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    show_create = execute_queries([\"SHOW CREATE TABLE users;\"], db_name, conn)[0]\n    assert len(show_create) > 0, \"No result from SHOW CREATE TABLE users.\"\n    create_stmt = show_create[0][1]\n    \n    # Using lower() to ignore case differences and accounting for backticks.\n    assert \"`reputation` int unsigned\" in create_stmt.lower(), (\n        \"Reputation column is not modified to INT UNSIGNED as expected.\"\n    )\n    "]}
{"instance_id": "MySQL_17", "sol_sql": ["INSERT INTO account (`account_id`, `district_id`, `frequency`, `account_type`, `date`) VALUES\n(12345, 18, \"POPLATEK MESICNE\", \"Checking\", \"1970-12-13\");"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries(\n        [\"SELECT account_type FROM account WHERE account_id = 12345;\"],\n        db_name, conn\n    )[0]\n    assert len(result) == 1, \"No account found with account_id 12345.\"\n    account_type = result[0][0]\n    assert account_type == \"Checking\", f\"Expected account_type to be 'Checking', but got '{account_type}'.\"\n    "]}
{"instance_id": "MySQL_18", "sol_sql": ["SELECT Player.player_api_id, Player.player_name, Player_Attributes.overall_rating FROM Player LEFT JOIN Player_Attributes ON  Player.player_api_id = Player_Attributes.player_api_id AND Player_Attributes.overall_rating = 68;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_19", "sol_sql": ["SELECT * FROM (SELECT Count, (Count - LAG(Count, 1) OVER (ORDER BY Id)) AS dif FROM backup_colour) t WHERE dif = 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_20", "sol_sql": ["SELECT s.member_id FROM member s WHERE s.position='Member' AND MATCH (s.email) AGAINST ('\"angela.sanders@lpu.edu\"' IN BOOLEAN MODE);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_21", "sol_sql": ["SELECT CONCAT(IFNULL(ranges.min, ''), '-', IFNULL(ranges.max, '')) AS `range`, AVG(Count) AS avg FROM (SELECT 0 AS min, 21 AS max UNION ALL SELECT 21, 34 UNION ALL SELECT 34, 64 UNION ALL SELECT 64, NULL) AS ranges LEFT JOIN backup_colour AS t ON (ranges.min IS NULL OR t.Count >= ranges.min) AND (ranges.max IS NULL OR t.Count < ranges.max) GROUP BY ranges.min, ranges.max;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_22", "sol_sql": ["SELECT * FROM attribute JOIN hero_attribute ON hero_attribute.attribute_id = attribute.id WHERE NOT (attribute_name = 'Speed' AND attribute_value = 35);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_23", "sol_sql": ["SELECT CDSCode, COUNT(CDSCODE) FROM schools WHERE District = 'Alameda County Office of Education' GROUP BY CDSCode LIMIT 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_24", "sol_sql": ["SELECT \n    id, \n    SUBSTRING_INDEX(GROUP_CONCAT(Max_v ORDER BY Max_v DESC), ',', 3) AS Top3_Values,\n    SUBSTRING_INDEX(GROUP_CONCAT(AttributeName ORDER BY Max_v DESC), ',', 3) AS Top3_Attributes\nFROM (\n    SELECT id, crossing AS Max_v, 'crossing' AS AttributeName FROM Player_Attributes\n    UNION ALL\n    SELECT id, finishing AS Max_v, 'finishing' AS AttributeName FROM Player_Attributes\n    UNION ALL\n    SELECT id, heading_accuracy AS Max_v, 'heading_accuracy' AS AttributeName FROM Player_Attributes\n    UNION ALL\n    SELECT id, short_passing AS Max_v, 'short_passing' AS AttributeName FROM Player_Attributes\n    UNION ALL\n    SELECT id, volleys AS Max_v, 'volleys' AS AttributeName FROM Player_Attributes\n) T \nGROUP BY id LIMIT 10;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_25", "sol_sql": ["\nSELECT * \nFROM transactions_1k\nWHERE Date(CONCAT(Date, ' ', TIME(Time)))\n      BETWEEN '2012-08-22' AND '2012-08-23'\nORDER BY amount DESC\nLIMIT 3;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_26", "sol_sql": ["SELECT s.driverStandingsId, s.raceId, d.driverId FROM driverStandings s LEFT JOIN drivers d on d.driverId = s.driverId WHERE s.raceId = 19;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_27", "sol_sql": ["SELECT State, substring_index(group_concat(County ORDER BY CDSCode DESC), ',', 1) AS County, substring_index(group_concat(City ORDER BY CDSCode DESC), ',', 1) AS City, substring_index(group_concat(CDSCode ORDER BY CDSCode DESC), ',', 1) AS CDSCode FROM schools WHERE State IS NOT NULL GROUP BY State;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_28", "sol_sql": ["SELECT Id, SUM(Count) AS COUNT, SUM(ExcerptPostId) AS EXCERPTPOSTID FROM backup_colour GROUP BY Id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_29", "sol_sql": ["SELECT status, SUM(amount) AS total_amount, SUM(payments) AS total_payments, (SUM(amount)+SUM(payments)) AS s FROM loan GROUP BY status;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_30", "sol_sql": ["SELECT p.ID, p.Diagnosis\nFROM Patient p\nJOIN Examination e\n ON(p.ID = e.ID)\nJOIN(SELECT p.Diagnosis, e.Thrombosis\n     FROM Patient p\n     JOIN Examination e\n      ON(p.ID = e.ID)\n      WHERE p.Diagnosis = 'PSS' AND e.Thrombosis = 0\n     GROUP BY p.Diagnosis, e.Thrombosis\n     HAVING COUNT(*) > 1) j\nON(p.Diagnosis = j.Diagnosis AND e.Thrombosis = j.Thrombosis);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_31", "sol_sql": ["SELECT DISTINCT\n    u.Id AS UserId,\n    u.DisplayName,\n    u.Reputation,\n    b.Name AS BadgeName,\n    b.Date AS BadgeDate\nFROM\n    users u\nLEFT JOIN badges b ON b.UserId = u.Id AND b.Name = 'Teacher'\nWHERE \n    u.Reputation >= 10000;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_32", "sol_sql": ["DELETE FROM backup_colour WHERE raceId IN (SELECT a.raceId FROM (SELECT MIN(raceId) AS `raceId` FROM backup_colour GROUP BY milliseconds HAVING COUNT(*) > 1) a);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\"SELECT COUNT(*) FROM backup_colour;\"], db_name, conn)[0]\n    row_count = result[0][0]\n    assert row_count == 3, f\"Expected 3 rows after deletion, but found {row_count} rows.\"\n    rows = execute_queries([\"SELECT raceId, milliseconds FROM backup_colour ORDER BY raceId;\"], db_name, conn)[0]\n    expected_rows = {(3, 22552), (4, 19237), (8, 92729)}\n    actual_rows = {(row[0], row[1]) for row in rows}\n    assert actual_rows == expected_rows, f\"Expected rows {expected_rows} but got {actual_rows}.\"\n    "]}
{"instance_id": "MySQL_33", "sol_sql": ["SELECT account.account_id, loan.loan_id, SUM(loan.amount) AS total_amount\nFROM account\nJOIN loan ON account.account_id = loan.account_id\nJOIN trans ON loan.account_id = trans.account_id\nWHERE loan.status LIKE '%A%' AND\n  (trans.type LIKE '%PRIJEM%' OR trans.type LIKE '%VYDAJ%')\nGROUP BY loan.loan_id\nORDER BY account.account_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_34", "sol_sql": ["INSERT INTO `session_card` (`sc_id`, `session_id`, `card_id`, `card_mode`) VALUES\n(1, 9410, 256, 'rw');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries(\n        [\"SELECT sc_id, session_id, card_id, card_mode FROM session_card WHERE sc_id = 1;\"],\n        db_name, conn\n    )[0]\n    assert len(result) == 1, \"Record with sc_id 1 was not inserted into session_card.\"\n    sc_id, session_id, card_id, card_mode = result[0]\n    assert sc_id == 1, f\"Expected sc_id to be 1, but got {sc_id}.\"\n    assert session_id == 9410, f\"Expected session_id to be 9410, but got {session_id}.\"\n    assert card_id == 256, f\"Expected card_id to be 256, but got {card_id}.\"\n    assert card_mode == 'rw', f\"Expected card_mode to be 'rw', but got {card_mode}.\"\n    "]}
{"instance_id": "MySQL_35", "sol_sql": ["DELETE Country FROM Country WHERE NOT EXISTS (SELECT 1 FROM League WHERE country_id = Country.id);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\"SELECT id, name FROM Country ORDER BY id;\"], db_name, conn)[0]\n    expected_rows = ((2, 'UK'), (3, 'US'), (4, 'RA'))\n    assert result == expected_rows, f\"Expected rows {expected_rows} but got {result}.\"\n    "]}
{"instance_id": "MySQL_36", "sol_sql": ["CREATE TABLE hero_event (`event_id` INT(11) NOT NULL AUTO_INCREMENT, `superhero` VARCHAR(255) NOT NULL, `event_date` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`event_id`));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\"SHOW CREATE TABLE hero_event;\"], db_name, conn)[0]\n    assert len(result) > 0, \"Table hero_event was not created.\"\n    create_stmt = result[0][1]\n    assert \"DEFAULT CURRENT_TIMESTAMP\" in create_stmt, \"The event_date column is not set to DEFAULT CURRENT_TIMESTAMP.\"\n    "]}
{"instance_id": "MySQL_37", "sol_sql": ["SELECT * FROM card_release t WHERE release_id IN \n    (SELECT DISTINCT release_id FROM card_release WHERE code_status_id = 3)\nUNION ALL\nSELECT * FROM card_release t WHERE release_id IN \n    (SELECT MAX(release_id) FROM card_release x WHERE \n    NOT EXISTS (SELECT 1 FROM card_release y WHERE code_status_id = 3 AND y.code_id = x.code_id) GROUP BY code_id);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_38", "sol_sql": ["ALTER TABLE superhero CHANGE COLUMN description description JSON NOT NULL DEFAULT (JSON_OBJECT());"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    insert_sql = \"INSERT INTO superhero (id) VALUES (99999);\"\n    execute_queries([insert_sql], db_name, conn)\n\n    select_sql = \"SELECT description FROM superhero WHERE id = 99999;\"\n    result = execute_queries([select_sql], db_name, conn)[0]\n    assert len(result) == 1, \"Record with id 99999 not found in superhero table.\"\n    description = result[0][0]\n    \n    assert description == '{}', f\"Expected description to default to '{{}}', but got {description}.\"\n    \n    delete_sql = \"DELETE FROM superhero WHERE id = 99999;\"\n    execute_queries([delete_sql], db_name, conn)\n    "]}
{"instance_id": "MySQL_39", "sol_sql": ["SELECT SUM(expense.cost) AS total_expense, SUM(budget.amount) AS total_budget, budget.link_to_event FROM budget JOIN (SELECT expense.link_to_budget, SUM(expense.cost) AS cost FROM expense GROUP BY expense.link_to_budget) AS expense ON expense.link_to_budget = budget.budget_id GROUP BY budget.link_to_event;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_40", "sol_sql": ["SELECT c.id FROM cards AS c LEFT JOIN decks AS d ON c.id = d.card2_id WHERE 1 NOT IN (c.id, COALESCE(d.card1_id, 0)) AND d.status IS NULL ORDER BY c.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_41", "sol_sql": ["UPDATE `Match` SET date = DATE_FORMAT(date, '%Y-%m-%d 15:%i:%s');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    # Retrieve the updated record.\n    result = execute_queries([\"SELECT date FROM `Match` WHERE date LIKE '2008-08-17%';\"], db_name, conn)[0]\n    assert len(result) > 0, \"No record found for '2008-08-17'.\"\n    updated_date = result[0][0]\n    \n    # Expected updated date should preserve the original minutes and seconds.\n    expected_date = \"2008-08-17 15:00:00\"\n    assert updated_date == expected_date, f\"Expected date '{expected_date}' but got '{updated_date}'.\"\n    \n    # Clean up: Delete the test record.\n    cleanup_sql = \"DELETE FROM `Match` WHERE date = '{}';\".format(expected_date)\n    execute_queries([cleanup_sql], db_name, conn)\n    "]}
{"instance_id": "MySQL_42", "sol_sql": ["UPDATE Laboratory l\nJOIN Patient p on p.ID = l.ID\nSET l.TAT = 1\nWHERE p.SEX='F' AND p.ID < 40000;", "\n\nDELETE e\nFROM Examination e\nJOIN Patient p ON p.ID = e.ID\nWHERE p.SEX='F' AND p.ID < 40000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query1 = \"SELECT e.ID, Thrombosis FROM ( SELECT * FROM Patient WHERE SEX = 'F' AND ID < 40000 ) AS filtered_patient INNER JOIN Examination AS e ON filtered_patient.ID = e.ID;\"\n    result = execute_queries([test_query1], db_name, conn)[0]\n    assert len(result) == 0, \"Some records were not deleted.\"\n    \n    test_query2 = \"SELECT TAT FROM ( SELECT * FROM Patient WHERE SEX = 'F' AND ID < 40000 ) AS filtered_patient INNER JOIN Laboratory AS l ON filtered_patient.ID = l.ID;\"\n    result = execute_queries([test_query2], db_name, conn)[0]\n    assert all(x == 1 for (x,) in result), \"Some record values were not updated.\"\n    "]}
{"instance_id": "MySQL_43", "sol_sql": ["UPDATE users\n  SET WebsiteUrl = REPLACE(WebsiteUrl, 'http://stackoverflow.com', 'https://stackoverflow.com');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query1 = \"SELECT WebsiteUrl FROM users WHERE BINARY WebsiteUrl LIKE '%http://stackoverflow.com%';\"\n    result = execute_queries([test_query1], db_name, conn)[0]\n    assert len(result) == 0, \"Not all URLs have been replaced.\"\n    \n    test_query2 = \"SELECT WebsiteUrl FROM users WHERE BINARY WebsiteUrl LIKE '%https://stackoverflow.com%';\"\n    result = execute_queries([test_query2], db_name, conn)[0]\n    assert len(result) == 116, \"Record number mismatch.\"\n    "]}
{"instance_id": "MySQL_44", "sol_sql": ["(SELECT full_name, LENGTH(full_name)\nFROM superhero\nWHERE full_name IS NOT NULL AND full_name <> '-'  \nORDER BY LENGTH(full_name) ASC, full_name ASC LIMIT 1)\nUNION\n(SELECT full_name, LENGTH(full_name)\nFROM superhero\nWHERE full_name IS NOT NULL AND full_name <> '-'  \nORDER BY LENGTH(full_name) DESC, full_name ASC LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_45", "sol_sql": ["SELECT name, COUNT(*) \nFROM races\nGROUP BY name;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_46", "sol_sql": ["INSERT INTO constructorResults (raceId, constructorId, points, status)\nSELECT r.raceId, r.constructorId, r.points, r.status FROM constructors c INNER JOIN constructorResults r ON r.constructorId = c.constructorId;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query = \"SELECT COUNT(*) FROM constructorResults;\"\n    result = execute_queries([test_query], db_name, conn)[0]\n    assert result[0][0] == 21686, f\"Expect 21686 records after inserting, but found {result[0][0]}.\"\n    "]}
{"instance_id": "MySQL_47", "sol_sql": ["WITH RankedTransactions AS (\n    SELECT tt.*, \n           ROW_NUMBER() OVER (PARTITION BY tt.CustomerID) AS rn\n    FROM transactions_1k tt\n    INNER JOIN\n        (SELECT CustomerID, MAX(Date) AS maxdate\n        FROM transactions_1k\n        GROUP BY CustomerID) groupedtt \n    ON tt.CustomerID = groupedtt.CustomerID \n    AND tt.Date = groupedtt.maxdate\n)\nSELECT *\nFROM RankedTransactions\nWHERE rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_48", "sol_sql": ["SELECT id, (CASE WHEN (colors = 'W' and power = '4') THEN coalesce(watermark, '996')\n             WHEN (colors = 'B' and power = '3') THEN coalesce(watermark, '997')\n             WHEN (colors = 'U' and power = '2') THEN coalesce(watermark, '998')\n             WHEN (colors = 'R' and power = '0') THEN coalesce(watermark, '999')\n    END) AS watermark\nFROM cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_49", "sol_sql": ["SELECT CustomerID, SUM(CASE WHEN DAY(date) = 3 THEN 1 ELSE 0 END) AS number_of_third_day,SUM(CASE WHEN DAY(date) = 24 THEN 1 ELSE 0 END) AS number_of_twenty_fourth_day FROM transactions_1k WHERE DAY(date) IN (3, 24) GROUP BY CustomerID"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_50", "sol_sql": ["SELECT  AVG(Score) AS AvgOfScore FROM (SELECT posts.OwnerUserId, posts.Tags, Score, CreaionDate, ROW_NUMBER() OVER (PARTITION BY OwnerUserId, Tags ORDER BY CreaionDate DESC) AS row_num FROM posts WHERE OwnerUserId = 183 AND Tags LIKE '%distribution%') AS Scores WHERE row_num <= 5"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_51", "sol_sql": ["WITH s_event_ids AS (SELECT event_id FROM event WHERE type LIKE 'S%')DELETE FROM attendance WHERE link_to_event IN (TABLE s_event_ids);", "WITH s_event_ids AS (SELECT event_id FROM event WHERE type LIKE 'S%')DELETE FROM event WHERE event_id IN (TABLE s_event_ids);"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) FROM event WHERE type LIKE 'S%'\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 0, f'Expected 0 but returned {test_pred_query_result_1[0][0]} rows'\n    "]}
{"instance_id": "MySQL_52", "sol_sql": ["SELECT link_to_member, COUNT(DISTINCT DATE(event_date)) AS total_attendance_days FROM attendance JOIN event ON attendance.link_to_event = event.event_id WHERE event_date BETWEEN '2019-01-01' AND '2023-12-31' GROUP BY link_to_member;"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_53", "sol_sql": ["WITH RECURSIVE cte(d) AS (SELECT CAST('2012-08-23' AS DATE) UNION ALL SELECT DATE_ADD(d, INTERVAL 1 DAY) FROM cte WHERE d < '2012-08-26') SELECT p.d date, p.CustomerID, case when p.s is null then 'No transaction exists' else p.s end FROM (SELECT c.d, c1.CustomerID, SUM(t.Amount) s FROM cte c CROSS JOIN customers c1 LEFT JOIN transactions_1k t ON t.CustomerID = c1.CustomerID AND DATE(t.Date) = c.d GROUP BY c.d, c1.CustomerID) p ORDER BY p.d, p.CustomerID;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_54", "sol_sql": ["WITH Recursive cte (root, entityid, parentid, entity_emission, pctcontribution) AS (Select entityid, entityid, Coalesce(parentid, entityid), emission, pctcontribution From tree_table Where parentid Is Null UNION ALL Select cte.root, t.entityid, t.parentid, t.emission, t.pctcontribution From cte Inner Join tree_table t ON( t.parentid = cte.entityid)), grid AS (SELECT x.root, x.entityid, x.parentid, x.entity_emission, x.groupid, x.cumulative_total, x.pctcontribution, Case When x.entityid = x.root Then 0 When x.entityid != x.root And x.entityid != x.groupid And x.groupid = x.root Then x.entity_emission * (100 - x.pctcontribution) / 100 When x.entityid != x.root And x.entityid = x.groupid Then LAG(x.entity_emission * (100 - x.pctcontribution)) Over(Partition By x.root, x.groupid Order By  x.entityid)/ 100 Else 0 End as contribution_correction FROM (Select root, entityid, parentid, entity_emission, Coalesce(LAG(parentid) Over(Order By root, parentid, entityid), parentid) as groupid, Round( Case When entityid = root Then Sum(entity_emission) Over(Partition By root) Else Case When Coalesce(LAG(parentid) Over(Order By entityid), parentid) = parentid Then entity_emission Else Sum(entity_emission) Over(Partition By root Order By entityid) End End, 0 ) as cumulative_total, pctcontribution From cte Order By entityid) x) SELECT g.entityid, g.parentid, Round(Case When g.entityid = g.root Then (Sum(Case When g.entityid != g.root Then g.corrected_contribution Else 0 End) Over(Partition By g.root) + ( Max(Case When g.entityid = g.root Then g.entity_emission Else 0 End) Over(Partition By g.root)) - Sum(g.group_correction) Over(Partition By g.root)) When g.entityid != g.root And g.entityid != g.groupid And g.groupid = g.root Then g.entity_emission When g.entityid != g.root And g.entityid != g.groupid Then g.entity_emission When g.entityid != g.root And g.entityid = g.groupid Then g.corrected_contribution Else 0 End, 0) as cumulative_contribution_total FROM (Select g.root, g.entityid, g.parentid, g.entity_emission, g.groupid, g.cumulative_total, g.pctcontribution, Round(Case When g.entityid = g.root Then Sum(g.entity_emission - g.contribution_correction) Over(Partition By g.root) When g.entityid != g.root And g.entityid != g.groupid And g.groupid = g.root Then g.cumulative_total - g.contribution_correction When g.entityid != g.root And g.entityid = g.groupid Then g.cumulative_total - g.contribution_correction Else 0 End, 0) as corrected_contribution, CASE WHEN g.entityid != g.root And g.entityid = g.groupid THEN Max(Case When g.entityid != g.root And g.entityid = g.groupid Then (g.cumulative_total - g.contribution_correction) * (100 - g.pctcontribution) / 100 Else 0 End) Over(Partition By g.root, g.groupid) ELSE 0 END as group_correction From grid g Order By  g.root, g.groupid, g.entityid) g;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_55", "sol_sql": ["CREATE VIEW period AS SELECT  t.valid_from, t.valid_to, (SELECT MIN(valid_from) FROM rules AS t2 WHERE t2.valid_from > t.valid_from) AS true_valid_to, t.rate FROM rules AS t;", "SELECT valid_from, valid_to, rate FROM period WHERE valid_from <= '2024-12-31' AND (true_valid_to > '2022-07-01' OR true_valid_to IS NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_56", "sol_sql": ["SELECT p.product_id, p.product_code, GROUP_CONCAT( SUBSTRING_INDEX(SUBSTRING_INDEX(assign_key,',',FIND_IN_SET(a.assign_id,p.assign_key)),',',-1) ORDER BY SUBSTRING_INDEX(SUBSTRING_INDEX(assign_key,',',FIND_IN_SET(a.assign_id,p.assign_key)),',',-1)) as AssignIDs, GROUP_CONCAT( a.value_id ORDER BY a.value_id) as ValueIDs, GROUP_CONCAT( v.value_name ORDER BY a.value_id) as 'Values' FROM products_sample p INNER JOIN assign a ON a.product_id = p.product_id INNER JOIN value_list v ON v.value_id = a.value_id WHERE FIND_IN_SET(a.assign_id,p.assign_key) > 0 GROUP BY p.product_id, p.product_code;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_57", "sol_sql": ["SELECT team_list.t_id FROM team_list JOIN detail ON team_list.t_id = detail.t_id GROUP BY team_list.t_id HAVING MIN(detail.type) = 'a' AND MAX(detail.type) = 'b' AND COUNT(DISTINCT detail.type) = 2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_58", "sol_sql": ["CREATE TABLE LessonSchedule (recordID SMALLINT UNSIGNED NOT NULL, StudentID SMALLINT UNSIGNED, LessonDateTime DATETIME NOT NULL, Primary Key (recordID, StudentID, LessonDateTime), Foreign Key (recordID) REFERENCES record(ID), Foreign Key (StudentID) REFERENCES Student(ID));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    table_exists = False\n    res = execute_queries([\"SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_name = 'LessonSchedule';\"], 'student_club', conn)[0]\n    if res[0][0] == 'LessonSchedule':\n        table_exists = True\n    assert table_exists, f\"Table 'LessonSchedule' was not found.\"\n    "]}
{"instance_id": "MySQL_59", "sol_sql": ["SELECT p.id, p.name, c.item, c.size FROM Packages p LEFT JOIN Contents c ON (c.packageid = p.id) WHERE (SELECT 1 FROM Contents WHERE packageid = p.id AND (item = 'square' AND size = 'A')) AND (SELECT 1 FROM Contents WHERE packageid = p.id AND (item = 'circle' AND size = 'B')) AND (SELECT COUNT(*) FROM Contents WHERE packageid = p.id) = 2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_60", "sol_sql": ["WITH unioned AS ( SELECT t1.id FROM Worker1 t1 UNION ALL SELECT t2.id FROM Worker2 t2), WithLead AS (SELECT u.*, LEAD(u.id) OVER (ORDER BY u.id) AS NextId FROM unioned u) SELECT p.id + 1 AS FirstMissing FROM WithLead p WHERE (p.NextId > p.id + 1 OR p.NextId IS NULL) ORDER BY p.id LIMIT 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_61", "sol_sql": ["WITH T0 AS (SELECT CustomerID, COUNT(*) AS total_count, SUM(isPassed = 'Y') AS pass_count, SUM(isPassed = 'N') AS fail_count FROM TransactionResults GROUP BY CustomerID) UPDATE CustomerTransactions a INNER JOIN T0 ON a.CustomerID = T0.CustomerID SET a.total_count = T0.total_count, a.pass_count = T0.pass_count, a.fail_count = T0.fail_count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = False\n    res = execute_queries([\"SELECT * FROM CustomerTransactions;\"], 'debit_card_specializing', conn)[0]\n    if res[0] == (1, 0, 0, 0) and res[1] == (2, 2, 0, 2) and res[2] == (3, 4, 3, 1):\n        result = True\n    assert result, \"UPDATE is not successful.\"\n    "]}
{"instance_id": "MySQL_62", "sol_sql": ["SELECT UserId, DENSE_RANK() OVER (ORDER BY ViewCount DESC) AS visit_ranking, DENSE_RANK() OVER (ORDER BY FavoriteCount DESC) AS favorite_ranking, DENSE_RANK() OVER (ORDER BY UpvoteCount DESC) AS upvote_ranking FROM user_record ORDER BY UserId;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "MySQL_63", "sol_sql": ["SET @current_time = TIMESTAMP('2022-12-01 12:40:00');", "WITH cte AS (SELECT slot, SUM(total) OVER(ORDER BY slot) AS total, total AS rowtotal FROM sales WHERE slot < @current_time ORDER BY slot DESC LIMIT 1) SELECT total - (30 - TIMESTAMPDIFF(MINUTE, slot, @current_time))/30 * rowtotal AS total FROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "MySQL_64", "sol_sql": ["DROP TABLE IF EXISTS table1;", "DROP PROCEDURE IF EXISTS insertMore;", "DROP PROCEDURE IF EXISTS doWhile", "CREATE TABLE table1(start int NOT NULL, id int PRIMARY KEY AUTO_INCREMENT, counter int NOT NULL, difference int NOT NULL, end int NOT NULL);", "CREATE PROCEDURE doWhile() BEGIN DECLARE i INT DEFAULT 1; DECLARE start INT DEFAULT 120; DECLARE counter INT DEFAULT 1; DECLARE end INT DEFAULT 300; WHILE (i <= end) DO INSERT INTO table1 VALUES (start,null,counter,start+counter,end); SET i = i+1; SET counter = counter+1; END WHILE; END;", "CALL doWhile();", "CREATE PROCEDURE insertMore() BEGIN DECLARE start INT; DECLARE counter INT DEFAULT 1; DECLARE end INT; SELECT COUNT(*) into end FROM table1; SELECT max(id)+1 into start FROM table1; WHILE (counter <= end) DO INSERT INTO table1 VALUES (start,null,counter,start+counter,end); SET counter = counter+1; END WHILE; END;", "CALL insertMore();", "SELECT * FROM table1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "MySQL_65", "sol_sql": ["DROP PROCEDURE IF EXISTS delete_excess_common_cards;", "CREATE PROCEDURE delete_excess_common_cards() BEGIN DECLARE card_count INT DEFAULT 0; SELECT COUNT(*) - 100 INTO card_count FROM cards_test WHERE rarity = 'common'; IF card_count > 0 THEN DELETE FROM cards_test WHERE rarity = 'common' ORDER BY id LIMIT card_count; END IF; END;", "CALL delete_excess_common_cards();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)[0]\n    result = execute_queries([\"SELECT COUNT(*) FROM cards_test WHERE rarity = 'common';\"], db_name, conn)[0]\n    assert result[0][0] == 100, f'Expected 100 rows, but found {result[0][0]} rows'\n"]}
{"instance_id": "MySQL_66", "sol_sql": ["SELECT A.member_id, A.first_name, A.last_name FROM member AS A WHERE A.member_id NOT IN (SELECT link_to_member FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_67", "sol_sql": ["SELECT ProductID, CAST(SUBSTRING_INDEX(Description, 'x', 1) AS UNSIGNED) AS count, CASE WHEN SUBSTRING_INDEX(Description, 'x', -1) LIKE '%Electronics%' THEN 'Electronics-type' ELSE 'Non-electronics-type' END AS type FROM product;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_68", "sol_sql": ["SELECT PRODUCT, 'Periods Overlap!' AS REMARK FROM (SELECT *, DISCOUNT_START - lag(DISCOUNT_END) over (partition by PRODUCT order by DISCOUNT_START) df FROM promotions) p GROUP BY PRODUCT HAVING SUM(df <= 0) > 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_69", "sol_sql": ["SELECT DISTINCT Team, FIRST_VALUE(source) OVER (PARTITION BY Team ORDER BY ID) AS source, FIRST_VALUE(destination) OVER (PARTITION BY Team ORDER BY ID DESC) AS destination FROM source_destination_flight;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_70", "sol_sql": ["SELECT c_id, date, trips, LEAST((SELECT cost FROM TicketCosts WHERE duration = 'Single') * trips, (SELECT cost FROM TicketCosts WHERE duration = 'Day')) AS cost FROM (SELECT ct.c_id, DATE(bt.start_time) AS date, COUNT(*) AS trips FROM CustomerTrip ct JOIN BusTrip bt ON ct.b_id = bt.b_id GROUP BY ct.c_id, DATE(bt.start_time)) AS day_summary;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_71", "sol_sql": ["WITH RECURSIVE data AS (SELECT FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(`timestamp`) / 1800) * 1800) as ts, MAX(status) AS status FROM statuses GROUP BY FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(`timestamp`) / 1800) * 1800)), timestamps (ts, tsmax) AS (SELECT MIN(ts), MAX(ts) FROM data UNION ALL SELECT ts + INTERVAL 30 MINUTE, tsmax FROM timestamps WHERE ts < tsmax) SELECT t.ts, d.status FROM timestamps t LEFT OUTER JOIN data d ON d.ts = t.ts ORDER BY t.ts;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_72", "sol_sql": ["select year_created, DisplayName, cnt_comments from (select YEAR(c.CreationDate) as year_created, u.DisplayName, COUNT(c.Id) as cnt_comments, rank() over(partition by YEAR(c.CreationDate) order by COUNT(c.Id) desc) as rn from comments as c inner join users AS u ON c.UserId = u.Id group by YEAR(c.CreationDate), u.Id ) c where rn <= 3 order by year_created, cnt_comments desc;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_73", "sol_sql": ["SELECT r.CustomerID, r.Description, r.Date FROM (SELECT t.CustomerID, p.Description, t.Date, ROW_NUMBER() OVER (PARTITION BY t.CustomerID ORDER BY t.Date DESC) AS RowNum FROM transactions_1k t INNER JOIN products p ON t.ProductID = p.ProductID) AS r WHERE r.RowNum = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_74", "sol_sql": ["WITH combinations AS (SELECT t1.product_name AS product1, t2.product_name AS product2, COUNT(*) AS num_combinations FROM orders t1 INNER JOIN orders t2 ON t1.customer_id = t2.customer_id AND t1.purchase_rank + 1 = t2.purchase_rank GROUP BY t1.product_name, t2.product_name), total_combinations AS (SELECT SUM(num_combinations) AS total FROM combinations) SELECT product1, product2, num_combinations, num_combinations * 100.0 / total AS percentage FROM combinations, total_combinations;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_75", "sol_sql": ["CREATE TABLE `content` (`id` serial PRIMARY KEY NOT NULL, `item_id` int NOT NULL, `nested_item_id` int, `block_id` int, `order` int NOT NULL);", "create trigger t after insert on content for each row begin if NEW.nested_item_id = NEW.id then signal sqlstate '45000' set message_text = 'content cannot reference itself'; end if; end;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"INSERT INTO `content` (`id`, `item_id`, `nested_item_id`, `order`) VALUES (1, 3, 5, 4);\"], 'card_games', conn)\n    execute_queries([\"INSERT INTO `content` (`id`, `item_id`, `nested_item_id`, `order`) VALUES (2, 4, 2, 5);\"], 'card_games', conn)\n    res = execute_queries([\"SELECT * FROM content;\"], 'card_games', conn)[0]\n    l = len(res)\n    assert l == 1, f\"Returned {l} rows.\"\n    "]}
{"instance_id": "MySQL_76", "sol_sql": ["SELECT d.day, j.start, j.end FROM event CROSS JOIN JSON_TABLE(JSON_KEYS(event_schedule), '$[*]' COLUMNS (day VARCHAR(10) PATH '$')) AS d CROSS JOIN JSON_TABLE(JSON_EXTRACT(event_schedule, CONCAT('$.', d.day)), '$[*]' COLUMNS (`start` TIME PATH '$.start', end TIME PATH '$.end')) AS j WHERE event_id='rec0Si5cQ4rJRVzd6';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_77", "sol_sql": ["WITH cte AS (SELECT *, ROW_NUMBER() OVER(PARTITION BY order_id ORDER BY order_date DESC, id DESC) AS rn FROM records) SELECT SUM(quantity) FROM products t1 INNER JOIN cte t2 ON t1.order_id = t2.order_id AND t2.order_status = 'A' AND t2.rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_78", "sol_sql": ["select type, count(b.cardID) as type_count, count(a.cardID) as total_type_count, (100.0 * count(b.cardID)) /  count(a.cardID) as  percent_penetration from card_type a left join info b on a.cardID = b.cardID group by type order by type_count desc;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_79", "sol_sql": ["INSERT INTO rulings (date, text, uuid) SELECT date, text, uuid FROM (SELECT '2023-01-01' AS date, 'Some ruling text.' AS text, (SELECT uuid FROM cards WHERE borderColor = 'black' AND layout = 'normal' LIMIT 1) AS uuid UNION ALL SELECT '2023-01-02' AS date, 'Another ruling text.' AS text, (SELECT uuid FROM cards WHERE isAlternative = 1 LIMIT 1) AS uuid) AS t WHERE NOT EXISTS (SELECT 1 FROM rulings WHERE rulings.date = t.date);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = execute_queries([\"SELECT * FROM rulings WHERE YEAR(date) = 2023;\"], 'card_games', conn)[0]\n    l = len(res)\n    assert l == 2, f\"Returned {l} rows.\"\n    "]}
{"instance_id": "MySQL_80", "sol_sql": ["\n(SELECT t1.TransactionID, g.GasStationID, p.ProductID,\n       COALESCE(t1.Date, g.Country, p.Description) AS Date, \n       COALESCE(t1.Amount, 0) AS Amount, \n       COALESCE(g.ChainID, 0) AS ChainID, \n       COALESCE(p.Description, '') AS Description \nFROM transactions_1k t1 LEFT JOIN gasstations g ON t1.GasStationID = g.GasStationID \n                        LEFT JOIN products p ON t1.ProductID = p.ProductID) \nUNION \n(SELECT t2.TransactionID, g.GasStationID, p.ProductID, \n       COALESCE(t2.Date, g.Country, p.Description) AS Date, \n       COALESCE(t2.Amount, 0) AS Amount, \n       COALESCE(g.ChainID, 0) AS ChainID, \n       COALESCE(p.Description, '') AS Description \nFROM gasstations g LEFT JOIN transactions_1k t2 ON t2.GasStationID = g.GasStationID \n                   LEFT JOIN products p ON t2.ProductID = p.ProductID \nWHERE t2.GasStationID IS NULL) \nUNION \n(SELECT t3.TransactionID, g.GasStationID, p.ProductID, \n       COALESCE(t3.Date, g.Country, p.Description) AS Date, \n       COALESCE(t3.Amount, 0) AS Amount, \n       COALESCE(g.ChainID, 0) AS ChainID, \n       COALESCE(p.Description, '') AS Description \nFROM products p LEFT JOIN transactions_1k t3 ON t3.ProductID = p.ProductID \n                LEFT JOIN gasstations g ON t3.GasStationID = g.GasStationID \nWHERE t3.ProductID IS NULL);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n"]}
{"instance_id": "MySQL_81", "sol_sql": ["\nWITH rates(n) AS (\n    VALUES ROW(0), ROW(1), ROW(2), ROW(3), ROW(4), ROW(5)\n)\nSELECT r.n RATES,\n    SUM(A8 = r.n) A8,\n    SUM(A9 = r.n) A9\nFROM rates r\nLEFT JOIN district d ON A8 = r.n OR A9 = r.n\nGROUP BY r.n\nORDER BY r.n DESC;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"instance_id": "MySQL_82", "sol_sql": ["DROP TABLE IF EXISTS calendar;", "DROP PROCEDURE IF EXISTS FillCalendar;", "CREATE TABLE calendar (\n    calendar_date DATE PRIMARY KEY\n);", "CREATE PROCEDURE FillCalendar()\nBEGIN\n    -- Declare variables with a non-reserved name\n    DECLARE current_dt DATE; -- Changed variable name from current_date\n\n    -- Initialize variables\n    SET current_dt = '2010-01-01';\n\n    -- Start transaction for better performance\n    START TRANSACTION;\n\n    WHILE current_dt <= DATE('2014-12-31') DO\n        -- Check if the current date is a weekend or holiday\n        IF (DAYOFWEEK(current_dt) = 1 OR DAYOFWEEK(current_dt) = 7) OR current_dt IN (\n            '2010-01-01', '2010-07-04', '2010-11-11', '2010-12-25',\n            '2011-01-01', '2011-07-04', '2011-11-11', '2011-12-25',\n            '2012-01-01', '2012-07-04', '2012-11-11', '2012-12-25',\n            '2013-01-01', '2013-07-04', '2013-11-11', '2013-12-25',\n            '2014-01-01', '2014-07-04', '2014-11-11', '2014-12-25'\n        ) THEN\n            INSERT INTO calendar (calendar_date) VALUES (current_dt);\n        END IF;\n\n        -- Move to the next day\n        SET current_dt = DATE_ADD(current_dt, INTERVAL 1 DAY);\n    END WHILE;\n\n    COMMIT;\nEND", "CALL FillCalendar();", "SELECT u.Id, u.DisplayName, u.Age, COUNT(*) AS TotalDays\nFROM users u INNER JOIN calendar c\n ON c.calendar_date >= u.CreationDate\n AND c.calendar_date <= u.LastAccessDate\nGROUP BY\nu.Id, u.DisplayName, u.Age;", "DROP TABLE IF EXISTS calendar;", "DROP PROCEDURE IF EXISTS FillCalendar;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"instance_id": "MySQL_83", "sol_sql": ["\nSELECT DISTINCT t1.CustomerID as Customer1, t2.CustomerID as Customer2, COUNT(*) as Count FROM transactions_1k t1 JOIN transactions_1k t2 ON t1.Date = t2.Date AND t1.GasStationID = t2.GasStationID AND t1.CustomerID < t2.CustomerID GROUP BY Customer1, Customer2 ORDER BY Count DESC;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"instance_id": "MySQL_84", "sol_sql": ["\nWITH DAILY_REVENUE AS (SELECT Date, SUM(Amount) AS TotalAmount FROM transactions_1k GROUP BY Date ORDER BY Date ASC) , MOVING_AVG AS( SELECT Date, CASE WHEN COUNT(*) OVER(ORDER BY Date ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) = 3 THEN SUM(TotalAmount) OVER(ORDER BY Date ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) ELSE NULL END AS TotalAmount, CASE WHEN COUNT(*) OVER(ORDER BY Date ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) = 3 THEN CAST(AVG(TotalAmount) OVER(ORDER BY Date ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS DECIMAL(10,2)) ELSE NULL END AS AverageAmount FROM DAILY_REVENUE) SELECT * FROM MOVING_AVG;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"instance_id": "MySQL_85", "sol_sql": ["\nWITH RECURSIVE cte AS ( \n\tSELECT s.id, s.code, s.parentCode, s.code AS origCode\n\tFROM sets s \n\tWHERE s.parentCode IS NULL \n\tUNION ALL \n\tSELECT s.id, s.code, s.parentCode, CONCAT(s.code,'-',s2.origCode) AS origCode\n\tFROM sets s \n\tINNER JOIN cte s2\n\t\tON s2.code = s.parentCode\n)\nSELECT s.id, s.code, s.origCode AS ancestralCode FROM cte s\nWHERE s.`parentCode` IS NOT NULL\nGROUP BY s.id, s.code, s.origCode;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n"]}
{"instance_id": "MySQL_86", "sol_sql": ["\nSELECT e.event_id AS event_id, \n       e.event_name AS event_name, \n       MAX(a.link_to_member) AS largest_member, \n       largest_member_cost,\n       avg_largest_member_cost,\n       largest_member_amount,\n       avg_largest_member_amount\nFROM event e\nINNER JOIN attendance a\n        ON e.event_id = a.link_to_event\nINNER JOIN (SELECT MAX(a.link_to_member) AS largest_member_cost,\n                  ROUND(AVG(ex.cost), 2) AS avg_largest_member_cost,\n                  a.link_to_event\n            FROM attendance a\n            INNER JOIN expense ex\n                    ON a.link_to_member = (\n                      SELECT MAX(ex.link_to_member)\n                      FROM expense ex\n                      WHERE ex.cost IS NOT NULL\n                      AND ex.link_to_member IN (\n                        SELECT link_to_member\n                        FROM attendance a\n                        WHERE a.link_to_event = 'rec2N69DMcrqN9PJC'\n                      )\n                    )\n            WHERE a.link_to_event = 'rec2N69DMcrqN9PJC'\n            GROUP BY a.link_to_event\n          ) AS largest_cost ON largest_cost.link_to_event = e.event_id\nINNER JOIN (SELECT MAX(a.link_to_member) AS largest_member_amount,\n                  ROUND(AVG(i.amount), 2) AS avg_largest_member_amount,\n                  a.link_to_event\n            FROM attendance a\n            INNER JOIN income i\n                    ON a.link_to_member = (\n                      SELECT MAX(i.link_to_member) \n                      FROM income i \n                      WHERE i.amount IS NOT NULL \n                      AND i.link_to_member IN (\n                        SELECT link_to_member \n                        FROM attendance a \n                        WHERE a.link_to_event = 'rec2N69DMcrqN9PJC'\n                      )\n                    )\n            WHERE a.link_to_event = 'rec2N69DMcrqN9PJC'\n            GROUP BY a.link_to_event\n          ) AS largest_amount ON largest_amount.link_to_event = e.event_id\nGROUP BY  e.event_id,\n          e.event_name, \n          largest_member_cost, \n          avg_largest_member_cost, \n          largest_member_amount, \n          avg_largest_member_amount;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n"]}
{"instance_id": "MySQL_87", "sol_sql": ["\nDROP PROCEDURE IF EXISTS delcolumn;\n", "\nCREATE PROCEDURE delcolumn(\n\ttbname varchar(100)\n)\nBEGIN\n\tDECLARE finished INTEGER DEFAULT 0;\n\tDECLARE colname varchar(100) DEFAULT \"\";\n\tDECLARE curcol\n\t\tCURSOR FOR\n\t\t\tSELECT COLUMN_NAME\n\t\t\tFROM INFORMATION_SCHEMA.COLUMNS\n\t\t\tWHERE TABLE_NAME = tbname;\n\tDECLARE CONTINUE HANDLER\n\t\tFOR NOT FOUND SET finished = 1;\n\tOPEN curcol;\n\n\tgetcol: LOOP\n\t\tFETCH curcol INTO colname;\n\t\tIF finished = 1 THEN\n\t\t\tLEAVE getcol;\n\t\tEND IF;\n\t\tSET @sql = CONCAT('SELECT COUNT(`',colname,'`) INTO @count FROM `',tbname,'`;');\n\t\tPREPARE stmt2 FROM @sql;\n\t\tEXECUTE stmt2;\n\t\tIF @count = 0 THEN\n\t\tSET @sql = CONCAT('ALTER TABLE `',tbname,'` DROP COLUMN `',colname,'`');\n\t\tPREPARE stmt2 FROM @sql;\n\t\tEXECUTE stmt2;\n\t\tEND IF;\n\tEND LOOP getcol;\n\tCLOSE curcol;\nEND;\n", "\nCALL delcolumn('digital_localization_analysis');\n", "\nDROP PROCEDURE IF EXISTS delcolumn;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n\n    test_sqls = [\"SELECT SUM(CASE WHEN column_name IN ('card_id', 'card_name', 'digital_set', 'digital_release') THEN 1 ELSE 0 END) AS required_columns_exist, SUM(CASE WHEN column_name IN ('physical_block', 'alt_language', 'paper_legality') THEN 1 ELSE 0 END) AS removed_columns_exist FROM ( SELECT DISTINCT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = 'digital_localization_analysis') AS unique_columns;\"]\n\n    required_column_number, removed_column_number = execute_queries(test_sqls, db_name, conn)[0][0]\n    assert required_column_number == 4, f\"Expected 4 columns retained but got {required_column_number} left.\"\n    assert removed_column_number == 0, f\"Expected 3 columns removed but got {removed_column_number} left.\"\n"]}
{"instance_id": "MySQL_88", "sol_sql": ["SELECT results.score, scores.value, scores.Segment FROM customer_scores scores JOIN customer_results results ON scores.Segment = results.Segment WHERE results.score >= scores.score GROUP BY scores.CustomerID, scores.Segment, results.score, scores.value ORDER BY scores.CustomerID DESC"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_89", "sol_sql": ["WITH Partitioned AS ( SELECT *, ROW_NUMBER() OVER (PARTITION BY CustomerID, Date ORDER BY CustomerID, Date) AS RowNumber FROM transactions_1k )SELECT *, CASE WHEN RowNumber > 1 THEN 0 ELSE ABS(COALESCE(DATEDIFF((SELECT MAX(Date) FROM transactions_1k WHERE Date < a.Date AND CustomerID = a.CustomerID), a.Date), 0)) END AS Days_between FROM Partitioned a"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    "]}
{"instance_id": "MySQL_90", "sol_sql": ["SELECT h1.hero_id AS id1, h2.hero_id AS id2 FROM (SELECT hero_id, GROUP_CONCAT(DISTINCT power_id ORDER BY power_id) AS power_set FROM hero_power GROUP BY hero_id) h1 JOIN (SELECT hero_id, GROUP_CONCAT(DISTINCT power_id ORDER BY power_id) AS power_set FROM hero_power GROUP BY hero_id) h2 ON h1.power_set = h2.power_set AND h1.hero_id < h2.hero_id"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    "]}
{"instance_id": "MySQL_91", "sol_sql": ["SELECT m.department, e.cost AS highest_cost, COUNT(e.expense_id) AS cost_count FROM expense e INNER JOIN member mem ON e.link_to_member = mem.member_id INNER JOIN major m ON mem.link_to_major = m.major_id WHERE e.cost = (SELECT MAX(cost) FROM expense) GROUP BY m.department, e.cost HAVING COUNT(e.expense_id) = (SELECT MAX(dept_count) FROM (SELECT COUNT(e2.expense_id) AS dept_count FROM expense e2 INNER JOIN member mem2 ON e2.link_to_member = mem2.member_id INNER JOIN major m2 ON mem2.link_to_major = m2.major_id WHERE e2.cost = (SELECT MAX(cost) FROM expense) GROUP BY m2.department) AS cost_counts)"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_92", "sol_sql": ["WITH segment_counts AS (SELECT Country, Segment, COUNT(*) AS count_segment, DENSE_RANK() OVER (PARTITION BY Country ORDER BY COUNT(*) DESC) AS rnk FROM gasstations GROUP BY Country, Segment)SELECT Country, Segment, count_segment FROM segment_counts WHERE rnk = 1"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "MySQL_93", "sol_sql": ["ALTER TABLE transactions_1k ADD COLUMN MA100 DECIMAL(8,2);", "WITH cte AS (SELECT TransactionID, CustomerID, Date, Time, Amount, AVG(Amount) OVER (PARTITION BY CustomerID ORDER BY Date, Time ROWS BETWEEN 99 PRECEDING AND CURRENT ROW) AS running_avg FROM transactions_1k) UPDATE transactions_1k INNER JOIN cte ON transactions_1k.TransactionID = cte.TransactionID SET transactions_1k.MA100 = cte.running_avg;"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT MA100 FROM transactions_1k;\"]\n    _, exec_err, _, _ = execute_queries(queries, db_name, conn)  \n    assert exec_err == False, \"Failed to create column MA100\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT MA100 FROM transactions_1k WHERE MA100 IS NULL\"], db_name, conn)[0]\n    assert len(test_pred_query_result_2) == 0, \"The update didn't happen\"\n    "]}
{"instance_id": "MySQL_94", "sol_sql": ["SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'card_games' ORDER BY UPDATE_TIME DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_95", "sol_sql": ["SELECT pt.ID, pt.SEX, pt.Birthday, ex.Diagnosis FROM Patient pt JOIN Examination ex ON pt.ID = ex.ID WHERE ex.Diagnosis = 'SLE' AND ex.`aCL IgG` > 3.0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_96", "sol_sql": ["SELECT \n    transactions_1k.TransactionID, \n    transactions_1k.Date, \n    transactions_1k.CustomerID, \n    GROUP_CONCAT(gasstations.GasStationID ORDER BY transactions_1k.TransactionID SEPARATOR '|') AS gasstation_ids, \n    GROUP_CONCAT(products.ProductID ORDER BY transactions_1k.TransactionID SEPARATOR '|') AS product_ids \nFROM \n    transactions_1k \nLEFT JOIN \n    gasstations ON transactions_1k.GasStationID = gasstations.GasStationID \nLEFT JOIN \n    products ON transactions_1k.ProductID = products.ProductID \nWHERE \n    transactions_1k.CustomerID IS NOT NULL \nGROUP BY \n    transactions_1k.CustomerID, transactions_1k.TransactionID, transactions_1k.Date;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_97", "sol_sql": ["SELECT cd.*, fd.* FROM cards cd INNER JOIN foreign_data fd ON cd.uuid = fd.uuid WHERE FIND_IN_SET('paper', cd.availability) ORDER BY cd.originalReleaseDate DESC LIMIT 0, 100"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_98", "sol_sql": ["SELECT link_to_event, CASE WHEN MAX(event_status = 'Closed') = 1 THEN 'Closed' WHEN MAX(event_status = 'Open') = 1 AND MAX(event_status = 'Planning') = 1 THEN 'Open' WHEN MAX(event_status = 'Open') = 1 THEN 'Open' WHEN MAX(event_status = 'Planning') = 1 THEN 'Planning' ELSE 'Unknown' END AS event_status, CASE WHEN MAX(event_status = 'Closed') = 1 THEN MAX(CASE WHEN event_status = 'Closed' THEN remaining END) WHEN MAX(event_status = 'Open') = 1 AND MAX(event_status = 'Planning') = 1 THEN MAX(CASE WHEN event_status = 'Open' THEN spent END) + MAX(CASE WHEN event_status = 'Planning' THEN spent END) WHEN MAX(event_status = 'Open') = 1 THEN MAX(CASE WHEN event_status = 'Open' THEN spent END) WHEN MAX(event_status = 'Planning') = 1 THEN MAX(CASE WHEN event_status = 'Planning' THEN spent END) END AS remaining FROM budget GROUP BY link_to_event;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "MySQL_99", "sol_sql": ["SELECT MIN(date) AS start_date, MAX(date) AS end_date \nFROM (\n    SELECT \n        date, \n        @island := IF(@prev_date = date - INTERVAL 1 DAY, @island, @island + 1) AS island, \n        @prev_date := date \n    FROM (\n        SELECT date \n        FROM `Match` \n        WHERE league_id = '1' \n        ORDER BY date\n    ) AS t1, \n    (SELECT @prev_date := NULL, @island := 0) AS vars\n) AS t2 \nGROUP BY island;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "SQLServer_0", "sol_sql": ["SELECT TOP 1 WITH TIES s.school, sa.avgscrread, sa.avgscrmath, sa.avgscrwrite FROM schools AS s INNER JOIN satscores AS sa ON s.cdscode = sa.cds WHERE s.county = 'Alameda' AND sa.rtype = 'S' ORDER BY sa.avgscrread DESC;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_1", "sol_sql": ["WITH cte AS (\n    SELECT\n        cdscode,\n        school,\n        fundingtype,\n        ROW_NUMBER() OVER (\n            PARTITION BY cdscode\n            ORDER BY lastupdate\n        ) AS rn\n    FROM schools\n)\n\nSELECT\n    c.cdscode,\n    'School' AS columnname,\n    p.school AS oldvalue,\n    c.school AS newvalue\nFROM cte AS c\nLEFT JOIN cte AS p\n    ON\n        c.cdscode = p.cdscode\n        AND p.rn + 1 = c.rn\nWHERE COALESCE(c.school, '') != COALESCE(p.school, '')\nUNION ALL\nSELECT\n    c.cdscode,\n    'FundingType' AS columnname,\n    p.fundingtype AS oldvalue,\n    c.fundingtype AS newvalue\nFROM cte AS c\nLEFT JOIN cte AS p\n    ON\n        c.cdscode = p.cdscode\n        AND p.rn + 1 = c.rn\nWHERE COALESCE(c.fundingtype, '') != COALESCE(p.fundingtype, '')\nORDER BY\n    c.cdscode,\n    columnname;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_2", "sol_sql": ["SELECT \"TransactionID\",\"CustomerID\" FROM transactions_1k ORDER BY TransactionID DESC OFFSET 300 ROWS FETCH NEXT 20 ROWS ONLY;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_3", "sol_sql": ["CREATE PROCEDURE InsertOrUpdateAccount\n    @account_id INT,\n    @district_id INT,\n    @frequency VARCHAR(50),\n    @date DATE\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    IF EXISTS (SELECT 1 FROM account WHERE account_id = @account_id)\n    BEGIN\n        UPDATE account\n        SET frequency = @frequency, date = @date\n        WHERE account_id = @account_id;\n    END\n    ELSE\n    BEGIN\n        INSERT INTO account (account_id, district_id, frequency, date)\n        VALUES (@account_id, @district_id, @frequency, @date);\n    END;\nEND;", "EXEC InsertOrUpdateAccount 4, 10, 'POPLATEK PO OBRATU', '2023-04-01';", "EXEC InsertOrUpdateAccount 9999, 3, 'POPLATEK TYDNE', '2024-10-22';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT frequency FROM account WHERE account_id = 4;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'POPLATEK PO OBRATU', f\"Expected frequency to match, but found {test_pred_query_result_1[0][0]}\"\n    test_pred_query_result_1 = execute_queries([\"SELECT date FROM account WHERE account_id = 4;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == date.fromisoformat('2023-04-01'), f\"Expected date to change, but found {test_pred_query_result_1[0][0]}\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT district_id FROM account WHERE account_id = 9999;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 3, f'Expected district id to insert, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT date FROM account WHERE account_id = 9999;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == date.fromisoformat('2024-10-22'), f\"Expected date to match, but found {test_pred_query_result_1[0][0]}\"\n    test_pred_query_result_1 = execute_queries([\"SELECT frequency FROM account WHERE account_id = 9999;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'POPLATEK TYDNE', f\"Expected frequency to match, but found {test_pred_query_result_1[0][0]}\"\n    "]}
{"instance_id": "SQLServer_4", "sol_sql": ["SELECT e.event_id,COALESCE(e.notes,(SELECT TOP 1 e2.notes FROM event e2 WHERE e2.event_id > e.event_id AND e2.notes IS NOT NULL ORDER BY e2.event_id ASC)) AS imputed_notes FROM event e ORDER BY e.event_id ASC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_5", "sol_sql": ["SELECT a.link_to_member, MAX(e.event_date) AS Latest_Event_Date FROM attendance a JOIN event e ON a.link_to_event = e.event_id GROUP BY a.link_to_member;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_6", "sol_sql": ["WITH RankedTrans AS (\n    SELECT\n        trans_id,\n        account_id,\n        date,\n        ROW_NUMBER() OVER (PARTITION BY account_id ORDER BY date) AS rn,\n        MIN(date) OVER (PARTITION BY account_id) AS first_date,\n        LAG(date) OVER (PARTITION BY account_id ORDER BY date) AS prev_date\n    FROM trans\n),\nCategorizedTrans AS ( \n    SELECT\n        trans_id,\n        account_id,\n        date,\n        CASE\n            WHEN rn = 1 THEN 'New'\n            WHEN DATEDIFF(DAY, prev_date, date) <= 30 THEN 'Followup'\n            ELSE 'New'\n        END AS Category\n    FROM RankedTrans\n)\nSELECT TOP 10 * \nFROM CategorizedTrans\nORDER BY trans_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = check_sql_function_usage(pred_sqls, [\"WITH\"])\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_7", "sol_sql": ["WITH CommonEvents AS (\n    SELECT\n        m1.member_id AS member1_id,\n        m2.member_id AS member2_id,\n        e.event_date\n    FROM attendance a1\n    JOIN attendance a2 ON a1.link_to_event = a2.link_to_event AND a1.link_to_member < a2.link_to_member\n    JOIN member m1 ON a1.link_to_member = m1.member_id\n    JOIN member m2 ON a2.link_to_member = m2.member_id\n    JOIN event e ON a1.link_to_event = e.event_id\n),\nLastCommonEvents AS (\n    SELECT\n        member1_id,\n        member2_id,\n        MAX(event_date) AS last_common_event_date\n    FROM CommonEvents\n    GROUP BY member1_id, member2_id\n),\nMostOverduePair AS (\n  SELECT TOP 1\n        member1_id,\n        member2_id,\n        last_common_event_date\n    FROM LastCommonEvents\n    ORDER BY last_common_event_date ASC\n)\nSELECT * FROM MostOverduePair"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_8", "sol_sql": ["SELECT C.name, C.manaCost FROM cards C LEFT JOIN legalities L ON L.uuid = C.uuid WHERE L.id IS NULL;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    result = check_sql_function_usage(pred_sqls,[\"LEFT JOIN\"])\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_9", "sol_sql": ["DECLARE @batch INT = 100\n\nINSERT INTO player_stats (player_id, match_id, goals, assists, yellow_cards, red_cards, minutes_played)\nSELECT TOP (@batch)\n             t.player_id,\n             t.match_id,\n             t.goals,\n             t.assists,\n             t.yellow_cards,\n             t.red_cards,\n             t.minutes_played\n      FROM player_stats_temp AS t\n      WHERE NOT EXISTS (\n        SELECT 1\n        FROM player_stats p\n        WHERE p.player_id = t.player_id\n      );"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM player_stats;\"], db_name,conn)[0]\n    test_pred_query_result_2 = execute_queries([\"SELECT * FROM player_stats_temp;\"], db_name,conn)[0]\n    assert test_pred_query_result_1 == test_pred_query_result_2, f'Expected insertion match, but found {test_pred_query_result_1}'\n    "]}
{"instance_id": "SQLServer_10", "sol_sql": ["\n        WITH CTE_Initial AS (\n            SELECT TOP 100  *, \n                ROW_NUMBER() OVER (ORDER BY DriverId, ContractType) AS UID,\n                ROW_NUMBER() OVER (ORDER BY DriverId, ContractType) AS GroupId\n            FROM driverContracts\n        ),\n        CTE_Working AS (\n            SELECT UID, DriverId, ContractType, StartDate, EndDate, GroupId\n            FROM CTE_Initial\n        ),\n        CTE_Updated AS (\n            SELECT \n                T1.UID,\n                T1.DriverId,\n                T1.ContractType,\n                T1.StartDate,\n                T1.EndDate,\n                MIN(CASE \n                        WHEN T1.GroupId < T2.GroupId THEN T1.GroupId \n                        ELSE T2.GroupId \n                    END) OVER (PARTITION BY T1.DriverId, T1.ContractType) AS NewGroupId\n            FROM CTE_Working T1\n            LEFT JOIN CTE_Working T2\n                ON T1.DriverId = T2.DriverId\n                AND T1.ContractType = T2.ContractType\n                AND T1.GroupId <> T2.GroupId\n                AND T1.StartDate <= T2.EndDate \n                AND T2.StartDate <= T1.EndDate\n        ),\n        CTE_Final AS (\n            SELECT UID, DriverId, ContractType, StartDate, EndDate, \n                MIN(NewGroupId) OVER (PARTITION BY DriverId, ContractType) AS GroupId\n            FROM CTE_Updated\n        ),\n        CTE_Grouped AS (\n            SELECT DriverId, ContractType, GroupId,\n                MIN(StartDate) AS StartDate, \n                MAX(EndDate) AS EndDate\n            FROM CTE_Final\n            GROUP BY DriverId, ContractType, GroupId\n        )\n        SELECT DriverId, StartDate, EndDate, ContractType\n        FROM CTE_Grouped\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_11", "sol_sql": ["\n        WITH rec AS\n        (\n            SELECT this.ID\n                , MAX(this.Date) AS Lastdate\n                , Prevdate =\n                (SELECT MAX(prev.Date) \n                    FROM Laboratory prev \n                    WHERE prev.ID = this.ID\n                    AND prev.Date < MAX(this.Date)\n                ) \n            FROM Laboratory this\n            GROUP BY this.ID\n        )\n        UPDATE mostRecent\n        SET GOT = prev.GOT\n            , GPT = prev.GPT\n        FROM Laboratory mostRecent\n        JOIN rec\n            ON rec.Lastdate = mostRecent.Date \n        JOIN Laboratory prev\n            ON prev.Date = rec.Prevdate\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = ['SELECT GOT, GPT FROM Laboratory;']\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert res == [(34, 36), (29, 31), (29, 31), (37, 42)]\n    "]}
{"instance_id": "SQLServer_12", "sol_sql": ["\n        WITH cte AS (\n            SELECT member_id, e.[first_name] + ' ' + e.[last_name] AS full_name, email\n            FROM member_email e \n        )\n        SELECT cte.member_id, cte.full_name, cte.email, p.position\n        FROM cte INNER JOIN member_position p\n        ON cte.full_name = p.full_name;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_13", "sol_sql": ["\n        DECLARE @STARTDATE NVARCHAR(100) = '1995-04-04'\n        DECLARE @ENDDATE   NVARCHAR(100) = '1995-04-05'\n\n\n        DECLARE @cols NVARCHAR(MAX) = STUFF(\n        (\n            SELECT DISTINCT\n                ', ' + QUOTENAME([type])\n            FROM trans\n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)')\n        , 1, 2, '')\n\n        DECLARE @sql NVARCHAR(MAX) = \n        N'\n        SELECT *\n        FROM\n        (\n            SELECT \n                [date]         AS Transaction_Date,\n                [type],\n                COUNT(*)       AS n\n            FROM trans\n            WHERE [date] BETWEEN ''' + @STARTDATE + ''' AND ''' + @ENDDATE + '''\n            GROUP BY [date], [type]\n        ) s\n        PIVOT\n        (\n            MAX(n)\n            FOR [type] IN (' + @cols + ')\n        ) pvt;\n        '\n\n        EXEC (@sql)\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base_dict(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_dict returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_14", "sol_sql": ["\n        CREATE PROCEDURE MyProc\n            @ID INT\n        AS\n        BEGIN\n            IF @ID IS NULL\n            BEGIN\n                RAISERROR (15600, -1, -1, 'MyProc');\n                RETURN; \n            END;\n\n            SELECT \n                name,\n                artist\n            FROM cards\n            WHERE id = @ID;\n        END;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n        \"\"\"\n        EXEC MyProc @ID = 42;\n        \"\"\"\n    ]\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert res == [('Dehydration', 'Arnie Swekel')]\n    \n    queries = [\n        \"\"\"\n        EXEC MyProc @ID = NULL;\n        \"\"\"\n    ]\n    \n    res, error, _ = execute_queries(queries, db_name, conn)\n    assert error == True\n    "]}
{"instance_id": "SQLServer_15", "sol_sql": ["\n        WITH cte AS (\n            SELECT ID, ParentID, ID as [StartID]\n            FROM LaboratoryLink\n            WHERE ID IN (657266, 115562)\n            UNION ALL\n            SELECT t.ID, t.ParentID, c.StartID\n            FROM LaboratoryLink t\n            JOIN cte c ON t.ID = c.ParentID\n        )\n        SELECT c.StartID, c.ID\n        FROM cte c\n        where c.ParentID is null;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert (115562, 71417) in pred_query_result\n    assert (657266, 27654) in pred_query_result\n    "]}
{"instance_id": "SQLServer_16", "sol_sql": ["\n        DECLARE\n        @PageSize INT = 10\n        , @PageNum  INT = 1;\n\n        WITH TempResult AS (SELECT\n                                id\n                                , superhero_name\n                            FROM  superhero_name\n                            WHERE id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        )\n        SELECT\n                *, MaxRows = COUNT(*) OVER()\n        FROM     TempResult\n        ORDER BY TempResult.superhero_name OFFSET (@PageNum - 1) * @PageSize ROWS\n        FETCH NEXT @PageSize ROWS ONLY;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_17", "sol_sql": ["\n        DECLARE @info NVARCHAR(100) = '{\"client_id\":1,\"gender\":\"F\"}';\n        IF (ISJSON(@info) > 0)  \n        BEGIN  \n            IF EXISTS (\n                SELECT 1 \n                FROM OPENJSON(@info) \n                WHERE [key] = 'gender'\n            )\n                SET @info = JSON_MODIFY(@info, '$.gender', 'M');\n        END;\n        SELECT @info AS info;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import json\n    global pred_query_result\n    res = json.loads(pred_query_result[0][0])\n    assert res['client_id'] == 1\n    assert res['gender'] == 'M'\n    "]}
{"instance_id": "SQLServer_18", "sol_sql": ["\n        DECLARE @xml XML = (\n        SELECT (\n        SELECT COLUMN_NAME, DATA_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'schools'\n        FOR XML PATH('Column'), TYPE) AS [Columns], \n        (SELECT cds, rtype FROM satscores FOR XML PATH('Row'), TYPE) AS [Rows] FOR XML PATH('Results')\n        );\n        \n        SELECT @xml.value('.', 'nvarchar(max)') AS EntireXmlAsText;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_19", "sol_sql": ["\n        CREATE OR ALTER TRIGGER [dbo].[InsertRaceName] ON [dbo].[races] \n            AFTER INSERT \n        AS \n        BEGIN \n            INSERT INTO [dbo].[race_names](race_name) \n            VALUES ('New Race') \n        END\n        ", "\n        INSERT INTO dbo.races (\n            [raceId],\n            [year],\n            [round],\n            [circuitId],\n            [name],\n            [date],\n            [time],\n            [url]\n        )\n        VALUES (\n            -1,\n            2009,\n            1,\n            10,\n            'New Test Race',\n            '2009-07-15',\n            '12:00:00',\n            'https://example.com'\n        );\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = ['SELECT * FROM race_names']\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert res[0][0] == 'New Race'\n    "]}
{"instance_id": "SQLServer_20", "sol_sql": ["\n        SELECT \n            CustomerID,\n            Consumption,\n            FORMAT(MIN(RealDate), 'yyyyMM') AS MinYearMonth,\n            FORMAT(MAX(RealDate), 'yyyyMM') AS MaxYearMonth\n        FROM\n        (\n            SELECT\n                st.*,\n                CAST(st.[Date] + '01' AS date) AS RealDate,\n\n                ROW_NUMBER() OVER (\n                    PARTITION BY st.CustomerID, st.Consumption\n                    ORDER BY CAST(st.[Date] + '01' AS date)\n                ) AS seqnum\n            FROM yearmonth st\n        ) AS st\n        GROUP BY\n            DATEADD(MONTH, -seqnum, RealDate),\n            CustomerID,\n            Consumption\n        ORDER BY\n            MIN(RealDate)\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_21", "sol_sql": ["\n        SELECT TOP 100  ROW_NUMBER() OVER (Order by T.TransactionID) as Row, DATEDIFF(SECOND, T.Date, LEAD(T.Date,1,T.Date) OVER (ORDER BY T.Date)) as TimeDifference FROM transactions_1k T\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_22", "sol_sql": ["\n        IF OBJECT_ID('tempdb..#AccountLvl', 'U') IS NULL\n        BEGIN\n            CREATE TABLE #AccountLvl (\n                [account_id] INT,\n                [lvl] INT\n            );\n        END\n        ", "\n        WITH Sorted AS (\n            SELECT\n                account_id,\n                ROW_NUMBER() OVER (ORDER BY account_id) AS lvl\n            FROM [account]\n        )\n        INSERT INTO #AccountLvl (account_id, lvl)\n        SELECT account_id, lvl\n        FROM Sorted;\n        ", "\n        SELECT TOP(1) * FROM #AccountLvl LEFT JOIN disp ON disp.account_id = #AccountLvl.account_id ORDER BY #AccountLvl.account_id, disp.disp_id;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_23", "sol_sql": ["\n        SELECT NEXT VALUE FOR budget_seq AS NextSeqVal\n        FROM (VALUES \n            (1),(2),(3),(4),(5),\n            (6),(7),(8),(9),(10)\n        ) AS T(n);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 10\n    res = [i[0] for i in pred_query_result]\n    assert res == [i+1 for i in range(10)]\n    \n    sec_pred_query_result,_,_ = execute_queries(pred_sqls, db_name, conn)\n    assert len(sec_pred_query_result) == 10\n    sec_res = [i[0] for i in sec_pred_query_result]\n    assert sec_res == [i+1 for i in range(10,20)]\n    "]}
{"instance_id": "SQLServer_24", "sol_sql": ["\n        SELECT\n            c.issued AS CDATE,\n            DATENAME(WEEKDAY, c.issued) AS CDAY\n        FROM card c\n        ORDER BY c.issued;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_25", "sol_sql": ["\n        SELECT \n            full_name,\n            CHARINDEX(' ', full_name, CHARINDEX(' ', full_name) + 1) AS second_space\n        FROM superhero;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_26", "sol_sql": ["\n        SELECT A2\n        FROM district_new\n        WHERE\n            A2 = UPPER(A2) COLLATE SQL_Latin1_General_CP1_CS_AS OR\n            A2 = LOWER(A2) COLLATE SQL_Latin1_General_CP1_CS_AS\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_27", "sol_sql": ["\n        DECLARE @LabResults TABLE(ID INT, Date DATE, GOT INT, GPT INT, LDH INT);\n        DECLARE @PatientInfo TABLE(ID INT, SEX NVARCHAR, Birthday DATE);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    _, error, _ = execute_queries(pred_sqls, db_name, conn)\n    assert error == False\n    "]}
{"instance_id": "SQLServer_28", "sol_sql": ["\n        SELECT date, account_id, \n        CASE COUNT(DISTINCT CASE WHEN type IN ('PRIJEM', 'VYDAJ', 'SLUZBY') THEN type END) WHEN 3 THEN 1 ELSE 0 END FROM trans GROUP BY [date], account_id\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    _, error, _ = execute_queries(pred_sqls, db_name, conn)\n    assert error == False\n    "]}
{"instance_id": "SQLServer_29", "sol_sql": ["\n        SELECT\n            c.CustomerID, \n            JSON_QUERY((   \n                SELECT '[' + STRING_AGG('\"' + STRING_ESCAPE(CAST(t.TransactionID AS NVARCHAR(100)), 'json') + '\"', ',') + ']' \n                FROM transactions_1k t\n                WHERE t.CustomerID = c.CustomerID\n            )) AS [Loans]\n        FROM customers c\n        INNER JOIN transactions_1k t ON c.CustomerID = t.CustomerID\n        WHERE c.Segment = 'SME'\n        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_30", "sol_sql": ["\n        with cte as\n        (\n            select t\n            from\n            (\n                select start_date as t\n                from account_activity\n                union all\n                select end_date\n                from account_activity\n\n                union all\n\n                select dateadd(day,-1,start_date) \n                from blackout_periods\n                union all\n                select  dateadd(day,1,end_date) \n                from blackout_periods\n            )a\n        ),\n        \n        cte2 as (select t as s, coalesce(LEAD(t,1) OVER ( ORDER BY t ),t) as e from cte a)\n        select s, e\n        from cte2 a \n        where not exists(select 1 from blackout_periods b where s between dateadd(day,-1,start_date) and dateadd(day,1,end_date) and e between dateadd(day,-1,start_date) and dateadd(day,1,end_date) )\n        and exists(select 1 from account_activity b where s between start_date and end_date and e between start_date and end_date)\n        and s <> e\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_31", "sol_sql": ["\n        SELECT e.event_id,\n        CASE WHEN b.link_to_event IS NOT NULL THEN 1 ELSE 0 END AS from_budget, \n        CASE WHEN a.link_to_event IS NOT NULL THEN 1 ELSE 0 END AS from_attendance\n        FROM event e LEFT JOIN budget b ON e.event_id = b.link_to_event LEFT JOIN attendance a ON e.event_id = a.link_to_event\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_32", "sol_sql": ["\n        SELECT r.name, \n        ISNULL(STUFF((SELECT ', ' + c.name FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.raceId = r.raceId FOR XML PATH ('')), 1, 2, ''), '') AS Constructors \n        FROM races r\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_33", "sol_sql": ["\n        SELECT distinct cl.client_id, cl.gender,\n        CASE WHEN cl.birth_date BETWEEN '1948-01-01' AND '1960-12-31' THEN 'Yes' ELSE 'No' END as age_old, \n        (SELECT MAX(account_id) FROM disp WHERE client_id = cl.client_id AND d2.type = 'OWNER') as last_acount\n        FROM client cl LEFT OUTER JOIN disp d2 ON d2.client_id = cl.client_id\n        GROUP BY cl.client_id, cl.gender, cl.birth_date, d2.type\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_34", "sol_sql": ["\n        WITH\n        CTE_RN\n        AS\n        (\n            SELECT\n                e.exp_id\n                ,e.mid\n                ,e.qty\n                ,i.qty AS LimitQty\n                ,ROW_NUMBER() OVER (ORDER BY e.exp_id) AS rn\n            FROM\n                Experiment AS e\n                INNER JOIN Inventory AS i ON e.mid = i.mid\n            WHERE e.mid = 2 \n        )\n        ,CTE_Recursive\n        AS\n        (\n            SELECT\n                CTE_RN.exp_id\n                ,CTE_RN.mid\n                ,CTE_RN.qty\n                ,CTE_RN.LimitQty\n                ,CTE_RN.rn\n                ,CASE WHEN CTE_RN.qty > CTE_RN.LimitQty\n                THEN 0\n                ELSE CTE_RN.qty\n                END AS SumQty\n                ,CASE WHEN CTE_RN.qty > CTE_RN.LimitQty\n                THEN 0\n                ELSE 1\n                END AS Executable\n            FROM\n                CTE_RN\n            WHERE\n                CTE_RN.rn = 1\n\n            UNION ALL\n\n            SELECT\n                CTE_RN.exp_id\n                ,CTE_RN.mid\n                ,CTE_RN.qty\n                ,CTE_RN.LimitQty\n                ,CTE_RN.rn\n                ,CASE WHEN CTE_RN.qty + CTE_Recursive.SumQty > CTE_RN.LimitQty\n                THEN CTE_Recursive.SumQty \n                ELSE CTE_RN.qty + CTE_Recursive.SumQty\n                END AS SumQty\n                ,CASE WHEN CTE_RN.qty + CTE_Recursive.SumQty > CTE_RN.LimitQty\n                THEN 0\n                ELSE 1\n                END AS Executable\n            FROM\n                CTE_RN\n                INNER JOIN CTE_Recursive ON CTE_Recursive.rn + 1 = CTE_RN.rn\n        )\n        SELECT exp_id, mid, Executable FROM CTE_Recursive\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_35", "sol_sql": ["\n        SELECT event.event_id, event.event_name, a.tmp_col as [attendances], b.tmp_col as [budget_category]\n        FROM event\n        LEFT JOIN (SELECT link_to_event, STRING_AGG(link_to_member, ';') AS tmp_col\n                FROM attendance\n                GROUP BY link_to_event) a ON event.event_id = a.link_to_event\n        LEFT JOIN (SELECT link_to_event, STRING_AGG(category, ';') AS tmp_col\n                FROM budget\n                GROUP BY link_to_event) b ON event.event_id = b.link_to_event\n        WHERE event.event_id = 'reczhS8wix6Kzbp9P'\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_36", "sol_sql": ["\n        ALTER FUNCTION [dbo].[fnGetTeamAverageHeight] (@team_api_id INT)\n        RETURNS FLOAT\n        AS\n        BEGIN\n            DECLARE @averageHeight FLOAT;\n\n            SELECT @averageHeight = AVG(height)\n            FROM Player\n            WHERE player_api_id IN\n                (\n                    SELECT player_api_id\n                    FROM Player_Attributes\n                    WHERE player_api_id IN\n                        (\n                            SELECT player_api_id\n                            FROM Team_Attributes\n                            WHERE team_api_id = @team_api_id\n                        )\n                );\n\n            RETURN @averageHeight;\n        END;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    sql = [\"SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = 'FUNCTION' AND ROUTINE_SCHEMA = 'dbo' AND ROUTINE_NAME = 'fnGetTeamAverageHeight';\"]\n    res, _, _ = execute_queries(sql, db_name, conn)\n    assert len(res) == 1 and res[0][0] != None\n    "]}
{"instance_id": "SQLServer_37", "sol_sql": ["\n        SELECT j1.[key]\n            , j2.*\n            , JSON_VALUE(j1.[value], '$.nvarchar_column') AS [another example]\n        FROM OPENJSON('[\n            {\"id_column\": 1234, \"decimal_column\": 12.34, \"nvarchar_column\": \"asdf\"},\n            {\"id_column\": 5678, \"decimal_column\": 56.78, \"nvarchar_column\": \"fdsa\"}\n        ]') AS j1\n        CROSS APPLY OPENJSON (j1.[value]) WITH (\n            id_column BIGINT,\n            decimal_column DEC(28, 8),\n            nvarchar_column NVARCHAR(30)\n        ) AS j2\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_38", "sol_sql": ["\n        select\n            CustomerID,\n            Date,\n            max(case when ProductID = 2 then Amount end),\n            max(case when ProductID = 5 then Amount end),\n            max(case when ProductID = 9 then Amount end)\n        from transactions_1k\n        group by CustomerID, Date\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_39", "sol_sql": ["\n        select r.name,\n            json_value(x.obj, '$[0]') name1,\n            json_value(x.obj, '$[1]') name2,\n            json_value(x.obj, '$[2]') name2,\n            json_value(x.obj, '$[3]') name4\n        from races r\n        cross apply (values('[\"' + replace(r.name, ' ', '\", \"') + '\"]')) x(obj)\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_40", "sol_sql": ["\n        WITH distinctCombos AS (\n            SELECT DISTINCT\n                r.Laboratory_ID, r.Patient_ID\n            FROM Record as r\n        ) , patientComboCount AS (\n            SELECT\n                l.ID\n                , STUFF((\n                    SELECT\n                        ',' + CAST(dc.Patient_ID as nvarchar)\n                    FROM distinctCombos as dc\n                    WHERE dc.Laboratory_ID = l.ID\n                    ORDER BY dc.Patient_ID ASC\n                    FOR XML PATH('')\n                ),1,1,'') as patientList\n            FROM Laboratory as l\n        )\n        SELECT\n            COUNT(DISTINCT patientList) as UniqueGroups\n        FROM patientComboCount as mcc\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_41", "sol_sql": ["\n        DECLARE @StartDate datetime\n        DECLARE @EndDate datetime\n\n        SET @StartDate = '2010-02-22 00:00:00'\n        SET @EndDate = '2010-02-22 23:59:59'\n\n        SELECT *\n        FROM Team_Attributes\n        WHERE date BETWEEN dateadd(day,-1,@StartDate) AND @EndDate\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_42", "sol_sql": ["\n        DROP TABLE IF EXISTS EventCategories;\n        \n        CREATE TABLE [dbo].[EventCategories](\n            [ID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,\n            [IsBusinessCategory] [bit] NULL\n        );\n        ", "\n        DROP TABLE IF EXISTS BusinessCategories;\n        CREATE TABLE [dbo].[BusinessCategories](\n        [ID] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY,\n        [BusinessCategoryID] [INT] NOT NULL REFERENCES EventCategories(ID));\n        ", "\n        DROP FUNCTION IF EXISTS [dbo].[fn_isBusinessCategory];\n        DROP FUNCTION IF EXISTS [dbo].[fn_isBusinessCategoryValid];\n        ", "\n        CREATE FUNCTION [dbo].[fn_isBusinessCategory] (@CatID INT) RETURNS INT\n        AS\n        BEGIN\n            RETURN (SELECT isBusinessCategory FROM EventCategories WHERE ID = @CatID)\n        END;\n        ", "\n        CREATE FUNCTION [dbo].[fn_isBusinessCategoryValid]\n        (\n            @CatID INT,\n            @isBusinessCat BIT\n        )\n        RETURNS BIT\n        AS\n        BEGIN\n            IF @isBusinessCat = 1\n            BEGIN\n                RETURN 1;\n            END;\n\n            IF EXISTS (SELECT 1 FROM BusinessCategories WHERE ID = @CatID)\n            BEGIN\n                RETURN 0;\n            END;\n            RETURN 1;\n        END;\n        ", "\n        ALTER TABLE BusinessCategories ADD CONSTRAINT FK_BusinessCategory \n        FOREIGN KEY (BusinessCategoryID) \n        REFERENCES EventCategories (ID);\n        ", "\n        ALTER TABLE BusinessCategories ADD CONSTRAINT ck_BusinessCategory \n        CHECK ([dbo].[fn_isBusinessCategory](BusinessCategoryID) = 1);\n        ", "\n        ALTER TABLE EventCategories ADD CONSTRAINT ck_Category_isBusinessCategory \n        CHECK ([dbo].[fn_isBusinessCategoryValid](ID, isBusinessCategory) = 1);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    sql1 = [\"INSERT INTO dbo.EventCategories (IsBusinessCategory) VALUES (1); DECLARE @ecID INT = SCOPE_IDENTITY(); INSERT INTO dbo.BusinessCategories (BusinessCategoryID) VALUES (@ecID);\"]\n    res, error, _ = execute_queries(sql1, db_name, conn)\n    assert error == False\n    \n    sql2 = [\"INSERT INTO dbo.EventCategories (IsBusinessCategory) VALUES (0); DECLARE @ecID2 INT = SCOPE_IDENTITY(); INSERT INTO dbo.BusinessCategories (BusinessCategoryID) VALUES (@ecID2);\"]\n    res, error, _ = execute_queries(sql2, db_name, conn)\n    assert error == True\n    "]}
{"instance_id": "SQLServer_43", "sol_sql": ["\n        with\n        vt\n        as\n        (\n            select vt.*, row_number() over (partition by CustomerID order by StartDate) as seqnum\n            from transactions_1k vt\n        )\n        ,cte\n        as\n        (\n            select\n                vt.TransactionID\n                ,vt.CustomerID\n                ,vt.StartDate as first_begin_date\n                ,vt.EndDate as first_end_date\n                ,vt.StartDate\n                ,vt.EndDate\n                ,seqnum\n            from vt\n            where seqnum = 1\n\n            union all\n\n            select\n                vt.TransactionID\n                ,vt.CustomerID\n                ,case when vt.StartDate <= dateadd(day, 90, cte.first_end_date)\n                    then cte.first_begin_date \n                    else vt.StartDate\n                end as first_begin_date\n                ,case when vt.StartDate <= dateadd(day, 90, cte.first_end_date)\n                    then cte.first_end_date\n                    else vt.EndDate\n                end as first_end_date\n                ,vt.StartDate\n                ,vt.EndDate\n                ,vt.seqnum\n            from\n                cte\n                inner join vt\n                    on  vt.seqnum = cte.seqnum + 1\n                    and vt.CustomerID = cte.CustomerID\n        )\n        select\n            cte.TransactionID\n            ,cte.CustomerID\n            ,cte.StartDate\n            ,cte.EndDate\n            ,case when first_begin_date = StartDate\n                then 0 else 1\n            end as flag\n        from cte\n        order by cte.CustomerID, cte.StartDate;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_44", "sol_sql": ["\n        SELECT * FROM budget WHERE category >= 'Food' AND category <= 'Speaker Gifts' AND link_to_event = 'recggMW2eyCYceNcy' ORDER BY category\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_45", "sol_sql": ["\n        DROP TABLE IF EXISTS #destinationTable;\n        CREATE TABLE #destinationTable (testRow NVARCHAR(MAX));\n\n        WITH r AS (\n            SELECT TOP 2 ID, Date, ROW_NUMBER() OVER (ORDER BY ID, Date) AS RowNum\n            FROM Laboratory\n        )\n        INSERT #destinationTable (testRow)\n        SELECT (SELECT ID, Date FROM r WHERE RowNum = r2.RowNum FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER)\n        FROM r r2;\n        ", "\n        SELECT testRow FROM #destinationTable;\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_46", "sol_sql": ["\n        SELECT MAX(payments)\n        FROM\n        (\n        SELECT payments, DENSE_RANK() OVER(ORDER BY payments DESC) AS Rank\n        FROM loan\n        ) E\n        WHERE (Rank = 2);\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_47", "sol_sql": ["\n        SELECT loan_id, \n        (SELECT user_id_version_2 from user_id_mapping where user_id_version_1=loan.source_account_id) AS source_account_id,\n        (SELECT user_id_version_2 from user_id_mapping where user_id_version_1=loan.target_account_id) AS target_account_id\n        FROM   loan\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_48", "sol_sql": ["\n    ;WITH CTE AS (\n        SELECT loan_id, date, status,\n                ROW_NUMBER() OVER (PARTITION BY loan_id ORDER BY date) - \n                ROW_NUMBER() OVER (PARTITION BY loan_id, status ORDER BY date) AS grp\n        FROM loan\n        ), CTE2 AS (\n        SELECT loan_id, status, grp, \n                ROW_NUMBER() OVER (ORDER BY MIN(date)) AS rn\n        FROM CTE\n        WHERE status = 1\n        GROUP BY loan_id, status, grp \n        )\n        SELECT c.loan_id, c.date, c.status, rn       \n        FROM CTE c\n        LEFT JOIN CTE2 c2 \n        ON c.loan_id = c2.loan_id AND c.status = c2.status AND c.grp = c2.grp\n        ORDER BY date\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_49", "sol_sql": ["\n        SELECT CASE WHEN s.id = 1 THEN 1 WHEN s.id = 2 THEN 2 WHEN s.id = 3 THEN 3 END AS fixed_id, s.superhero_name, p.publisher_name FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.id IN (1, 2, 3)\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_50", "sol_sql": ["\n        WITH cte AS (\n        SELECT clamped_time\n            , trans_id\n            , amount\n            , balance\n            , rn1 = ROW_NUMBER() OVER (PARTITION BY clamped_time ORDER BY [date])\n\n        FROM trans\n        CROSS APPLY (\n            SELECT DATEADD(MINUTE, DATEDIFF(MINUTE, 0, [date]) / 5 * 5, 0)\n        ) AS x(clamped_time)\n        )\n        SELECT clamped_time\n            , MIN(CASE WHEN rn1 = 1 THEN [amount] END) AS [amount]\n            , MIN([balance]) AS [balance]\n        FROM cte\n        GROUP BY clamped_time\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_51", "sol_sql": ["\n        declare @text varchar(200)='1.25,5.34,6.9'\n        declare @json varchar(202)='[' + @text + ']'\n\n        declare @var1 numeric(18,5)= JSON_VALUE(@json,'$[0]')\n        declare @var2 numeric(18,5)= JSON_VALUE(@json,'$[1]')\n        declare @var3 numeric(18,5)= JSON_VALUE(@json,'$[2]')\n        select @var1,@var2,@var3\n        "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "SQLServer_52", "sol_sql": ["\nWITH CTE AS\n(\n    SELECT \n        pa.id,\n        [xml_val] = CAST('<t>' + REPLACE(pa.player_api_id, ',', '</t><t>') + '</t>' AS XML)\n    FROM Player_Attributes pa\n)\nSELECT TOP 10\n    CTE.id,\n    p.player_name,\n    [player_api_id] = col.value('.', 'VARCHAR(100)')\nFROM CTE\nCROSS APPLY [xml_val].nodes('/t') CA(col)\nINNER JOIN Player p\n    ON CA.col.value('.', 'VARCHAR(100)') = p.player_api_id;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "SQLServer_53", "sol_sql": ["\nSELECT raceId\nFROM races\nWHERE EXISTS\n(\n    SELECT 1\n    FROM circuits\n    WHERE circuits.circuitId = races.circuitId\n      AND circuits.country LIKE 'M%'\n)\nAND NOT EXISTS\n(\n    SELECT 1\n    FROM circuits\n    WHERE circuits.circuitId = races.circuitId\n      AND circuits.name LIKE '%International%'\n);\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "SQLServer_54", "sol_sql": ["\nWITH PrintsSummary AS\n(\n    SELECT \n        name, \n        COUNT(printings) AS Prints\n    FROM cards\n    GROUP BY name\n),\nTopPrints AS\n(\n    SELECT TOP 3 \n        name, \n        Prints\n    FROM PrintsSummary\n    ORDER BY Prints DESC\n),\nOthers AS\n(\n    SELECT \n        'Others' AS name,\n        SUM(Prints) AS Prints\n    FROM PrintsSummary\n    WHERE name NOT IN (SELECT name FROM TopPrints)\n)\nSELECT name, Prints \nFROM TopPrints\nUNION ALL\nSELECT name, Prints\nFROM Others;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "SQLServer_55", "sol_sql": ["\nWITH AtomSequence AS (SELECT a.atom_id, a.molecule_id, a.element, ROW_NUMBER() OVER \n(PARTITION BY a.molecule_id ORDER BY a.atom_id) AS seq_num FROM atom a \nWHERE a.molecule_id = 'TR000'), BondSequence \nAS (SELECT b.bond_id, b.molecule_id, b.bond_type, ROW_NUMBER() \nOVER (PARTITION BY b.molecule_id ORDER BY b.bond_id) \nAS seq_num FROM bond b WHERE b.molecule_id = 'TR000') \nSELECT a.atom_id, a.element, b.bond_id, b.bond_type FROM AtomSequence a LEFT JOIN BondSequence b \nON a.molecule_id = b.molecule_id AND a.seq_num = b.seq_num ORDER BY a.seq_num;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n"]}
{"instance_id": "SQLServer_56", "sol_sql": ["WITH hero_activity AS (\n    SELECT \n        id,\n        activity_date,\n        activity_value,\n        hero_id,\n        DATEFROMPARTS(YEAR(activity_date), MONTH(activity_date), 1) as month_start\n    FROM (\n        VALUES \n            (1, '2023-01-01', 10, 1),\n            (2, '2023-01-02', 20, 1),\n            (3, '2023-02-01', 15, 1),\n            (4, '2023-02-02', 25, 1),\n            (5, '2023-01-03', 30, 2),\n            (6, '2023-02-03', 40, 2)\n    ) AS t (id, activity_date, activity_value, hero_id)\n),\nmonthly_totals AS (\n    SELECT \n        month_start,\n        SUM(activity_value) as month_total\n    FROM hero_activity\n    GROUP BY month_start\n),\nactivity_totals AS (\n    SELECT\n        ha.id,\n        ha.activity_date,\n        ha.activity_value,\n        ha.hero_id,\n        SUM(ha.activity_value) OVER (\n            ORDER BY ha.activity_date\n        ) AS run_tot,\n        SUM(ha.activity_value) OVER (\n            PARTITION BY YEAR(ha.activity_date), MONTH(ha.activity_date)\n            ORDER BY ha.activity_date\n        ) AS m_run_tot,\n        LAG(mt.month_total, 1, 0) OVER (\n            ORDER BY ha.month_start\n        ) AS prev_month_total\n    FROM hero_activity ha\n    LEFT JOIN monthly_totals mt ON ha.month_start = mt.month_start\n)\nSELECT\n    id,\n    activity_date,\n    activity_value,\n    run_tot,\n    m_run_tot,\n    prev_month_total AS required_output\nFROM activity_totals\nORDER BY activity_date;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_57", "sol_sql": ["SELECT\n    r.raceid,\n    r.name AS racename,\n    c.name AS circuitname,\n    d.forename AS driverforename,\n    d.surname AS driversurname,\n    co.name AS constructorname,\n    res.position AS finishposition,\n    res.points\nFROM races AS r\nINNER JOIN circuits AS c ON r.circuitid = c.circuitid\nINNER JOIN results AS res ON r.raceid = res.raceid\nINNER JOIN drivers AS d ON res.driverid = d.driverid\nINNER JOIN constructors AS co ON res.constructorid = co.constructorid\nORDER BY\n    r.raceid,\n    res.position;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_58", "sol_sql": ["SELECT\n    a1.atom_id AS atom_id1,\n    a2.atom_id AS atom_id2,\n    b.bond_id,\n    b.bond_type\nFROM atom AS a1\nCROSS JOIN atom AS a2\nLEFT JOIN connected AS c\n    ON\n        a1.atom_id = c.atom_id\n        AND a2.atom_id = c.atom_id2\nLEFT JOIN bond AS b ON c.bond_id = b.bond_id\nWHERE a1.molecule_id = a2.molecule_id\nORDER BY\n    a1.atom_id,\n    a2.atom_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_59", "sol_sql": ["WITH LastNonNullGOT AS (\n    SELECT \n        ID,\n        DATE,\n        GOT,\n        ROW_NUMBER() OVER (\n            PARTITION BY ID, \n            (SELECT MAX(sub.DATE) \n             FROM LABORATORY sub \n             WHERE sub.ID = l.ID \n             AND sub.DATE <= l.DATE \n             AND sub.GOT IS NOT NULL)\n            ORDER BY DATE DESC\n        ) as rn\n    FROM LABORATORY l\n)\nSELECT \n    ID,\n    DATE,\n    GOT,\n    FIRST_VALUE(GOT) OVER (\n        PARTITION BY ID \n        ORDER BY CASE WHEN GOT IS NULL THEN 1 ELSE 0 END, \n        DATE DESC\n        ROWS UNBOUNDED PRECEDING\n    ) AS NEW_GOT\nFROM LastNonNullGOT\nWHERE rn = 1\nORDER BY ID, DATE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_60", "sol_sql": ["WITH CTE AS (\n    SELECT\n        P.ID AS PATIENTID,\n        P.SEX,\n        P.BIRTHDAY,\n        E.[Examination Date],\n        E.DIAGNOSIS,\n        E.THROMBOSIS\n    FROM PATIENT AS P\n    LEFT JOIN EXAMINATION AS E ON P.ID = E.ID\n)\n\nSELECT\n    PATIENTID,\n    SEX,\n    BIRTHDAY,\n    COUNT([Examination Date]) AS EXAMINATIONCOUNT,\n    SUM(CASE\n        WHEN THROMBOSIS = 1 THEN 1\n        ELSE 0\n    END) AS THROMBOSISCOUNT,\n    SUM(CASE\n        WHEN THROMBOSIS = 0 THEN 1\n        ELSE 0\n    END) AS NOTHROMBOSISCOUNT\nFROM CTE\nGROUP BY\n    PATIENTID,\n    SEX,\n    BIRTHDAY\nORDER BY PATIENTID;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_61", "sol_sql": ["with data as (\n    select\n        county,\n        cdscode,\n        row_number() over (\n            partition by county\n            order by cdscode asc\n        ) as rnk\n    from schools\n)\n\nselect\n    a.cdscode as cdscode1,\n    a.county as county1,\n    b.cdscode as cdscode2,\n    b.county as county2\nfrom data as a\ninner join data as b\n    on\n        a.county = b.county\n        and b.rnk = a.rnk + 1\nwhere a.rnk % 2 = 1;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_62", "sol_sql": ["SELECT\n    a1.molecule_id,\n    a1.atom_id AS atom1_id,\n    a1.element AS atom1_element,\n    a2.atom_id AS atom2_id,\n    a2.element AS atom2_element,\n    b.bond_id,\n    b.bond_type\nFROM atom AS a1\nINNER JOIN connected AS c ON a1.atom_id = c.atom_id\nINNER JOIN atom AS a2 ON c.atom_id2 = a2.atom_id\nINNER JOIN bond AS b ON c.bond_id = b.bond_id\nORDER BY\n    a1.molecule_id,\n    a1.atom_id,\n    a2.atom_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_63", "sol_sql": ["SELECT\n    m.molecule_id,\n    m.label AS molecule_label,\n    a.atom_id,\n    a.element AS atom_element,\n    b.bond_id,\n    b.bond_type\nFROM molecule AS m\nINNER JOIN atom AS a ON m.molecule_id = a.molecule_id\nINNER JOIN connected AS c ON a.atom_id = c.atom_id\nINNER JOIN bond AS b ON c.bond_id = b.bond_id\nORDER BY\n    m.molecule_id,\n    a.atom_id,\n    b.bond_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_64", "sol_sql": ["SELECT *\nFROM molecule\nWHERE\n    molecule_id <> 'TR000'\n    AND molecule_id <> 'TR001'\n    AND molecule_id <> 'TR002';\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_65", "sol_sql": ["SELECT\n    FORMAT([date], 'yyyy-MM') AS month,\n    COUNT(DISTINCT [date]) AS distinct_days\nFROM rulings\nGROUP BY FORMAT([date], 'yyyy-MM')\nORDER BY month;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_66", "sol_sql": ["SELECT\n    superhero_name,\n    gender\nFROM superhero\nINNER JOIN gender ON superhero.gender_id = gender.id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "SQLServer_67", "sol_sql": ["DECLARE @SearchDiagnosis NVARCHAR(100) = 'SLE';\nSELECT \n    P.ID,\n    S.VALUE\nFROM PATIENT P\nCROSS APPLY STRING_SPLIT(P.DIAGNOSIS, ',') S\nWHERE TRIM(S.VALUE) = @SearchDiagnosis;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    '''\n    Args:\n        pred_sqls (list): List of SQL queries generated by LLMs\n        sol_sqls (list): List of correct SQL queries (reference solution)\n        db_name (str): Name of the database to execute queries on\n        conn (object): Microsoft SQL Server connection object\n    Returns:\n        No returns, uses assertions to validate correctness\n    '''\n    # Remove DISTINCT keywords from both predicted and solution SQLs\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    \n    # Check if the predicted SQLs use the required SQL functions or keywords\n    required_keywords = [\"CROSS APPLY\", \"STRING_SPLIT\"]\n    result = check_sql_function_usage(pred_sqls, required_keywords)\n    assert result == 1, f\"Predicted SQLs do not contain all required keywords: {required_keywords}\"\n    \n    # Execute both SQL lists and compare results\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1, indicating the predicted SQLs do not produce the same results as the solution SQLs.\"\n    \n    # Check for SQL injection vulnerabilities by looking for suspicious patterns\n    for sql in pred_sqls:\n        assert \"; DROP TABLE\" not in sql.upper(), \"Predicted SQL contains a potential SQL injection vulnerability.\"\n    \n    return result"]}
{"instance_id": "SQLServer_68", "sol_sql": ["CREATE SEQUENCE height_sequence START WITH 1 INCREMENT BY 1;\nCREATE SEQUENCE weight_sequence START WITH 1 INCREMENT BY 1;\nALTER TABLE superhero ADD height_cm INT NOT NULL DEFAULT NEXT VALUE FOR height_sequence;\nALTER TABLE superhero ADD weight_kg INT NOT NULL DEFAULT NEXT VALUE FOR weight_sequence;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    # First, execute the solution SQL to ensure the sequences and columns are added correctly\n    execute_queries(sol_sqls, db_name, conn)\n    \n    # Now, execute the predicted SQL\n    execute_queries(pred_sqls, db_name, conn)\n    \n    # Check if the columns were added correctly by the solution SQL\n    sql_check_columns = [\"SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'superhero' AND COLUMN_NAME IN ('height_cm', 'weight_kg');\"]\n    res_sol, _, _ = execute_queries(sql_check_columns, db_name, conn)\n    \n    # The solution SQL should have added the columns, so there should be 2 results\n    assert len(res_sol) == 2, \"The solution SQL did not correctly add the columns to the superhero table.\"\n    \n    # Check if the columns have default constraints (using sequences)\n    sql_check_defaults = [\"SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS c JOIN sys.default_constraints d ON c.COLUMN_DEFAULT = d.definition WHERE c.TABLE_NAME = 'superhero' AND c.COLUMN_NAME IN ('height_cm', 'weight_kg');\"]\n    res_default, _, _ = execute_queries(sql_check_defaults, db_name, conn)\n    \n    # The solution should have added default constraints\n    assert len(res_default) > 0, \"The solution SQL did not correctly add default constraints for the columns.\"\n    \n    # Check if the sequences were created\n    sql_check_sequences = [\"SELECT name FROM sys.sequences WHERE name IN ('height_sequence', 'weight_sequence');\"]\n    res_seq, _, _ = execute_queries(sql_check_sequences, db_name, conn)\n    \n    # The solution should have created the sequences\n    assert len(res_seq) == 2, \"The solution SQL did not correctly create the required sequences.\"\n    \n    # Finally, ensure that the predicted SQL does not incorrectly use multiple IDENTITY columns\n    assert check_sql_function_usage(pred_sqls, ['IDENTITY']) == 0 or check_sql_function_usage(pred_sqls, ['SEQUENCE']) > 0, \"The predicted SQL either incorrectly uses multiple IDENTITY columns or doesn't use sequences as an alternative.\"\n    "]}
{"instance_id": "SQLServer_69", "sol_sql": ["SELECT\n    p.*,\n    e.[Examination Date],\n    e.[aCL IgG],\n    e.[aCL IgM],\n    e.ana,\n    e.[ANA Pattern],\n    e.[aCL IgA],\n    e.diagnosis,\n    e.kct,\n    e.rvvt,\n    e.lac,\n    e.symptoms,\n    e.thrombosis\nFROM patient AS p\nLEFT JOIN examination AS e ON p.id = e.id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_70", "sol_sql": ["WITH cte AS (\n    SELECT\n        id,\n        date,\n        got,\n        gpt,\n        ldh,\n        alp,\n        tp,\n        alb,\n        ua,\n        un,\n        cre,\n        [T-BIL],\n        [T-CHO],\n        tg,\n        cpk,\n        glu,\n        wbc,\n        rbc,\n        hgb,\n        hct,\n        plt,\n        pt,\n        aptt,\n        fg,\n        [U-PRO],\n        igg,\n        iga,\n        igm,\n        crp,\n        ra,\n        rf,\n        c3,\n        c4,\n        rnp,\n        sm,\n        sc170,\n        ssa,\n        ssb,\n        centromea,\n        dna,\n        [DNA-II],\n        ROW_NUMBER() OVER (\n            PARTITION BY id\n            ORDER BY date DESC\n        ) AS rn\n    FROM laboratory\n)\n\nSELECT\n    id,\n    date,\n    got,\n    gpt,\n    ldh,\n    alp,\n    tp,\n    alb,\n    ua,\n    un,\n    cre,\n    [T-BIL],\n    [T-CHO],\n    tg,\n    cpk,\n    glu,\n    wbc,\n    rbc,\n    hgb,\n    hct,\n    plt,\n    pt,\n    aptt,\n    fg,\n    [U-PRO],\n    igg,\n    iga,\n    igm,\n    crp,\n    ra,\n    rf,\n    c3,\n    c4,\n    rnp,\n    sm,\n    sc170,\n    ssa,\n    ssb,\n    centromea,\n    dna,\n    [DNA-II]\nFROM cte\nWHERE rn = 1;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_71", "sol_sql": ["WITH cte AS (\n    SELECT\n        id,\n        date,\n        got,\n        gpt,\n        ldh,\n        alp,\n        tp,\n        alb,\n        ua,\n        un,\n        cre,\n        [T-BIL],\n        [T-CHO],\n        tg,\n        cpk,\n        glu,\n        wbc,\n        rbc,\n        hgb,\n        hct,\n        plt,\n        pt,\n        aptt,\n        fg,\n        [U-PRO],\n        igg,\n        iga,\n        igm,\n        crp,\n        ra,\n        rf,\n        c3,\n        c4,\n        rnp,\n        sm,\n        sc170,\n        ssa,\n        ssb,\n        centromea,\n        dna,\n        [DNA-II],\n        ROW_NUMBER() OVER (\n            PARTITION BY id\n            ORDER BY date DESC\n        ) AS rn\n    FROM laboratory\n)\n\nSELECT\n    id,\n    date,\n    got,\n    gpt,\n    ldh,\n    alp,\n    tp,\n    alb,\n    ua,\n    un,\n    cre,\n    [T-BIL],\n    [T-CHO],\n    tg,\n    cpk,\n    glu,\n    wbc,\n    rbc,\n    hgb,\n    hct,\n    plt,\n    pt,\n    aptt,\n    fg,\n    [U-PRO],\n    igg,\n    iga,\n    igm,\n    crp,\n    ra,\n    rf,\n    c3,\n    c4,\n    rnp,\n    sm,\n    sc170,\n    ssa,\n    ssb,\n    centromea,\n    dna,\n    [DNA-II]\nFROM cte\nWHERE rn = 1;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_72", "sol_sql": ["DECLARE @SQL nvarchar(MAX),\n             @CRLF nchar(2) = NCHAR(13) + NCHAR(10),\n                   @MaxTally int;\n\n\nSELECT @MaxTally = MAX(C)\nFROM\n  (SELECT COUNT(*) AS C\n   FROM results\n   GROUP BY driverId) R;\n\nWITH N AS\n  (SELECT N\n   FROM (\n         VALUES(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL))N(N)),\n     Tally AS\n  (SELECT TOP (@MaxTally) ROW_NUMBER() OVER (\n                                             ORDER BY\n                                               (SELECT NULL)) AS I\n   FROM N N1,\n        N N2)\nSELECT @SQL = N'SELECT driverId,' + @CRLF + STUFF(\n                                                    (SELECT N',' + @CRLF + CONCAT(N'       MAX(CASE WHEN RN = ', T.I, N' THEN points END) AS Race', T.I, '_Points')\n                                                     FROM Tally T\n                                                     ORDER BY T.I ASC\n                                                     FOR XML PATH(N''), TYPE).value('(./text())[1]', 'nvarchar(MAX)'), 1, 3, N'') + @CRLF + N'FROM (SELECT raceId,' + @CRLF + N'           driverId,' + @CRLF + N'           points,' + @CRLF + N'           ROW_NUMBER() OVER (PARTITION BY driverId ORDER BY raceId) AS RN' + @CRLF + N'    FROM results) AS RNs' + @CRLF + N'GROUP BY driverId;';\n\nPRINT @SQL;\n\nEXEC sys.sp_executesql @SQL;", "WITH RNS AS (\n    SELECT\n        RACEID,\n        DRIVERID,\n        POINTS,\n        ROW_NUMBER() OVER (\n            PARTITION BY DRIVERID\n            ORDER BY RACEID\n        ) AS RN\n    FROM RESULTS\n)\n\nSELECT\n    DRIVERID,\n    MAX(CASE\n        WHEN RN = 1 THEN POINTS\n    END) AS RACE1_POINTS,\n    MAX(CASE\n        WHEN RN = 2 THEN POINTS\n    END) AS RACE2_POINTS,\n    MAX(CASE\n        WHEN RN = 3 THEN POINTS\n    END) AS RACE3_POINTS,\n    MAX(CASE\n        WHEN RN = 4 THEN POINTS\n    END) AS RACE4_POINTS,\n    MAX(CASE\n        WHEN RN = 5 THEN POINTS\n    END) AS RACE5_POINTS\nFROM RNS\nGROUP BY DRIVERID;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_73", "sol_sql": ["SELECT\n    RACEID,\n    MAX(CASE\n        WHEN POSITIONTEXT = '1' THEN DRIVERID\n    END) AS POSITION1,\n    MAX(CASE\n        WHEN POSITIONTEXT = '2' THEN DRIVERID\n    END) AS POSITION2,\n    MAX(CASE\n        WHEN POSITIONTEXT = '3' THEN DRIVERID\n    END) AS POSITION3\nFROM RESULTS\nGROUP BY RACEID;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_74", "sol_sql": ["WITH x AS (\n    SELECT\n        driverid,\n        statusid,\n        ROW_NUMBER() OVER (\n            PARTITION BY driverid\n            ORDER BY COUNT(*) DESC\n        ) AS rn\n    FROM results\n    GROUP BY\n        driverid,\n        statusid\n)\n\nSELECT\n    driverid,\n    statusid\nFROM x\nWHERE rn = 1;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    '''\n    Args:\n        pred_sqls (list): List of SQL queries generated by LLMs\n        sol_sqls (list): List of correct SQL queries (reference solution)\n        db_name (str): Name of the database to execute queries on\n        conn (object): Microsoft SQL Server connection object\n    Returns:\n        No returns, uses assertions to validate correctness\n    '''\n    # First, we need to ensure that the predicted SQL does not attempt to insert into the results table\n    # We will check if the predicted SQL contains the INSERT INTO statement\n    assert check_sql_function_usage(pred_sqls, ['INSERT INTO results']) == 0, \"Predicted SQL should not contain INSERT INTO results\"\n\n    # Now, we will execute the predicted SQL and the solution SQL and compare their results\n    # The predicted SQL should return the same results as the solution SQL\n    assert ex_base(pred_sqls, sol_sqls, db_name, conn) == 1, \"Predicted SQL does not produce the same results as the solution SQL\"\n\n    # Additionally, we will check if the predicted SQL uses the required SQL functions and keywords\n    required_keywords = ['WITH', 'ROW_NUMBER()', 'PARTITION BY', 'ORDER BY', 'COUNT(*)', 'DESC', 'SELECT', 'FROM', 'WHERE']\n    assert check_sql_function_usage(pred_sqls, required_keywords) == 1, \"Predicted SQL does not contain all required keywords or functions\""]}
{"instance_id": "SQLServer_75", "sol_sql": ["\nSELECT \n    CASE \n        WHEN COUNT(DISTINCT code) = 1 \n            THEN MAX(CAST(code AS VARCHAR(50))) \n        ELSE CONCAT(\n            CAST(MIN(code) AS VARCHAR(50)),\n            '-',\n            CAST(MAX(code) AS VARCHAR(50))\n        ) \n    END AS concat_codes\nFROM drivers\nWHERE code IS NOT NULL;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    '''\n    Args:\n        pred_sqls (list): List of SQL queries generated by LLMs\n        sol_sqls (list): List of correct SQL queries (reference solution)\n        db_name (str): Name of the database to execute queries on\n        conn (object): Microsoft SQL Server connection object\n    Returns:\n        No returns, uses assertions to validate correctness\n    '''\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result[0] == sol_sqls_result[0], f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result[0]} and sol_result is {sol_sqls_result[0]}.\"\n    return 1"]}
{"instance_id": "SQLServer_76", "sol_sql": ["\nSELECT \n    driverid,\n    CASE \n        WHEN COUNT(DISTINCT code) > 1 \n             THEN CONCAT(MIN(code), '-', MAX(code))\n             ELSE MIN(code)\n    END AS concat_codes\nFROM drivers\nWHERE code IS NOT NULL\nGROUP BY driverid;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    '''\n    Args:\n        pred_sqls (list): List of SQL queries generated by LLMs\n        sol_sqls (list): List of correct SQL queries (reference solution)\n        db_name (str): Name of the database to execute queries on\n        conn (object): Microsoft SQL Server connection object\n    Returns:\n        No returns, uses assertions to validate correctness\n    '''\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result[0] == sol_sqls_result[0], f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result[0]} and sol_result is {sol_sqls_result[0]}.\"\n    return 1"]}
{"instance_id": "SQLServer_77", "sol_sql": ["\nWITH AvgValues AS (\n    SELECT \n        AVG(BUILDUPPLAYSPEED)   AS AvgBuildupplaySpeed,\n        AVG(DEFENCETEAMWIDTH)   AS AvgDefenceTeamWidth\n    FROM TEAM_ATTRIBUTES\n)\nSELECT\n    TA.ID,\n    TA.BUILDUPPLAYSPEED,\n    TA.BUILDUPPLAYPASSING,\n    TA.CHANCECREATIONPASSING,\n    TA.CHANCECREATIONCROSSING,\n    TA.CHANCECREATIONSHOOTING,\n    TA.DEFENCEPRESSURE,\n    TA.DEFENCEAGGRESSION,\n    TA.DEFENCETEAMWIDTH\nFROM TEAM_ATTRIBUTES AS TA\nCROSS JOIN AvgValues\nWHERE TA.BUILDUPPLAYSPEED > AvgValues.AvgBuildupplaySpeed\n  AND TA.DEFENCETEAMWIDTH < AvgValues.AvgDefenceTeamWidth;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert res == 0\n    return res\n"]}
{"instance_id": "SQLServer_78", "sol_sql": ["\nWITH CTE AS\n(\n    SELECT\n        TA.ID,\n        TA.TEAM_API_ID,\n        TA.DATE,\n        TA.BUILDUPPLAYSPEED,\n        TA.BUILDUPPLAYPASSING,\n        TA.CHANCECREATIONPASSING,\n        TA.CHANCECREATIONCROSSING,\n        TA.CHANCECREATIONSHOOTING,\n        TA.DEFENCEPRESSURE,\n        TA.DEFENCEAGGRESSION,\n        TA.DEFENCETEAMWIDTH,\n        LEAD(TA.BUILDUPPLAYSPEED)  OVER (PARTITION BY TA.TEAM_API_ID ORDER BY TA.DATE) AS NEXT_BUILDUPPLAYSPEED,\n        LEAD(TA.BUILDUPPLAYPASSING) OVER (PARTITION BY TA.TEAM_API_ID ORDER BY TA.DATE) AS NEXT_BUILDUPPLAYPASSING,\n        LAG(TA.DEFENCETEAMWIDTH)  OVER (PARTITION BY TA.TEAM_API_ID ORDER BY TA.DATE) AS PREV_DEFENCETEAMWIDTH,\n        LAG(TA.CHANCECREATIONSHOOTING)  OVER (PARTITION BY TA.TEAM_API_ID ORDER BY TA.DATE) AS PREV_CHANCECREATIONSHOOTING,\n        COUNT(TA.ID) OVER (PARTITION BY TA.TEAM_API_ID) AS TEAM_COUNT\n    FROM TEAM_ATTRIBUTES AS TA\n)\nSELECT\n    ID,\n    TEAM_API_ID,\n    DATE,\n    BUILDUPPLAYSPEED,\n    BUILDUPPLAYPASSING,\n    CHANCECREATIONPASSING,\n    CHANCECREATIONCROSSING,\n    CHANCECREATIONSHOOTING,\n    DEFENCEPRESSURE,\n    DEFENCEAGGRESSION,\n    DEFENCETEAMWIDTH,\n    NEXT_BUILDUPPLAYSPEED,\n    NEXT_BUILDUPPLAYPASSING,\n    PREV_DEFENCETEAMWIDTH,\n    PREV_CHANCECREATIONSHOOTING,\n    TEAM_COUNT\nFROM CTE\nWHERE\n    PREV_DEFENCETEAMWIDTH > BUILDUPPLAYSPEED\n    AND TEAM_COUNT > 1\nORDER BY TEAM_API_ID, DATE;\n"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "SQLServer_79", "sol_sql": ["SELECT\n    p.id,\n    p.sex,\n    p.diagnosis,\n    MIN(l.date) AS earliest_test_date\nFROM patient AS p\nINNER JOIN laboratory AS l ON p.id = l.id\nGROUP BY\n    p.id,\n    p.sex,\n    p.diagnosis;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_80", "sol_sql": ["WITH cte AS (\n    SELECT\n        id,\n        [Examination Date],\n        thrombosis,\n        risklag = LAG(thrombosis, 1, thrombosis) OVER (\n            PARTITION BY id\n            ORDER BY [Examination Date]\n        ),\n        rn = ROW_NUMBER() OVER (\n            PARTITION BY id,\n            YEAR([Examination Date]),\n            MONTH([Examination Date])\n            ORDER BY [Examination Date] DESC\n        )\n    FROM examination\n)\n\nSELECT\n    id,\n    startofmonth = CONVERT(\n        DATE, DATEADD(MONTH, DATEDIFF(MONTH, 0, [Examination Date]), 0)\n    ),\n    increase_risk = CASE\n        WHEN risklag < thrombosis THEN 'Yes'\n        ELSE 'No'\n    END,\n    decrease_risk = CASE\n        WHEN risklag > thrombosis THEN 'Yes'\n        ELSE 'No'\n    END\nFROM cte\nWHERE rn = 1;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_81", "sol_sql": ["WITH x AS (\n    SELECT FLOOR(COALESCE(LEN(label), 0) / 100) AS labellength\n    FROM [molecule]\n)\n\nSELECT\n    labellength * 100 AS labellengthstart,\n    (labellength + 1) * 100 - 1 AS labellengthend,\n    COUNT(*) AS moleculecount\nFROM x\nGROUP BY labellength\nORDER BY labellength;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_82", "sol_sql": ["\nWITH t AS (\n    SELECT\n        e.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY e.id\n            ORDER BY e.[Examination Date]\n        ) AS seqnum\n    FROM examination AS e\n),\ncte AS (\n    SELECT\n        t.id,\n        t.[Examination Date] AS startdate,\n        t.seqnum,\n        'N' AS isrehire,\n        t.[Examination Date] AS anchordate\n    FROM t\n    WHERE t.seqnum = 1\n    \n    UNION ALL\n    \n    SELECT\n        t.id,\n        t.[Examination Date] AS startdate,\n        t.seqnum,\n        CASE\n            WHEN t.[Examination Date] > DATEADD(YEAR, 1, cte.anchordate) \n                 THEN 'Y'\n            ELSE 'N'\n        END AS isrehire,\n        CASE\n            WHEN t.[Examination Date] > DATEADD(YEAR, 1, cte.anchordate)\n                 THEN t.[Examination Date]\n            ELSE cte.anchordate\n        END AS anchordate\n    FROM cte\n    INNER JOIN t\n        ON cte.id = t.id\n       AND t.seqnum = cte.seqnum + 1\n)\nSELECT\n    id,\n    startdate,\n    seqnum,\n    isrehire\nFROM cte\nORDER BY\n    id,\n    startdate;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_83", "sol_sql": ["SELECT\n    sids.value AS molecule_id,\n    m.label\nFROM STRING_SPLIT('TR000,TR001,TR002', ',') AS sids\nINNER JOIN molecule AS m ON sids.value = m.molecule_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_84", "sol_sql": ["SELECT *\nFROM\n    (\n        SELECT\n            id,\n            name,\n            item = ROW_NUMBER() OVER (\n                PARTITION BY id\n                ORDER BY label\n            ),\n            value = CONCAT(label, ' (', tag1, ')'\n            )\n        FROM\n            (SELECT\n                id,\n                name,\n                'Colors' AS label,\n                colors AS tag1\n            FROM cards\n            UNION ALL\n            SELECT\n                id,\n                name,\n                'ManaCost' AS label,\n                manacost AS tag1\n            FROM cards) AS src\n    ) AS src\nPIVOT (\n    MAX(value)\n    FOR item IN ([1], [2])\n) AS pvt\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_85", "sol_sql": ["WITH T_period_futur AS (\n    SELECT\n        1 AS Tpf_period_id,\n        CAST('2021-10-25' AS DATE) AS Tpf_start_period\n    UNION ALL\n    SELECT\n        Tpf_period_id + 1 AS Tpf_period_id,\n        DATEADD(WEEK, 1, Tpf_start_period)\n    FROM T_period_futur\n    WHERE Tpf_period_id < 12\n)\n\nSELECT\n    Tpf_period_id,\n    Tpf_start_period,\n    YEAR(Tpf_start_period) AS Tpf_year,\n    CAST(YEAR(Tpf_start_period) AS VARCHAR)\n    + '.'\n    + RIGHT('00' + CAST(DATEPART(WK, Tpf_start_period) - 1 AS VARCHAR), 2)\n        AS Tpf_period_number,\n    DATEADD(DAY, 6, Tpf_start_period) AS Tpf_end_period\nFROM T_period_futur OPTION (MAXRECURSION 0);\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_86", "sol_sql": ["SELECT\n    p.id AS patientid,\n    p.diagnosis,\n    COALESCE(e.thrombosis, 0) AS thrombosisstatus\nFROM patient AS p\nLEFT JOIN examination AS e ON p.id = e.id\nORDER BY p.id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_87", "sol_sql": ["WITH TEAMATTRS AS (\n    SELECT\n        BUILDUPPLAYSPEED AS VALUE,\n        'Team_Attributes' AS IDENTIFIER,\n        ROW_NUMBER() OVER (\n            ORDER BY BUILDUPPLAYSPEED\n        ) AS RN\n    FROM TEAM_ATTRIBUTES\n)\n\nSELECT\n    PLAYERATTRS.VALUE,\n    PLAYERATTRS.IDENTIFIER,\n    TEAMATTRS.VALUE,\n    TEAMATTRS.IDENTIFIER\nFROM\n    (SELECT\n        OVERALL_RATING AS VALUE,\n        'Player_Attributes' AS IDENTIFIER,\n        ROW_NUMBER() OVER (\n            ORDER BY OVERALL_RATING\n        ) AS RN\n    FROM PLAYER_ATTRIBUTES) AS PLAYERATTRS\nFULL OUTER JOIN\n    TEAMATTRS\n    ON PLAYERATTRS.RN = TEAMATTRS.RN;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_88", "sol_sql": ["WITH data1 AS (\n    SELECT\n        originalreleasedate,\n        (DATEDIFF(DAY, '2007-01-01', originalreleasedate) / 7)\n        + 1 AS start_of_week\n    FROM cards\n    WHERE originalreleasedate >= '2007-01-01'\n)\n\nSELECT\n    DATEADD(WEEK, start_of_week - 1, '2007-01-01') AS start_of_week,\n    COUNT(*) AS card_count\nFROM data1\nGROUP BY start_of_week\nORDER BY start_of_week;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_89", "sol_sql": ["SELECT\n    [date],\n    home_team_api_id AS group_1,\n    away_team_api_id AS group_2,\n    home_team_goal AS daily_profits,\n    SUM(home_team_goal) OVER (\n        PARTITION BY DATEPART(YEAR, [date]),\n        DATEPART(MONTH, [date]),\n        home_team_api_id,\n        away_team_api_id\n        ORDER BY [date] ROWS UNBOUNDED PRECEDING\n    ) AS mtd,\n    SUM(home_team_goal) OVER (\n        PARTITION BY DATEPART(YEAR, [date]),\n        DATEPART(QUARTER, [date]),\n        home_team_api_id,\n        away_team_api_id\n        ORDER BY [date] ROWS UNBOUNDED PRECEDING\n    ) AS qtd,\n    SUM(home_team_goal) OVER (\n        PARTITION BY DATEPART(YEAR, [date]),\n        home_team_api_id,\n        away_team_api_id\n        ORDER BY [date] ROWS UNBOUNDED PRECEDING\n    ) AS ytd,\n    SUM(home_team_goal) OVER (\n        PARTITION BY home_team_api_id,\n        away_team_api_id\n        ORDER BY [date] ROWS UNBOUNDED PRECEDING\n    ) AS ltd\nFROM [Match]\nORDER BY\n    [date],\n    home_team_api_id,\n    away_team_api_id;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_90", "sol_sql": ["SELECT\n    c.name AS card_name,\n    l.format,\n    MIN(CASE\n        WHEN l.status = 'Legal' THEN l.id\n    END) OVER (\n        PARTITION BY c.name,\n        l.format\n    ) AS legal_id,\n    MIN(CASE\n        WHEN l.status = 'Banned' THEN l.id\n    END) OVER (\n        PARTITION BY c.name,\n        l.format\n    ) AS banned_id,\n    CASE\n        WHEN l.status = 'Legal'\n            THEN MIN(CASE\n                WHEN l.status = 'Legal' THEN l.id\n            END) OVER (\n                PARTITION BY c.name,\n                l.format) - MIN(CASE\n                WHEN l.status = 'Banned' THEN l.id\n            END)\n                OVER (\n                    PARTITION BY c.name,\n                    l.format\n                )\n    END AS id_diff\nFROM cards AS c\nINNER JOIN legalities AS l ON c.uuid = l.uuid\nWHERE\n    l.format IN (\n        'commander',\n        'duel',\n        'legacy'\n    )\nORDER BY\n    c.name ASC,\n    l.format ASC;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_91", "sol_sql": ["WITH a AS (\n    SELECT\n        id,\n        date AS applicationid,\n        ROW_NUMBER() OVER (\n            PARTITION BY id\n            ORDER BY date\n        ) AS rn,\n        LAG(date) OVER (\n            PARTITION BY id\n            ORDER BY date\n        ) AS prev\n    FROM laboratory\n)\n\nSELECT\n    id AS usercode,\n    prev AS data_1,\n    rn AS id_2,\n    applicationid AS data_2,\n    rn - 1 AS id_1\nFROM a\nWHERE prev IS NOT NULL;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_92", "sol_sql": ["SELECT\n    RACEID,\n    NAME,\n    [date],\n    LAG(RACEID) OVER (\n        PARTITION BY YEAR\n        ORDER BY [date]\n    ) AS PREVRACEID,\n    LEAD(RACEID) OVER (\n        PARTITION BY YEAR\n        ORDER BY [date]\n    ) AS NEXTRACEID\nFROM RACES\nORDER BY\n    YEAR,\n    [date];\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_93", "sol_sql": ["WITH pages AS (\n    SELECT\n        1 AS page_id,\n        1 AS power_id\n    UNION ALL\n    SELECT\n        1,\n        7\n    UNION ALL\n    SELECT\n        2,\n        1\n    UNION ALL\n    SELECT\n        3,\n        1\n    UNION ALL\n    SELECT\n        3,\n        7\n    UNION ALL\n    SELECT\n        3,\n        89\n    UNION ALL\n    SELECT\n        4,\n        20\n    UNION ALL\n    SELECT\n        5,\n        55\n    UNION ALL\n    SELECT\n        5,\n        1\n    UNION ALL\n    SELECT\n        6,\n        1\n    UNION ALL\n    SELECT\n        6,\n        13\n),\n\nitems AS (\n    SELECT\n        10 AS hero_id,\n        1 AS power_id\n    UNION ALL\n    SELECT\n        10,\n        7\n    UNION ALL\n    SELECT\n        10,\n        20\n    UNION ALL\n    SELECT\n        12,\n        1\n    UNION ALL\n    SELECT\n        12,\n        55\n)\n\nSELECT\n    p.page_id,\n    i.hero_id\nFROM\n    (SELECT\n        p.page_id,\n        p.power_id,\n        COUNT(*) OVER (PARTITION BY p.page_id) AS total_powers\n    FROM pages AS p) AS p\nINNER JOIN items AS i ON p.power_id = i.power_id\nGROUP BY\n    p.page_id,\n    i.hero_id,\n    p.total_powers\nHAVING COUNT(i.power_id) >= p.total_powers;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_94", "sol_sql": ["WITH data AS (\n    SELECT\n        p.id,\n        p.[First Date] AS as_of_date,\n        p.diagnosis AS current_diagnosis,\n        LAG(p.diagnosis) OVER (\n            PARTITION BY p.id\n            ORDER BY p.[First Date]\n        ) AS prev_diagnosis,\n        CASE\n            WHEN p.diagnosis IN (\n                'RA susp.',\n                'PSS',\n                'SLE'\n            ) THEN 1\n            ELSE 0\n        END AS output_flag\n    FROM patient AS p\n)\n\nSELECT\n    as_of_date,\n    id,\n    current_diagnosis,\n    prev_diagnosis,\n    CASE\n        WHEN output_flag = 1 THEN MIN(as_of_date) OVER (\n            PARTITION BY id,\n            output_flag\n            ORDER BY as_of_date\n        )\n    END AS desired_output\nFROM data\nWHERE\n    current_diagnosis <> prev_diagnosis\n    OR prev_diagnosis IS NULL;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_95", "sol_sql": ["WITH KEYWORDMATCHES AS (\n    SELECT\n        P.ID,\n        CASE\n            WHEN\n                PATINDEX('%' + LOWER('Aaron') + '%', LOWER(P.PLAYER_NAME)) > 0\n                THEN 'Aaron'\n        END AS COLAKEYWORD,\n        CASE\n            WHEN\n                PATINDEX('%' + LOWER('Cresswell') + '%', LOWER(P.PLAYER_NAME))\n                > 0\n                THEN 'Cresswell'\n        END AS COLBKEYWORD,\n        CASE\n            WHEN\n                PATINDEX('%' + LOWER('Doran') + '%', LOWER(P.PLAYER_NAME)) > 0\n                THEN 'Doran'\n        END AS COLCKEYWORD\n    FROM PLAYER AS P\n),\n\nKEYWORDSCORES AS (\n    SELECT\n        ID,\n        STUFF(\n            (\n                SELECT ', ' + COLAKEYWORD\n                FROM KEYWORDMATCHES AS INNERKM\n                WHERE\n                    INNERKM.ID = KM.ID\n                    AND COLAKEYWORD IS NOT NULL\n                FOR XML PATH ('')\n            ), 1, 2, ''\n        ) AS KEYWORDSA,\n        STUFF(\n            (\n                SELECT ', ' + COLBKEYWORD\n                FROM KEYWORDMATCHES AS INNERKM\n                WHERE\n                    INNERKM.ID = KM.ID\n                    AND COLBKEYWORD IS NOT NULL\n                FOR XML PATH ('')\n            ), 1, 2, ''\n        ) AS KEYWORDSB,\n        STUFF(\n            (\n                SELECT ', ' + COLCKEYWORD\n                FROM KEYWORDMATCHES AS INNERKM\n                WHERE\n                    INNERKM.ID = KM.ID\n                    AND COLCKEYWORD IS NOT NULL\n                FOR XML PATH ('')\n            ), 1, 2, ''\n        ) AS KEYWORDSC,\n        SUM(CASE\n            WHEN COLAKEYWORD IS NOT NULL THEN 10\n            ELSE 0\n        END) AS COLASCORE,\n        SUM(CASE\n            WHEN COLBKEYWORD IS NOT NULL THEN 5\n            ELSE 0\n        END) AS COLBSCORE,\n        SUM(CASE\n            WHEN COLCKEYWORD IS NOT NULL THEN 0.1\n            ELSE 0\n        END) AS COLCSCORE\n    FROM KEYWORDMATCHES AS KM\n    GROUP BY ID\n)\n\nSELECT DISTINCT\n    P.ID,\n    P.PLAYER_NAME AS DESCRIPTION,\n    (KS.COLASCORE + KS.COLBSCORE + KS.COLCSCORE) AS SCORE\nFROM PLAYER AS P\nINNER JOIN KEYWORDSCORES AS KS ON P.ID = KS.ID;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_96", "sol_sql": ["WITH ATOMRNS AS (\n    SELECT\n        MOLECULE_ID,\n        ELEMENT,\n        ROW_NUMBER() OVER (\n            PARTITION BY MOLECULE_ID\n            ORDER BY ATOM_ID\n        ) AS RN\n    FROM ATOM\n)\n\nSELECT\n    MOLECULE_ID,\n    MAX(CASE\n        WHEN RN = 1 THEN ELEMENT\n    END) AS ELEMENT1,\n    MAX(CASE\n        WHEN RN = 2 THEN ELEMENT\n    END) AS ELEMENT2,\n    MAX(CASE\n        WHEN RN = 3 THEN ELEMENT\n    END) AS ELEMENT3\nFROM ATOMRNS\nGROUP BY MOLECULE_ID;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_97", "sol_sql": ["WITH SUPERHEROLIST AS (\n    SELECT\n        ID,\n        SUPERHERO_NAME,\n        ROW_NUMBER() OVER (\n            ORDER BY ID\n        ) AS ROWNUMBER\n    FROM SUPERHERO\n)\n\nSELECT\n    S1.SUPERHERO_NAME AS CURRENTSUPERHERO,\n    S2.SUPERHERO_NAME AS SUPERHEROAFTER4\nFROM SUPERHEROLIST AS S1\nLEFT JOIN SUPERHEROLIST AS S2 ON S2.ROWNUMBER = S1.ROWNUMBER + 4;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_98", "sol_sql": ["SELECT num\nFROM\n    (SELECT\n        number AS num,\n        ROW_NUMBER() OVER (\n            ORDER BY id) - ROW_NUMBER() OVER (PARTITION BY number\n        ORDER BY id) AS grp\n    FROM cards) AS a\nGROUP BY\n    grp,\n    num\nHAVING COUNT(*) >= 3;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "SQLServer_99", "sol_sql": ["SELECT\n    molecule_id,\n    bond_type\nFROM\n    (\n        SELECT\n            b.molecule_id,\n            b.bond_type,\n            ROW_NUMBER() OVER (\n                PARTITION BY b.molecule_id\n                ORDER BY b.bond_type\n            ) AS rn\n        FROM bond AS b\n        WHERE\n            EXISTS\n            (\n                SELECT 1\n                FROM bond AS b0\n                WHERE b0.molecule_id = b.molecule_id\n                GROUP BY b0.molecule_id\n                HAVING COUNT(DISTINCT b0.bond_type) > 1\n            )\n    ) AS w\nWHERE rn = 1\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_0", "sol_sql": ["\n    SELECT \n        e.\"event_id\", \n        DBMS_LOB.SUBSTR(e.\"event_name\", 4000, 1) AS event_name,\n        e.\"event_date\", \n        DBMS_LOB.SUBSTR(e.\"type\", 4000, 1) AS type,  \n        MAX(e.\"event_date\") OVER (PARTITION BY DBMS_LOB.SUBSTR(e.\"type\", 4000, 1)) AS latest_event_date \n    FROM \"event\" e\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_1", "sol_sql": ["\n    SELECT \"element\", \"record\"\n    FROM \"frpm_record\"\n\n    UNION ALL\n\n    SELECT \n        substr(\"element\", 1, instr(\"element\", '_') - 1) || '_rate' AS element,\n        MAX(CASE WHEN \"element\" LIKE '%_lowgrade' THEN \"record\" END) /\n        MAX(CASE WHEN \"element\" LIKE '%_highgrade' THEN \"record\" END) AS \"record\"\n    FROM \"frpm_record\"\n    GROUP BY substr(\"element\", 1, instr(\"element\", '_') - 1)\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_2", "sol_sql": ["\n    SELECT M.\"id\", M.\"date\", M.\"overall_rating\"\n    FROM \"Player_Rate\" M\n    WHERE M.\"date\" = (SELECT MAX(M2.\"date\") FROM \"Player_Rate\" M2 WHERE M2.\"id\" = M.\"id\")\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_3", "sol_sql": ["\n    MERGE INTO \"frpm\" target \n    USING (SELECT DISTINCT \"CDSCode\" FROM \"frpm\" WHERE \"Percent (%) Eligible Free (K-12)\" >= 0.5) source\n    ON (target.\"CDSCode\" = source.\"CDSCode\")\n    WHEN MATCHED THEN \n    UPDATE SET target.\"Charter School (Y/N)\" = 1000\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    query = \"\"\"SELECT \"CDSCode\" FROM \"frpm\" WHERE \"Charter School (Y/N)\" = 1000\"\"\"\n    result, _ = perform_query_on_oracle_databases(query, db_name, conn=None, as_dict=False)\n    assert len(result) > 0\n    "]}
{"instance_id": "Oracle_4", "sol_sql": ["\n    SELECT \"id\", \"date\", \"home_team_goal\", LAG(\"home_team_goal\") OVER (ORDER BY \"date\" ASC) AS prev_home_goal FROM \"Match\" WHERE \"date\" <= TO_DATE('2024-02-26', 'YYYY-MM-DD')\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1\"\n    "]}
{"instance_id": "Oracle_5", "sol_sql": ["\n    MERGE INTO \"school_record\" tab2\n    USING (\n        SELECT \"CDSCode\", \"Charter School (Y/N)\" FROM \"charter_school\" WHERE \"Charter School (Y/N)\" = '1'\n    ) tab1\n    ON (tab1.\"CDSCode\" = tab2.\"CDSCode\")\n    WHEN NOT MATCHED THEN\n        INSERT (\"CDSCode\") VALUES (tab1.\"CDSCode\")\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    sql = 'SELECT * FROM \"school_record\"'\n    sql_res, _ = perform_query_on_oracle_databases(sql, db_name, conn=conn, as_dict=False)\n    id_lists = sorted([i[0] for i in sql_res])\n    assert id_lists == ['01611430122689', '01611430122697']\n    "]}
{"instance_id": "Oracle_6", "sol_sql": ["\n    SELECT \n    SUBSTR(\"first_name\", 1, 1) || RPAD('', LENGTH(\"first_name\") - 2, '') || SUBSTR(\"first_name\", -1) AS masked_first_name,\n    SUBSTR(\"last_name\", 1, 1) || RPAD('', LENGTH(\"last_name\") - 2, '') || SUBSTR(\"last_name\", -1) AS masked_last_name\n    FROM \"member\"\n    WHERE LENGTH(\"first_name\") > 2 AND LENGTH(\"last_name\") > 2\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1\"\n    "]}
{"instance_id": "Oracle_7", "sol_sql": ["\n    SELECT \"atom_id\",\n        MAX(CASE WHEN rn = 1 THEN \"bond_id\" END) AS bond_id_1,\n        MAX(CASE WHEN rn = 2 THEN \"bond_id\" END) AS bond_id_2,\n        MAX(CASE WHEN rn = 3 THEN \"bond_id\" END) AS bond_id_3\n    FROM (\n        SELECT \"atom_id\", \"bond_id\",\n            ROW_NUMBER() OVER (PARTITION BY \"atom_id\" ORDER BY \"bond_id\") AS rn\n        FROM \"connected\"\n    ) \n    WHERE rn <= 3\n    GROUP BY \"atom_id\"\n    ORDER BY \"atom_id\"\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1\"\n    "]}
{"instance_id": "Oracle_8", "sol_sql": ["\n    SELECT a.\"link_to_event\", tmp.*\n    FROM \"attendance_trunc\" a\n    CROSS JOIN LATERAL (\n        SELECT LISTAGG(m.\"member_name\", '|') WITHIN GROUP (ORDER BY v.position) AS value\n        FROM (\n            SELECT LEVEL AS position,\n                REGEXP_SUBSTR(a.\"link_to_member\", '[^|]+', 1, LEVEL) AS value\n            FROM DUAL\n            CONNECT BY REGEXP_SUBSTR(a.\"link_to_member\", '[^|]+', 1, LEVEL) IS NOT NULL\n        ) v\n        INNER JOIN \"member_trunc\" m\n            ON v.value = m.\"member_id\"\n    ) tmp\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1\"\n    "]}
{"instance_id": "Oracle_9", "sol_sql": ["\n    DELETE FROM \"atom\"\n    WHERE \n        DBMS_LOB.SUBSTR(\"atom\".\"element\", 4000, 1) <> 'cl'\n        AND EXISTS (\n            SELECT 1\n            FROM \"molecule\"\n            WHERE \"atom\".\"molecule_id\" = \"molecule\".\"molecule_id\"\n            AND DBMS_LOB.SUBSTR(\"molecule\".\"label\", 4000, 1) = '-'\n        )\n    "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    sql = \"\"\"\n    SELECT *\n    FROM \"atom\"\n    WHERE \n        DBMS_LOB.SUBSTR(\"element\", 4000, 1) <> 'cl'\n        AND EXISTS (\n            SELECT 1\n            FROM \"molecule\"\n            WHERE \"atom\".\"molecule_id\" = \"molecule\".\"molecule_id\"\n            AND DBMS_LOB.SUBSTR(\"label\", 4000, 1) = '-'\n        )\n    \"\"\"\n    sql_res, _ = perform_query_on_oracle_databases(sql, db_name, conn=conn, as_dict=False)\n    assert sql_res == []\n    "]}
{"instance_id": "Oracle_10", "sol_sql": ["\nSELECT \"cds\", \n       TO_CHAR(\"sname\"), \n       (SELECT JSON_ARRAYAGG(JSON_OBJECT(\n           'enroll12' VALUE TO_CHAR(\"enroll12\"),\n           'NumTstTakr' VALUE TO_CHAR(\"NumTstTakr\"),\n           'AvgScrRead' VALUE TO_CHAR(\"AvgScrRead\"),\n           'AvgScrMath' VALUE TO_CHAR(\"AvgScrMath\"),\n           'AvgScrWrite' VALUE TO_CHAR(\"AvgScrWrite\")\n           ) ORDER BY \"enroll12\" DESC\n           RETURNING CLOB) \n        FROM \"satscores\" t\n        WHERE TO_CHAR(t.\"rtype\") = 'S' \n        AND t.\"cds\" = \"satscores\".\"cds\"\n       ) \nFROM \"satscores\" \nWHERE TO_CHAR(\"rtype\") = 'S'\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):   \n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_11", "sol_sql": ["\nWITH OrderedCategories AS (\n  SELECT \n    ROW_NUMBER() OVER (ORDER BY DBMS_LOB.SUBSTR(\"category\", 4000) DESC) AS rn,\n    DBMS_LOB.SUBSTR(\"category\", 4000) AS category,\n    SUM(\"spent\") AS category_total\n  FROM \"MASTER\".\"budget\"\n  GROUP BY DBMS_LOB.SUBSTR(\"category\", 4000)\n),\nRecursiveCTE (rn, category, category_total, cumulative_total, included) AS (\n  SELECT \n    rn,\n    category,\n    category_total,\n    category_total AS cumulative_total,\n    CASE \n      WHEN category_total <= 800 THEN 1 ELSE 0 \n    END AS included\n  FROM OrderedCategories\n  WHERE rn = 1\n  UNION ALL\n  SELECT \n    oc.rn,\n    oc.category,\n    oc.category_total,\n    CASE \n      WHEN r.cumulative_total + oc.category_total <= 800 THEN r.cumulative_total + oc.category_total\n      ELSE r.cumulative_total \n    END AS cumulative_total,\n    CASE \n      WHEN r.cumulative_total + oc.category_total <= 800 THEN 1 ELSE 0 \n    END AS included\n  FROM RecursiveCTE r\n  JOIN OrderedCategories oc ON oc.rn = r.rn + 1\n)\nSELECT category, category_total\nFROM RecursiveCTE\nWHERE included = 1\nORDER BY rn\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):   \n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_12", "sol_sql": ["\nSELECT header || ': ' || \"name\" AS grouped_countries\nFROM (\n    SELECT \n        t.*,\n        LAG(CASE WHEN \"name\" LIKE 'Country Group%' THEN \"name\" END IGNORE NULLS) \n        OVER (ORDER BY \"id\") AS header\n    FROM \"Country\" t\n)\nWHERE \"name\" NOT LIKE 'Country Group%'\nORDER BY \"id\" "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_13", "sol_sql": ["\nSELECT TO_CHAR(\"type\"),\n    COUNT(*) KEEP (DENSE_RANK LAST ORDER BY EXTRACT(YEAR FROM \"event_date\")) - COUNT(*) KEEP (DENSE_RANK FIRST ORDER BY EXTRACT(YEAR FROM \"event_date\")) e\nFROM \"event\"\nGROUP BY TO_CHAR(\"type\")\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):   \n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_14", "sol_sql": ["\nSELECT COUNT(*)\n    FROM (\n        SELECT DISTINCT\n            LEAST(h.\"home_team_api_id\", h.\"away_team_api_id\") AS team1,\n            GREATEST(h.\"home_team_api_id\", h.\"away_team_api_id\") AS team2\n        FROM \"Match\" h\n        WHERE EXISTS (\n            SELECT 1 \n            FROM \"Match\" a\n            WHERE a.\"home_team_api_id\" = h.\"away_team_api_id\"\n            AND a.\"away_team_api_id\" = h.\"home_team_api_id\"\n        )\n)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):   \n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_15", "sol_sql": ["\n    SELECT \"player_api_id\",\n       MAX(\"overall_rating\") KEEP (DENSE_RANK FIRST ORDER BY \"date\" DESC)      AS \"latest_overall_rating\",\n       MAX(\"potential\") KEEP (DENSE_RANK FIRST ORDER BY \"date\" DESC)           AS \"latest_potential\",\n       MAX(TO_CHAR(\"preferred_foot\")) KEEP (DENSE_RANK FIRST ORDER BY \"date\" DESC)      AS \"latest_preferred_foot\",\n       MAX(TO_CHAR(\"attacking_work_rate\")) KEEP (DENSE_RANK FIRST ORDER BY \"date\" DESC) AS \"latest_attacking_work_rate\"\n    FROM \"Player_Attributes\"\n    WHERE \"date\" <= TO_DATE('2015-12-31', 'YYYY-MM-DD')\n    GROUP BY \"player_api_id\"\n    ORDER BY \"player_api_id\" "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_16", "sol_sql": ["\n    SELECT * FROM (\n        SELECT \"District Name\",\n               CASE\n                   WHEN INSTR(\n                       (SELECT LISTAGG(SUBSTR(\"District Name\", LEVEL, 1)) WITHIN GROUP (ORDER BY LEVEL DESC)\n                        FROM DUAL\n                        CONNECT BY LEVEL <= LENGTH(\"District Name\")),\n                       'deifinU'\n                   ) > 0\n                   THEN LENGTH(\"District Name\") - (INSTR(\n                       (SELECT LISTAGG(SUBSTR(\"District Name\", LEVEL, 1)) WITHIN GROUP (ORDER BY LEVEL DESC)\n                        FROM DUAL\n                        CONNECT BY LEVEL <= LENGTH(\"District Name\")),\n                       'deifinU'\n                   ) + LENGTH('Unified') - 2)\n                   ELSE 0\n               END AS Position_district\n        FROM \"frpm\"\n    ) sub\n    ORDER BY sub.Position_district DESC "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty'\n    assert test_result[0][0] == 'Dos Palos Oro Loma Joint Unified', 'The first query of the district name should be Dos Palos Oro Loma Joint Unified.'\n    expected = execute_queries([\"\"\"\n        SELECT \"District Name\",\n               INSTR(\"District Name\", 'Unified', 3) AS Position\n        FROM \"frpm\"\n        order by INSTR(\"District Name\", 'Unified', 3) desc \"\"\"], db_name, conn)[0]\n    for i, (row1, row2) in enumerate(zip(test_result, expected)):\n        assert row1 == row2, f'Every row in test_result should be in the expected array. This expected row should be {row2}, but shown {row1}'\n\n    "]}
{"instance_id": "Oracle_17", "sol_sql": ["\n    SELECT distinct test.\"atom_id\", COUNT(\"connected\".\"atom_id\") OVER (PARTITION BY test.\"atom_id\") AS cnt\n    FROM test LEFT JOIN \"connected\" ON test.\"atom_id\" = \"connected\".\"atom_id\"\n    WHERE test.\"atom_id\" IN ( SELECT COLUMN_VALUE\n            FROM TABLE( NEW atom_tab('TR000_1', 'TR000_2') ) tab ) \n    order by  test.\"atom_id\" "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_18", "sol_sql": ["\n    SELECT \"frpm\".*\n    FROM \"frpm\"\n    LEFT OUTER JOIN \"satscores\" ON \"frpm\".\"CDSCode\" = \"satscores\".\"cds\"\n    LEFT OUTER JOIN \"schools\" ON \"frpm\".\"CDSCode\" = \"schools\".\"CDSCode\"\n    WHERE (\"satscores\".\"cds\" = '01100170112607' AND \"schools\".\"CDSCode\" = '01100170112607')\n    AND \"frpm\".\"Charter School (Y/N)\" = '1' AND COALESCE(\"frpm\".\"District Code\", 0) = 10017 "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result_0 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result_0) > 0, f'Expected non-zero results, but found {len(test_result_0)} results'\n    query = [\"\"\"SELECT \"frpm\".*\n        FROM \"frpm\"\n        LEFT OUTER\n        JOIN \"satscores\" ON \"frpm\".\"CDSCode\" = \"satscores\".\"cds\"\n        LEFT OUTER JOIN \"schools\" ON \"frpm\".\"CDSCode\" = \"schools\".\"CDSCode\"\n        WHERE (\"schools\".\"CDSCode\" = '01100170112607' and \"satscores\".\"cds\" = '01100170112607')\n        AND \"frpm\".\"Charter School (Y/N)\" = 1 AND COALESCE(\"frpm\".\"District Code\", 0) = 10017 \"\"\"]\n    test_pred_query_result_1 = execute_queries(query, db_name, conn)[0]\n    assert test_result_0[0] == test_pred_query_result_1[0], f'Expected output is {test_pred_query_result_1}, but found {test_result_0}.'\n    assert all(row[-1] == 1 for row in test_result_0), 'All retrieved records should be from charter schools (Charter = 1)'\n    assert all(row[3] == 10017 for row in test_result_0), 'All retrieved records should belong to District Code 10017'\n    "]}
{"instance_id": "Oracle_19", "sol_sql": ["\n    WITH date_ranges AS (\n    SELECT\n        \"player_fifa_api_id\" as id,\n        MIN(\"date\") AS first_date,\n        MAX(\"date\") AS last_date\n    FROM \"Player_Attributes\"\n    GROUP BY \"player_fifa_api_id\"\n    )\n    SELECT\n        id,\n        'Before First Date' AS period_type,\n        first_date,\n        first_date - DATE '2000-01-01' AS days_diff\n    FROM date_ranges\n    WHERE first_date > DATE '2000-01-01'\n    UNION ALL\n    SELECT\n        id,\n        'After Last Date' AS period_type,\n        last_date,\n        DATE '2025-12-31' - last_date AS days_diff\n    FROM date_ranges\n    WHERE last_date < DATE '2025-12-31'\n    ORDER BY id, days_diff"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    query = [\"\"\"\n    select min(\"date\"),max(\"date\")\n    from \"Player_Attributes\"\n    where \"player_fifa_api_id\" = 2\"\"\"]\n    test_date = execute_queries(query, db_name, conn)[0]\n    assert test_result[0][2] == test_date[0][0], 'Expected first date of id=2 should be the same'\n    assert test_result[1][2] == test_date[0][1], 'Expected last date of id=2 should be the same'\n    query = [\"\"\"\n    select min(\"date\")-date '2000-01-01'\n    from \"Player_Attributes\"\n    where \"player_fifa_api_id\" = 2\"\"\"]\n    test_date_diff = execute_queries(query, db_name, conn)[0]\n    assert test_result[0][3] == test_date_diff[0][0], 'Expected first date diff from 2000-01-01 of id=2 should be the same'\n    query = [\"\"\"\n    select date '2025-12-31' - max(\"date\")\n    from \"Player_Attributes\"\n    where \"player_fifa_api_id\" = 2\"\"\"]\n    test_date_diff = execute_queries(query, db_name, conn)[0]\n    assert test_result[1][3] == test_date_diff[0][0], 'Expected last date diff to 2025-12-31 of id=2 should be the same'\n\n    "]}
{"instance_id": "Oracle_20", "sol_sql": ["\n    SELECT *\n    FROM \"event\" e\n    WHERE to_char(e.\"status\") <> 'Closed'\n    and ROWNUM <= 5"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert all(row[6] != 'Closed' for row in test_result), 'None of the events should have status Closed'\n    assert len(test_result) <= 5, f'Expected at most 5 rows, but found {len(test_result)} rows'\n    test_ordered_events = execute_queries([\"\"\"SELECT * FROM \"event\" WHERE to_char(\"event\".\"status\") != 'Closed' FETCH first 5 ROWS ONLY\"\"\"], db_name, conn)[0]\n    assert test_result == test_ordered_events, 'Expected and actual query results do not match when fetching and locking rows.'\n\n    "]}
{"instance_id": "Oracle_21", "sol_sql": ["\n    SELECT e.\"event_id\", b.\"amount\", a.\"link_to_member\", a.\"link_to_event\"\n    FROM \"event\" e\n    LEFT JOIN \"budget\" b ON e.\"event_id\" = b.\"link_to_event\"\n    LEFT JOIN \"attendance\" a ON e.\"event_id\" = a.\"link_to_event\"\n    ORDER BY e.\"event_id\" "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least one result row, but none found.'\n    test_budget_table_result = execute_queries(['SELECT \"amount\", \"link_to_event\" FROM \"budget\"'], db_name, conn)[0]\n    expected_event_ids = {row[1] for row in test_budget_table_result}\n    expected_amount = {row[0] for row in test_budget_table_result}\n    actual_event_ids = {row[0] for row in test_result}\n    actual_amount = {row[1] for row in test_result}\n    assert expected_event_ids.issubset(actual_event_ids), f'Expected event_ids from budget table: {expected_event_ids}, but found different in result: {actual_event_ids}'\n    assert expected_amount.issubset(actual_amount), f'Expected amount from budget table: {expected_amount}, but found different in result: {actual_amount}'\n    test_event_count_result = execute_queries(['SELECT COUNT(DISTINCT \"event_id\") FROM \"event\"'], db_name, conn)[0]\n    assert test_event_count_result[0][0] == len(set(row[0] for row in test_result)), f'Expected {test_event_count_result[0][0]} distinct event_ids, but got {len(set(row[0] for row in test_result))}'\n\n    "]}
{"instance_id": "Oracle_22", "sol_sql": ["\n    SELECT sh.\"id\" AS superhero_id,\n           sh.\"superhero_name\",\n           a.\"alignment\" AS moral_alignment\n    FROM \"superhero\" sh\n    JOIN \"alignment\" a ON sh.\"alignment_id\" = a.\"id\"\n    WHERE a.\"alignment\" LIKE '%Good%'\n    order by sh.\"id\" "], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected results with alignments containing \"Good\", but found none.'\n    for row in test_result: assert 'Good' in row[2], f'Expected alignment to include \"Good\", but found {row[-1]}'\n    expected_alignments = execute_queries([\"\"\"SELECT \"id\", \"superhero_name\" FROM \"superhero\" WHERE \"alignment_id\" = 1\"\"\"], db_name, conn)[0]\n    expected_ids = {row[0] for row in expected_alignments}\n    expected_name = {row[1] for row in expected_alignments}\n    actual_ids = {row[0] for row in test_result}\n    actual_name = {row[1] for row in test_result}\n    assert expected_ids == actual_ids, f'Expected superhero IDs: {expected_ids}, but found: {actual_ids}.'\n    assert expected_name == actual_name, f'Expected superhero names: {expected_name}, but found: {actual_name}.'\n    unique_alignments = set(row[2] for row in test_result)\n    assert unique_alignments == {'Good'}, f'Expected all alignments to be \"Good\", but found: {unique_alignments}.'\n\n    "]}
{"instance_id": "Oracle_23", "sol_sql": ["SELECT objectid FROM (SELECT ply.objectid, row_number() OVER (PARTITION BY ply.objectid ORDER BY NULL) rn FROM ply CROSS JOIN pnt WHERE sdo_anyinteract(ply.shape, pnt.shape) = 'TRUE') WHERE rn = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_execution_plan(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_24", "sol_sql": ["select trunc(eventdate, 'iw') as eventdate, userid, sum(traffic) as traffic, stats_mode(location) as location from SCHOOL_EVENTS group by trunc(eventdate, 'iw'), userid"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_execution_plan(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_25", "sol_sql": ["MERGE INTO record d USING (SELECT ROWID AS rid, SYS_GUID() AS uuid FROM record s) s ON (s.rid = d.ROWID) WHEN MATCHED THEN UPDATE SET d.r1 = uuid, d.r2 = uuid"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = True\n    res = execute_queries([\"SELECT * FROM record\"], db_name, conn)[0]\n    for i in res:\n        if i[1] != i[2]:\n            result = False\n    assert result, \"The UPDATE does not work.\"\n    "]}
{"instance_id": "Oracle_26", "sol_sql": ["INSERT INTO groups (ROOM_GUID, USER_GUID) SELECT o.GUID, g.USER_GUID FROM login o JOIN groups g ON o.LOGIN = (SELECT o2.LOGIN FROM login o2 WHERE o2.GUID = g.ROOM_GUID) AND o.NAME = (SELECT o3.NAME FROM login o3 WHERE o3.GUID = g.ROOM_GUID) WHERE o.GUID NOT IN (SELECT ROOM_GUID FROM groups)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = execute_queries([\"SELECT * FROM groups WHERE USER_GUID = 'CCCCCCCCCC'\"], db_name, conn)[0]\n    l = len(res)\n    assert l == 2, f\"Returned {l} rows.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = execute_queries([\"SELECT * FROM groups WHERE USER_GUID = 'AAAAAAAAAA'\"], db_name, conn)[0]\n    l = len(res)\n    assert l == 2, f\"Returned {l} rows.\"\n    "]}
{"instance_id": "Oracle_27", "sol_sql": ["CREATE OR REPLACE FUNCTION FIND_TEST_TABLE_COLUMN(IN_COLUMN1 TEST_TABLE.COLUMN1 % TYPE, IN_COLUMN2 TEST_TABLE.COLUMN2 % TYPE, IN_COLUMN3 TEST_TABLE.COLUMN3 % TYPE, IN_COLUMN4 TEST_TABLE.COLUMN4 % TYPE, IN_REQUESTED_COLUMN VARCHAR2) RETURN VARCHAR2 IS result VARCHAR2(255); BEGIN SELECT CASE IN_REQUESTED_COLUMN WHEN 'COLUMN1' THEN column1 WHEN 'COLUMN2' THEN column2 WHEN 'COLUMN3' THEN column3 END INTO result FROM TEST_TABLE WHERE  COLUMN1 = IN_COLUMN1 AND COLUMN2 = IN_COLUMN2 AND COLUMN3 = IN_COLUMN3 AND (IN_COLUMN4 IS NULL OR COLUMN4 = IN_COLUMN4) FETCH FIRST ROW ONLY; RETURN result; EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = execute_queries([\"SELECT FIND_TEST_TABLE_COLUMN('A', 'B', 'C', 'D', 'COLUMN1') AS result1, FIND_TEST_TABLE_COLUMN('A', 'B', 'C', NULL, 'COLUMN2') AS result2, FIND_TEST_TABLE_COLUMN('X', 'Y', 'Z', NULL, 'COLUMN3') AS result3 FROM DUAL\"], db_name, conn)[0]\n    l = len(res)\n    assert l == 1, f\"Returned {l} rows.\"\n    assert res[0] == ('A', 'B', None), \"The result is incorrect.\"\n    "]}
{"instance_id": "Oracle_28", "sol_sql": ["select \"date\" from \"Team_Attributes\" where \"team_api_id\" = 123 order by \"date\" desc fetch first 1 rows only"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = performance_compare_by_execution_plan(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_29", "sol_sql": ["SELECT td.year, br.bond_type, COUNT(td.bond_type) FROM bond_ref br LEFT OUTER JOIN (SELECT EXTRACT(YEAR FROM transact_dt_tm) AS year, bond_type FROM bond_list) td PARTITION BY (td.year) ON br.bond_type = td.bond_type GROUP BY td.year, br.bond_seq, br.bond_type ORDER BY td.year, br.bond_seq"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_30", "sol_sql": ["with temp as (select b.*, row_number() over (order by id) - id grp from employee b where total_employees > 100), temp2 as (select a.*, count(*) over (partition by grp) cnt from temp a) select id, enroll_date, total_employees from temp2 where cnt >= 3 order by id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_31", "sol_sql": ["SELECT \"2020\", \"2021\", \"2022\", \"2023\", \"2024\", \"2020\" + \"2021\" + \"2022\" + \"2023\" + \"2024\" AS for_total FROM (SELECT EXTRACT(YEAR FROM payment_date) AS year, payment_sum FROM FEE) PIVOT (SUM(payment_sum) FOR year IN (2020,2021,2022,2023,2024))"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "Oracle_32", "sol_sql": ["SELECT UTL_RAW.SUBSTR(STANDARD_HASH(product_id, 'SHA1'), 1, 8) AS hash_value, UTL_RAW.LENGTH(UTL_RAW.SUBSTR(STANDARD_HASH(product_id, 'SHA1'), 1, 8)) AS hash_length FROM products"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res = execute_queries(pred_sqls, db_name, conn)[0]\n    for i in res:\n        l = len(i[0])\n        assert l == 8, f\"Returned length is {l}.\"\n    "]}
{"instance_id": "Oracle_33", "sol_sql": ["SELECT\n    \"Match\".\"id\" AS \"match_id\",\n    \"Match\".\"date\" AS \"match_date\",\n    \"Match\".\"home_team_goal\" AS \"home_team_goals\",\n    \"Match\".\"away_team_goal\" AS \"away_team_goals\",\n    \"HomeTeam\".\"team_long_name\" AS \"home_team_name\",\n    \"AwayTeam\".\"team_long_name\" AS \"away_team_name\",\n    \"League\".\"name\" AS \"league_name\"\nFROM \"Match\"\nINNER JOIN\n    \"Team\" \"HomeTeam\"\n    ON \"Match\".\"home_team_api_id\" = \"HomeTeam\".\"team_api_id\"\nINNER JOIN\n    \"Team\" \"AwayTeam\"\n    ON \"Match\".\"away_team_api_id\" = \"AwayTeam\".\"team_api_id\"\nINNER JOIN \"League\" ON \"Match\".\"league_id\" = \"League\".\"id\"\nORDER BY \"Match\".\"date\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_34", "sol_sql": ["SELECT\n    \"molecule_id\",\n    \"label\"\nFROM \"molecule\"\nORDER BY \"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_35", "sol_sql": ["SELECT XMLSERIALIZE(DOCUMENT XMLELEMENT(\"files\", XMLAGG(XMLELEMENT(\"file\", XMLFOREST(\"id\" AS \"id\", \"team_long_name\" AS \"team_long_name\"))\n                                                        ORDER BY NLSSORT(\"team_long_name\", 'NLS_SORT=XFRENCH'))) INDENT SIZE = 2)\nFROM \"Team\""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_36", "sol_sql": ["SELECT\n    L.\"name\" AS \"league_name\",\n    EXTRACT(\n        YEAR\n        FROM \"date\"\n    ) AS \"year\",\n    COUNT(*) AS \"match_count\"\nFROM \"Match\" M\nINNER JOIN \"League\" L ON M.\"league_id\" = L.\"id\"\nGROUP BY\n    EXTRACT(\n        YEAR\n        FROM M.\"date\"\n    ),\n    L.\"name\"\nORDER BY EXTRACT(\n    YEAR\n    FROM M.\"date\"\n),\nL.\"name\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_37", "sol_sql": ["WITH temp AS (\n    SELECT\n        a.\"atom_id\",\n        a.\"molecule_id\",\n        ROW_NUMBER() OVER (\n            PARTITION BY a.\"molecule_id\"\n            ORDER BY a.\"atom_id\"\n        ) - TO_NUMBER(REGEXP_SUBSTR(a.\"atom_id\", '\\d+$'\n        )) AS grp\n    FROM \"atom\" a\n),\n\ntemp2 AS (\n    SELECT\n        t.\"atom_id\",\n        t.\"molecule_id\",\n        COUNT(*) OVER (PARTITION BY t.\"molecule_id\", t.grp) AS cnt\n    FROM temp t\n)\n\nSELECT\n    t2.\"atom_id\",\n    t2.\"molecule_id\"\nFROM temp2 t2\nWHERE t2.cnt >= 3\nORDER BY\n    t2.\"molecule_id\",\n    t2.\"atom_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_38", "sol_sql": ["WITH tmp AS (\n    SELECT\n        school_id,\n        start_date,\n        end_date\n    FROM school_info\n),\ntmp1 AS (\n    SELECT\n        CONNECT_BY_ROOT t.start_date AS start_date,  \n        t.school_id AS school_id,\n        t.start_date AS start_date1,                 \n        t.end_date AS end_date,                     \n        LEVEL AS lvl\n    FROM tmp t\n    CONNECT BY\n         PRIOR school_id  = school_id\n     AND PRIOR start_date <> start_date\n     AND PRIOR end_date   <> end_date\n     AND PRIOR end_date BETWEEN start_date AND end_date\n),\ntmp2 AS (\n    SELECT *\n    FROM tmp1\n    WHERE (start_date, school_id, lvl) IN (\n        SELECT\n            start_date,\n            school_id,\n            MAX(lvl) AS max_lvl\n        FROM tmp1\n        GROUP BY\n            start_date,\n            school_id\n    )\n)\nSELECT\n    school_id,\n    MIN(start_date) AS start_date,   \n    end_date                      \nFROM tmp2\nGROUP BY\n    school_id,\n    end_date\nORDER BY\n    school_id,\n    start_date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "Oracle_39", "sol_sql": ["WITH \"cte\" AS (\n    SELECT\n        \"id\",\n        \"superhero_name\",\n        \"alignment_id\",\n        \"publisher_id\",\n        \"height_cm\",\n        \"hair_colour_id\",\n\n        MAX(\"height_cm\") OVER (\n            PARTITION BY \"alignment_id\", \"publisher_id\"\n        ) AS \"max_height\",\n\n        SUM(\"hair_colour_id\") OVER (\n            PARTITION BY \"alignment_id\", \"publisher_id\"\n        ) AS \"total_hair_colour\"\n\n    FROM \"superhero\"\n)\nSELECT\n    \"alignment_id\",\n    \"publisher_id\",\n    \"id\",\n    \"superhero_name\",\n    \"height_cm\",\n    \"hair_colour_id\",\n    \"total_hair_colour\"\nFROM \"cte\"\nWHERE \"height_cm\" = \"max_height\"\nORDER BY\n    \"alignment_id\",\n    \"publisher_id\",\n    \"id\" "], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "Oracle_40", "sol_sql": ["WITH all_paths AS (\n    SELECT\n        CONNECT_BY_ROOT(from_atom)           AS root_atom,\n        SYS_CONNECT_BY_PATH(from_atom, '->') AS full_path,\n        from_atom,\n        to_atom,\n        start_date,\n        LEVEL AS lvl\n    FROM toxic_mappings\n    CONNECT BY NOCYCLE from_atom = PRIOR to_atom\n),\nmarked_paths AS (\n    SELECT\n        root_atom,\n        from_atom,\n        to_atom,\n        start_date,\n        LEAD(start_date - 1, 1) OVER (\n           PARTITION BY full_path\n           ORDER BY lvl, start_date\n        ) AS end_date,\n        full_path\n    FROM all_paths\n)\nSELECT\n    root_atom       AS begin_atom,\n    from_atom,\n    to_atom         AS end_atom,\n    start_date      AS path_start_date,\n    end_date,\n    full_path       AS path_identifier\nFROM marked_paths\nORDER BY root_atom, path_start_date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base_server returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "Oracle_41", "sol_sql": ["SELECT\n    \"atom\".\"atom_id\",\n    \"atom\".\"molecule_id\",\n    \"atom\".\"element\",\n    \"molecule\".\"label\",\n    \"bond\".\"bond_id\",\n    \"bond\".\"bond_type\"\nFROM \"atom\"\nINNER JOIN \"molecule\" ON \"atom\".\"molecule_id\" = \"molecule\".\"molecule_id\"\nLEFT JOIN \"connected\" ON \"atom\".\"atom_id\" = \"connected\".\"atom_id\"\nLEFT JOIN \"bond\" ON \"connected\".\"bond_id\" = \"bond\".\"bond_id\"\nORDER BY\n    \"atom\".\"molecule_id\",\n    \"atom\".\"atom_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_42", "sol_sql": ["SELECT\n    EXTRACT(\n        YEAR\n        FROM TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')\n    ) AS \"year\",\n    TO_CHAR(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS'), 'IW') AS \"week\",\n    SUM(CASE\n        WHEN \"home_team_goal\" > \"away_team_goal\" THEN 1\n        ELSE 0\n    END) AS \"home_team_wins\",\n    SUM(CASE\n        WHEN \"home_team_goal\" < \"away_team_goal\" THEN 1\n        ELSE 0\n    END) AS \"away_team_wins\",\n    SUM(CASE\n        WHEN \"home_team_goal\" = \"away_team_goal\" THEN 1\n        ELSE 0\n    END) AS \"draws\",\n    COUNT(*) AS \"total_matches\"\nFROM \"Match\"\nGROUP BY\n    EXTRACT(\n        YEAR\n        FROM TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')\n    ),\n    TO_CHAR(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS'), 'IW')\nORDER BY\n    \"year\",\n    \"week\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_43", "sol_sql": ["WITH set_a (\n    x) AS (\n    SELECT 1\n    FROM dual\n    UNION ALL\n    SELECT 2\n    FROM dual\n    UNION ALL\n    SELECT 1\n    FROM dual\n),\n\nset_b (\n    x) AS (\n    SELECT 1\n    FROM dual\n    UNION ALL\n    SELECT 2\n    FROM dual\n),\n\nunique_a (x, rn) AS (\n    SELECT\n        x,\n        ROW_NUMBER() OVER (\n            PARTITION BY x\n            ORDER BY rownum\n        ) AS rn\n    FROM set_a\n),\n\nunique_b (x, rn) AS (\n    SELECT\n        x,\n        ROW_NUMBER() OVER (\n            PARTITION BY x\n            ORDER BY rownum\n        ) AS rn\n    FROM set_b\n)\n\nSELECT\n    COUNT(CASE\n        WHEN a.rn = b.rn THEN 1\n    END) AS num_identical_in_a_and_b,\n    COUNT(CASE\n        WHEN a.rn IS NULL THEN 1\n    END) AS num_not_identical_in_a,\n    COUNT(CASE\n        WHEN b.rn IS NULL THEN 1\n    END) AS num_not_identical_in_b\nFROM unique_a a\nFULL OUTER JOIN unique_b\n    b ON a.x = b.x\nAND a.rn = b.rn\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_44", "sol_sql": ["SELECT\n    \"molecule_id\",\n    LISTAGG(\"element\", ' || ') WITHIN GROUP (\n        ORDER BY \"atom_id\"\n    ) AS \"elements\"\nFROM \"atom\"\nGROUP BY \"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_45", "sol_sql": ["SELECT DISTINCT\n    \"molecule_id\",\n    LISTAGG(DISTINCT \"atom_id\", ',') WITHIN GROUP (\n        ORDER BY \"atom_id\"\n    ) OVER (PARTITION BY \"molecule_id\") AS \"atom_ids\"\nFROM \"atom\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_46", "sol_sql": ["WITH data (\n    value) AS (\n    SELECT '111,2,3 | 112,4,5 | 113,6,7'\n    FROM dual\n),\n\nhero_attributes (value, i, max_i, hero_id, attribute_id, attribute_value) AS (\n    SELECT\n        value,\n        1,\n        REGEXP_COUNT(value, '(.*?),(.*?),(.*?)(\\||$)'),\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, 1, NULL, 1),\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, 1, NULL, 2),\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, 1, NULL, 3)\n    FROM data\n    UNION ALL\n    SELECT\n        value,\n        i + 1,\n        max_i,\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, i + 1, NULL, 1),\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, i + 1, NULL, 2),\n        REGEXP_SUBSTR(value, '(.*?),(.*?),(.*?)(\\||$)', 1, i + 1, NULL, 3)\n    FROM hero_attributes\n    WHERE i < max_i\n)\n\nSELECT\n    i,\n    hero_id,\n    attribute_id,\n    attribute_value\nFROM hero_attributes\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_47", "sol_sql": ["SELECT\n    \"date\",\n    \"match_api_id\"\nFROM\n    (SELECT\n        \"date\",\n        \"match_api_id\",\n        RANK() OVER (\n            PARTITION BY TRUNC(\"date\")\n            ORDER BY ABS(TRUNC(\"date\") + INTERVAL '8' HOUR - \"date\")\n        ) AS rnk8,\n        RANK() OVER (\n            PARTITION BY TRUNC(\"date\")\n            ORDER BY ABS(TRUNC(\"date\") + INTERVAL '20' HOUR - \"date\")\n        ) AS rnk20\n    FROM \"Match\")\nWHERE\n    rnk8 = 1\n    OR rnk20 = 1\nORDER BY \"date\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_48", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\",\n    \"c\".\"atom_id2\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"b\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_49", "sol_sql": ["WITH match_dates AS (\n    SELECT\n        \"id\",\n        TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS') AS match_date,\n        TO_CHAR(\n            TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS'),\n            'fxDay',\n            'NLS_DATE_LANGUAGE=English'\n        ) AS day_of_week,\n        TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS') AS match_start_time,\n        TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')\n        + INTERVAL '2' HOUR AS match_end_time\n    FROM \"Match\"\n)\n\nSELECT\n    m.*,\n    ROUND(\n        GREATEST(\n            LEAST(\n                m.match_end_time,\n                m.match_date + INTERVAL '17:00:00' HOUR TO SECOND\n            )\n            - GREATEST(\n                m.match_start_time,\n                m.match_date + INTERVAL '07:30:00' HOUR TO SECOND\n            ),\n            0\n        )\n        * 24\n        * 60\n    ) AS match_duration_minutes\nFROM match_dates m\nWHERE m.match_date - TRUNC(m.match_date, 'IW') < 5\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_50", "sol_sql": ["WITH \"t\" AS\n  (SELECT 1 AS \"from_hour\",\n          4 AS \"to_hour\",\n          20 AS \"pay\"\n   FROM dual\n   UNION ALL SELECT 5 AS \"from_hour\",\n                    8 AS \"to_hour\",\n                    50 AS \"pay\"\n   FROM dual\n   UNION ALL SELECT 10 AS \"from_hour\",\n                    12 AS \"to_hour\",\n                    100 AS \"pay\"\n   FROM dual),\n     \"input_data\" AS\n  (SELECT 6 AS \"user_hours\"\n   FROM dual)\nSELECT *\nFROM \"input_data\" \"i\" OUTER APPLY\n  (SELECT SUM((LEAST(\"t\".\"to_hour\", \"i\".\"user_hours\") - (\"t\".\"from_hour\" - 1)) * \"t\".\"pay\") AS \"sum_to_pay\"\n   FROM \"t\"\n   WHERE \"i\".\"user_hours\" >= \"t\".\"from_hour\")"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_51", "sol_sql": ["SELECT\n    \"molecule\".\"molecule_id\",\n    MIN(\"atom\".\"atom_id\") AS \"first_atom_id\"\nFROM \"molecule\"\nINNER JOIN \"atom\" ON \"molecule\".\"molecule_id\" = \"atom\".\"molecule_id\"\nGROUP BY \"molecule\".\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_52", "sol_sql": ["SELECT\n    m.\"molecule_id\",\n    m.\"label\",\n    a.\"atom_id\",\n    a.\"element\",\n    c.\"atom_id2\",\n    b.\"bond_id\",\n    b.\"bond_type\"\nFROM \"molecule\" m\nINNER JOIN \"atom\" a ON m.\"molecule_id\" = a.\"molecule_id\"\nINNER JOIN \"connected\" c ON a.\"atom_id\" = c.\"atom_id\"\nINNER JOIN \"bond\" b ON c.\"bond_id\" = b.\"bond_id\"\nORDER BY\n    m.\"molecule_id\",\n    a.\"atom_id\",\n    c.\"atom_id2\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_53", "sol_sql": ["SELECT \"home_team_api_id\" AS \"team_api_id\",\n       \"start_date\",\n       \"end_date\",\n       \"match_count\"\nFROM \"Match\" MATCH_RECOGNIZE (PARTITION BY \"home_team_api_id\"\n                              ORDER BY \"date\" MEASURES FIRST(\"date\") AS \"start_date\", LAST(\"date\") AS \"end_date\", COUNT(*) AS \"match_count\" PATTERN (consecutive_wins+) DEFINE consecutive_wins AS \"home_team_goal\" > \"away_team_goal\")"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_54", "sol_sql": ["SELECT\n    REPLACE(SUBSTR(\"date\", 1, INSTR(\"date\", '.', -1) - 1), '.')\n    || SUBSTR(\"date\", INSTR(\"date\", '.', -1)) AS \"updated_value\"\nFROM \"Team_Attributes\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_55", "sol_sql": ["SELECT\n    \"molecule\".\"molecule_id\",\n    \"molecule\".\"label\",\n    \"atom\".\"atom_id\",\n    \"atom\".\"element\",\n    \"bond\".\"bond_id\",\n    \"bond\".\"bond_type\"\nFROM \"molecule\"\nINNER JOIN \"atom\" ON \"molecule\".\"molecule_id\" = \"atom\".\"molecule_id\"\nINNER JOIN \"connected\" ON \"atom\".\"atom_id\" = \"connected\".\"atom_id\"\nINNER JOIN \"bond\" ON \"connected\".\"bond_id\" = \"bond\".\"bond_id\"\nORDER BY\n    \"molecule\".\"molecule_id\",\n    \"atom\".\"atom_id\",\n    \"bond\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_56", "sol_sql": ["SELECT\n    \"molecule\".\"molecule_id\",\n    LISTAGG(\"atom\".\"atom_id\", ',') WITHIN GROUP (\n        ORDER BY \"atom\".\"atom_id\"\n    ) AS \"atom_ids\"\nFROM \"molecule\"\nLEFT OUTER JOIN \"atom\" ON \"molecule\".\"molecule_id\" = \"atom\".\"molecule_id\"\nGROUP BY \"molecule\".\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_57", "sol_sql": ["SELECT *\nFROM\n    (SELECT\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY a.\"molecule_id\"\n            ORDER BY a.\"atom_id\"\n        ) AS rnk\n    FROM \"atom\" a)\nWHERE rnk <= 2\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_58", "sol_sql": ["SELECT\n    \"id\",\n    REGEXP_SUBSTR(\"date\", '[^ ]+', 1, LEVEL) AS \"date_part\"\nFROM \"Player_Attributes\" CONNECT BY LEVEL <= REGEXP_COUNT(\"date\", '[^ ]+')\nAND\nPRIOR \"id\" = \"id\"\nAND\nPRIOR SYS_GUID() IS NOT NULL\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_59", "sol_sql": ["SELECT\n    \"id\",\n    \"date\",\n    \"buildUpPlaySpeed\" AS old_value,\n    level,\n    LEAD(\"buildUpPlaySpeed\") OVER (\n        PARTITION BY \"team_api_id\"\n        ORDER BY \"date\"\n    ) AS new_value\nFROM \"Team_Attributes\" CONNECT BY\nPRIOR \"team_api_id\" = \"team_api_id\"\nAND\nPRIOR \"date\" < \"date\"\nAND\nPRIOR \"buildUpPlaySpeed\" = \"buildUpPlaySpeed\"\nSTART WITH NOT EXISTS\n(\n    SELECT *\n    FROM \"Team_Attributes\" t2\n    WHERE\n        t2.\"team_api_id\" = \"Team_Attributes\".\"team_api_id\"\n        AND t2.\"date\" < \"Team_Attributes\".\"date\"\n        AND t2.\"buildUpPlaySpeed\" = \"Team_Attributes\".\"buildUpPlaySpeed\"\n)\nORDER BY\n    \"team_api_id\",\n    \"date\",\n    level\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_60", "sol_sql": ["SELECT REGEXP_REPLACE('1110.400000.8001382', '\\.[^.]*$', '') AS \"output\"\nFROM dual\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_61", "sol_sql": ["SELECT\n    dates.\"month_start_date\",\n    m.\"molecule_id\",\n    m.\"label\"\nFROM\n    (\n        SELECT ADD_MONTHS(TO_DATE('01/01/2018', 'MM/DD/YYYY'), level - 1) AS \"month_start_date\"\n        FROM dual CONNECT BY level <= 12\n    ) dates\nINNER JOIN \"molecule\" m ON 1 = 1\nWHERE\n    dates.\"month_start_date\" BETWEEN TO_DATE(\n        '01/01/2018', 'MM/DD/YYYY'\n    ) AND TO_DATE('12/31/2018', 'MM/DD/YYYY')\nORDER BY\n    dates.\"month_start_date\",\n    m.\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_62", "sol_sql": ["WITH \"my_table\" AS\n  (SELECT 'A' AS \"cto\",\n          1 AS \"nif\",\n          'A1' AS \"file_\",\n          5 AS \"filesize\"\n   FROM dual\n   UNION ALL SELECT 'A' AS \"cto\",\n                    1 AS \"nif\",\n                    'A2' AS \"file_\",\n                    3 AS \"filesize\"\n   FROM dual\n   UNION ALL SELECT 'A' AS \"cto\",\n                    2 AS \"nif\",\n                    'A3' AS \"file_\",\n                    2 AS \"filesize\"\n   FROM dual\n   UNION ALL SELECT 'A' AS \"cto\",\n                    2 AS \"nif\",\n                    'A4' AS \"file_\",\n                    1 AS \"filesize\"\n   FROM dual\n   UNION ALL SELECT 'B' AS \"cto\",\n                    1 AS \"nif\",\n                    'B1' AS \"file_\",\n                    4 AS \"filesize\"\n   FROM dual\n   UNION ALL SELECT 'B' AS \"cto\",\n                    1 AS \"nif\",\n                    'B2' AS \"file_\",\n                    6 AS \"filesize\"\n   FROM dual)\nSELECT \"cto\",\n       \"nif\",\n       \"file_\",\n       \"partition\",\n       \"mn\" - \"first_mn\" + 1 AS \"subpartition\",\n       \"total_size\"\nFROM\n  (SELECT t.*,\n          ROW_NUMBER() OVER (PARTITION BY \"cto\"\n                             ORDER BY SUBSTR(\"file_\", 1, 1), TO_NUMBER(SUBSTR(\"file_\", 2))) AS \"rn\",\n          SUM(\"filesize\") OVER (PARTITION BY \"nif\") AS \"nif_size\"\n   FROM \"my_table\" t) MATCH_RECOGNIZE(PARTITION BY \"cto\"\n                                      ORDER BY \"rn\" MEASURES MATCH_NUMBER() AS \"mn\", SUM(\"filesize\") AS \"total_size\" ALL ROWS PER MATCH PATTERN ((same_nif* nif)* same_nif* end_nif) DEFINE same_nif AS \"nif\" = NEXT(\"nif\"), nif AS (NEXT(\"nif\") IS NULL\n                                                                                                                                                                                                                                     OR \"nif\" != NEXT(\"nif\"))\n                                      AND SUM(\"filesize\") + NEXT(\"nif_size\") <= 10, end_nif AS SUM(\"filesize\") <= 10) MATCH_RECOGNIZE(PARTITION BY \"cto\"\n                                                                                                                                      ORDER BY \"rn\" MEASURES MATCH_NUMBER() AS \"partition\", FIRST(\"mn\") AS \"first_mn\" ALL ROWS PER MATCH PATTERN ((same_nif* nif)+) DEFINE same_nif AS \"nif\" = NEXT(\"nif\"), nif AS (NEXT(\"nif\") IS NULL\n                                                                                                                                                                                                                                                                                                                    OR \"nif\" != NEXT(\"nif\"))\n                                                                                                                                      AND \"mn\" - FIRST(\"mn\") < 7)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_63", "sol_sql": ["WITH tbl AS (\n    SELECT TO_DATE('12.01.2023', 'dd.mm.yyyy') AS act_date\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('19.01.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('19.01.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('19.01.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('19.01.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('12.02.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('31.01.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('13.02.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('17.02.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('17.02.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('19.02.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('10.03.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('12.03.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('27.03.2023', 'dd.mm.yyyy')\n    FROM dual\n    UNION ALL\n    SELECT TO_DATE('10.04.2023', 'dd.mm.yyyy')\n    FROM dual\n),\n\nt2 AS (SELECT\n    TO_CHAR(t.act_date, 'MON-yy') AS act_month,\n    TO_CHAR(t.act_date, 'yyyymm') AS rn_2\nFROM tbl t\nGROUP BY\n    TO_CHAR(t.act_date, 'MON-yy'),\n    TO_CHAR(t.act_date, 'yyyymm')\nORDER BY TO_CHAR(t.act_date, 'yyyymm')\n),\n\ngrid AS (\n    SELECT\n        t1.activation_month,\n        t1.rn_1,\n        t2.act_month,\n        t2.rn_2\n    FROM\n        (SELECT\n            TO_CHAR(t.act_date, 'MON-yy') AS activation_month,\n            TO_CHAR(t.act_date, 'yyyymm') AS rn_1\n        FROM tbl t\n        GROUP BY\n            TO_CHAR(t.act_date, 'MON-yy'),\n            TO_CHAR(t.act_date, 'yyyymm')\n        ORDER BY TO_CHAR(t.act_date, 'yyyymm')) t1\n    LEFT JOIN\n        t2\n        ON (t1.rn_1 <= t2.rn_2)\n),\n\nmolecule_activity AS (\n    SELECT\n        m.\"molecule_id\",\n        TO_CHAR(t.act_date, 'yyyymm') AS act_date\n    FROM tbl t\n    INNER JOIN\n        \"molecule\"\n            m\n        ON\n            m.\"molecule_id\" IN\n            (\n                SELECT DISTINCT \"molecule_id\"\n                FROM \"bond\"\n                UNION\n                SELECT DISTINCT \"molecule_id\"\n                FROM \"atom\"\n            )\n)\n\nSELECT\n    g.activation_month,\n    g.act_month,\n    CASE\n        WHEN g.rn_1 = g.rn_2\n            THEN\n                (\n                    SELECT COUNT(DISTINCT ma.\"molecule_id\")\n                    FROM molecule_activity ma\n                    WHERE ma.act_date = g.rn_1\n                )\n        ELSE\n            (\n                SELECT COUNT(DISTINCT ma.\"molecule_id\")\n                FROM molecule_activity ma\n                WHERE ma.act_date BETWEEN g.rn_1 AND g.rn_2\n            )\n    END AS active_molecules\nFROM grid g\nORDER BY\n    g.rn_1,\n    g.rn_2\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_64", "sol_sql": ["WITH \"credits\" AS (\n    SELECT\n        5001 AS ID,\n        12 AS ARTCRED,\n        7.5 AS BIZCRED,\n        12 AS HUMCRED,\n        14 AS NATCRED,\n        11 AS TEKCRED,\n        9 AS GENCRED\n    FROM DUAL\n    UNION ALL\n    SELECT\n        5002 AS ID,\n        10.5 AS ARTCRED,\n        6 AS BIZCRED,\n        5 AS HUMCRED,\n        4 AS NATCRED,\n        6 AS TEKCRED,\n        3 AS GENCRED\n    FROM DUAL\n),\n\n\"grp_choices\" AS (\n    SELECT\n        5001 AS ID,\n        'ART' AS GROUPCHOICE,\n        TO_DATE('03.03.2010', 'dd.mm.yyyy') AS DATECHOICE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        5001 AS ID,\n        'BIZ' AS GROUPCHOICE,\n        TO_DATE('05.05.2015', 'dd.mm.yyyy') AS DATECHOICE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        5001 AS ID,\n        'NAT' AS GROUPCHOICE,\n        TO_DATE('23.06.2022', 'dd.mm.yyyy') AS DATECHOICE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        5002 AS ID,\n        'ART' AS GROUPCHOICE,\n        TO_DATE('23.06.2023', 'dd.mm.yyyy') AS DATECHOICE\n    FROM DUAL\n)\n\nSELECT\n    C.ID,\n    G.GROUPCHOICE,\n    CASE G.GROUPCHOICE\n        WHEN 'ART' THEN C.ARTCRED\n        WHEN 'BIZ' THEN C.BIZCRED\n        WHEN 'HUM' THEN C.HUMCRED\n        WHEN 'NAT' THEN C.NATCRED\n        WHEN 'TEK' THEN C.TEKCRED\n        WHEN 'GEN' THEN C.GENCRED\n        ELSE 0\n    END AS CREDIT\nFROM \"credits\" C\nINNER JOIN \"grp_choices\" G ON C.ID = G.ID\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_65", "sol_sql": ["WITH molecule_atoms AS (\n    SELECT\n        \"molecule_id\",\n        COUNT(\"atom_id\") AS atom_count\n    FROM \"atom\"\n    GROUP BY \"molecule_id\"\n)\n\nSELECT\n    \"molecule_id\",\n    level AS atom_number\nFROM molecule_atoms CONNECT BY level <= atom_count\nAND\nPRIOR \"molecule_id\" = \"molecule_id\"\nAND\nPRIOR SYS_GUID() IS NOT NULL\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_66", "sol_sql": ["SELECT\n    \"team_api_id\",\n    \"buildUpPlaySpeed\",\n    \"date\"\nFROM\n    (SELECT\n        \"team_api_id\",\n        \"buildUpPlaySpeed\",\n        \"date\",\n        ROW_NUMBER() OVER (\n            PARTITION BY \"team_api_id\"\n            ORDER BY \"date\" DESC\n        ) AS seq\n    FROM \"Team_Attributes\")\nWHERE seq = 1\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_67", "sol_sql": ["with \"test\" (\n    \"col1\",\n    \"col2\",\n    \"col3\") as (\n    select\n        'pers1',\n        'nom',\n        'Aurelie'\n    from dual\n    union all\n    select\n        'pers1',\n        'prenom',\n        'Dupont'\n    from dual\n    union all\n    select\n        'pers1',\n        'age',\n        '25'\n    from dual\n    union all\n    select\n        'pers2',\n        'nom',\n        'Stephane'\n    from dual\n    union all\n    select\n        'pers2',\n        'prenom',\n        'Blanc'\n    from dual\n    union all\n    select\n        'pers2',\n        'age',\n        '45'\n    from dual\n)\n\nselect\n    \"col1\",\n    max(case\n        when \"col2\" = 'nom' then \"col3\"\n    end) as \"nom\",\n    max(case\n        when \"col2\" = 'prenom' then \"col3\"\n    end) as \"prenom\",\n    max(case\n        when \"col2\" = 'age' then \"col3\"\n    end) as \"age\"\nfrom \"test\"\ngroup by \"col1\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_68", "sol_sql": ["SELECT\n    \"m\".\"date\" AS \"match_date\",\n    \"l\".\"name\" AS \"league_name\",\n    \"c\".\"name\" AS \"country_name\",\n    \"ht\".\"team_long_name\" AS \"home_team\",\n    \"at\".\"team_long_name\" AS \"away_team\",\n    \"m\".\"home_team_goal\" AS \"home_team_goals\",\n    \"m\".\"away_team_goal\" AS \"away_team_goals\"\nFROM \"Match\" \"m\"\nINNER JOIN \"League\" \"l\" ON \"m\".\"league_id\" = \"l\".\"id\"\nINNER JOIN \"Country\" \"c\" ON \"l\".\"country_id\" = \"c\".\"id\"\nINNER JOIN \"Team\" \"ht\" ON \"m\".\"home_team_api_id\" = \"ht\".\"team_api_id\"\nINNER JOIN \"Team\" \"at\" ON \"m\".\"away_team_api_id\" = \"at\".\"team_api_id\"\nORDER BY \"m\".\"date\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_69", "sol_sql": ["WITH MY_TABLE AS (\n    SELECT\n        '1111' AS TECHNICAL_ID,\n        'NOTIONALCR' AS ASSET_TYPE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        '1111' AS TECHNICAL_ID,\n        '50000' AS ASSET_TYPE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        '2222' AS TECHNICAL_ID,\n        'FWDNOTLCR' AS ASSET_TYPE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        '2222' AS TECHNICAL_ID,\n        '50000' AS ASSET_TYPE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        '3333' AS TECHNICAL_ID,\n        '50000' AS ASSET_TYPE\n    FROM DUAL\n    UNION ALL\n    SELECT\n        '3333' AS TECHNICAL_ID,\n        'DUMMY' AS ASSET_TYPE\n    FROM DUAL\n),\n\nMAP_RECRF_ASSET_TYPE AS (\n    SELECT\n        'SW' AS APPLICATION,\n        'NOTIONALCR' AS ASSET_TYPE,\n        1 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'NOTIONALDB' AS ASSET_TYPE,\n        1 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'FWDNOTLCR' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'FWDNOTLDR' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'SWOFFBALCR' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'SWOFFBALDR' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'SWFWNOTLCR' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        'SWFWNOTLDB' AS ASSET_TYPE,\n        2 AS PRIORITY\n    FROM DUAL\n    UNION ALL\n    SELECT\n        'SW' AS APPLICATION,\n        '50000' AS ASSET_TYPE,\n        3 AS PRIORITY\n    FROM DUAL\n),\n\nCTE AS (\n    SELECT\n        X.TECHNICAL_ID,\n        X.ASSET_TYPE,\n        ROW_NUMBER() OVER (\n            PARTITION BY X.TECHNICAL_ID\n            ORDER BY MRAT.PRIORITY\n        ) AS \"rn\"\n    FROM MY_TABLE X\n    INNER JOIN MAP_RECRF_ASSET_TYPE MRAT ON X.ASSET_TYPE = MRAT.ASSET_TYPE\n    WHERE MRAT.APPLICATION = 'SW'\n)\n\nSELECT\n    TECHNICAL_ID,\n    ASSET_TYPE\nFROM CTE\nWHERE \"rn\" = 1\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_70", "sol_sql": ["SELECT\n    \"country_id\",\n    MAX(CASE\n        WHEN \"rn\" = 1 THEN \"date\"\n    END) AS \"last_match_date\",\n    MAX(CASE\n        WHEN \"rn\" = 2 THEN \"date\"\n    END) AS \"prev_match_date\"\nFROM\n    (SELECT\n        \"country_id\",\n        \"date\",\n        ROW_NUMBER() OVER (\n            PARTITION BY \"country_id\"\n            ORDER BY \"date\" DESC\n        ) AS \"rn\"\n    FROM \"Match\")\nWHERE \"rn\" <= 2\nGROUP BY \"country_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_71", "sol_sql": ["SELECT\n    \"atom\".\"atom_id\",\n    \"atom\".\"molecule_id\",\n    \"atom\".\"element\",\n    \"bond\".\"bond_id\",\n    \"bond\".\"bond_type\"\nFROM \"atom\"\nLEFT JOIN \"connected\" ON \"atom\".\"atom_id\" = \"connected\".\"atom_id\"\nLEFT JOIN \"bond\" ON \"connected\".\"bond_id\" = \"bond\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_72", "sol_sql": ["SELECT\n    \"m\".\"id\",\n    \"m\".\"home_team_api_id\",\n    \"m\".\"away_team_api_id\",\n    \"m\".\"home_team_goal\",\n    \"m\".\"away_team_goal\",\n    SUM(CASE\n        WHEN\n            \"m\".\"home_team_api_id\" = \"t\".\"team_api_id\"\n            THEN \"m\".\"home_team_goal\" - \"m\".\"away_team_goal\"\n        ELSE \"m\".\"away_team_goal\" - \"m\".\"home_team_goal\"\n    END) OVER (\n        PARTITION BY \"t\".\"team_api_id\"\n        ORDER BY \"m\".\"id\"\n    ) AS \"goal_difference\"\nFROM \"Match\" \"m\"\nINNER JOIN \"Team\" \"t\"\n    ON\n        \"m\".\"home_team_api_id\" = \"t\".\"team_api_id\"\n        OR \"m\".\"away_team_api_id\" = \"t\".\"team_api_id\"\nORDER BY\n    \"t\".\"team_api_id\",\n    \"m\".\"id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_73", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"b\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_74", "sol_sql": ["SELECT\n    T.\"team_long_name\",\n    T.\"team_short_name\",\n    TA.\"buildUpPlaySpeed\",\n    TA.\"buildUpPlaySpeedClass\",\n    TA.\"chanceCreationShooting\",\n    TA.\"chanceCreationShootingClass\",\n    TA.\"defencePressure\",\n    TA.\"defencePressureClass\"\nFROM \"Team\" T\nINNER JOIN \"Team_Attributes\" TA ON T.\"team_api_id\" = TA.\"team_api_id\"\nWHERE TA.\"date\" = TO_DATE('2013-09-20 00:00:00', 'YYYY-MM-DD HH24:MI:SS')\n", "SELECT *\nFROM TABLE(DBMS_XPLAN.display_cursor(format => 'adaptive'))\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_75", "sol_sql": ["SELECT \"valid_from\",\n       \"valid_until\",\n       \"count\"\nFROM\n  (SELECT \"dt\" AS \"valid_from\",\n          LEAD(\"dt\") OVER (\n                           ORDER BY \"dt\") - INTERVAL '1' SECOND AS \"valid_until\",\n          SUM(\"count\" * \"type\") OVER (\n                                      ORDER BY \"dt\") AS \"count\"\n   FROM\n     (SELECT \"valid_from\",\n             \"valid_until\" + INTERVAL '1' DAY AS \"valid_until\",\n             1 AS \"count\"\n      FROM\n        (SELECT TO_DATE('2014-01-01', 'YYYY-MM-DD') AS \"valid_from\",\n                TO_DATE('2014-01-31', 'YYYY-MM-DD') AS \"valid_until\"\n         FROM DUAL\n         UNION ALL SELECT TO_DATE('2014-02-01', 'YYYY-MM-DD') AS \"valid_from\",\n                          TO_DATE('2014-02-28', 'YYYY-MM-DD') AS \"valid_until\"\n         FROM DUAL)) UNPIVOT INCLUDE NULLS (\"dt\"\n                                            FOR \"type\" IN (\"valid_from\" AS 1, \"valid_until\" AS -1)))\nWHERE \"count\" > 0\n  AND (\"valid_from\" <= \"valid_until\"\n       OR \"valid_until\" IS NULL)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_76", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"c\".\"atom_id2\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"c\".\"atom_id2\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_77", "sol_sql": ["SELECT\n    \"col2\",\n    LISTAGG(DISTINCT \"col3\", ', ') WITHIN GROUP (\n        ORDER BY \"col3\"\n    ) AS \"col3\"\nFROM\n    (SELECT\n        '11-11' AS \"pk\",\n        1 AS \"col2\",\n        'str1' AS \"col3\",\n        TO_DATE('2024/09/04 00:00', 'yyyy/mm/dd hh24:mi') AS \"col4\"\n    FROM dual\n    UNION ALL\n    SELECT\n        '22-22',\n        2,\n        'str2',\n        TO_DATE('2024/09/04 00:01', 'yyyy/mm/dd hh24:mi')\n    FROM dual\n    UNION ALL\n    SELECT\n        '33-33',\n        1,\n        'str2',\n        TO_DATE('2024/09/04 00:02', 'yyyy/mm/dd hh24:mi')\n    FROM dual\n    UNION ALL\n    SELECT\n        '44-44',\n        4,\n        'str4',\n        TO_DATE('2024/09/04 00:03', 'yyyy/mm/dd hh24:mi')\n    FROM dual\n    UNION ALL\n    SELECT\n        '55-55',\n        1,\n        'str7',\n        TO_DATE('2024/09/04 00:04', 'yyyy/mm/dd hh24:mi')\n    FROM dual\n    UNION ALL\n    SELECT\n        '44-44',\n        2,\n        'str3',\n        TO_DATE('2024/09/04 00:04', 'yyyy/mm/dd hh24:mi')\n    FROM dual\n    UNION ALL\n    SELECT\n        '55-55',\n        1,\n        'str1',\n        TO_DATE('2024/09/04 00:01', 'yyyy/mm/dd hh24:mi')\n    FROM dual)\nWHERE\n    \"col4\" >= TO_DATE('2024/09/04 00:00', 'yyyy/mm/dd hh24:mi')\n    AND \"col4\" < TO_DATE('2024/09/04 00:05', 'yyyy/mm/dd hh24:mi')\nGROUP BY \"col2\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_78", "sol_sql": ["SELECT\n    \"molecule\".\"molecule_id\",\n    \"molecule\".\"label\",\n    \"atom\".\"atom_id\",\n    \"atom\".\"element\",\n    \"bond\".\"bond_id\",\n    \"bond\".\"bond_type\",\n    \"connected\".\"atom_id2\"\nFROM \"molecule\"\nINNER JOIN \"atom\" ON \"molecule\".\"molecule_id\" = \"atom\".\"molecule_id\"\nINNER JOIN \"connected\" ON \"atom\".\"atom_id\" = \"connected\".\"atom_id\"\nINNER JOIN \"bond\" ON \"connected\".\"bond_id\" = \"bond\".\"bond_id\"\nORDER BY\n    \"molecule\".\"molecule_id\",\n    \"atom\".\"atom_id\",\n    \"connected\".\"atom_id2\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_79", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"b\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_80", "sol_sql": ["SELECT\n    m.\"molecule_id\",\n    COUNT(a.\"atom_id\") / COUNT(DISTINCT b.\"bond_id\") AS result\nFROM \"molecule\" m\nINNER JOIN \"atom\" a ON m.\"molecule_id\" = a.\"molecule_id\"\nINNER JOIN \"connected\" c ON a.\"atom_id\" = c.\"atom_id\"\nINNER JOIN \"bond\" b ON c.\"bond_id\" = b.\"bond_id\"\nGROUP BY m.\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_81", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\" AS ID,\n    COUNT(DISTINCT \"a\".\"atom_id\") AS QTY,\n    COUNT(DISTINCT \"b\".\"bond_id\") AS VALUE\nFROM \"molecule\" \"m\"\nLEFT JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nLEFT JOIN \"bond\" \"b\" ON \"m\".\"molecule_id\" = \"b\".\"molecule_id\"\nGROUP BY \"m\".\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_82", "sol_sql": ["SELECT\n    COALESCE(a.\"atom_id\", b.\"bond_id\") AS \"id\",\n    COALESCE(a.\"molecule_id\", b.\"molecule_id\") AS \"molecule_id\",\n    COALESCE(a.\"element\", b.\"bond_type\") AS \"val\"\nFROM \"atom\" a\nFULL OUTER JOIN \"bond\" b ON a.\"molecule_id\" = b.\"molecule_id\"\nORDER BY\n    \"id\",\n    \"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_83", "sol_sql": ["WITH data AS (\n    SELECT\n        101 AS \"id\",\n        'A' AS \"type\",\n        10 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        101 AS \"id\",\n        'B' AS \"type\",\n        10 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        101 AS \"id\",\n        'B' AS \"type\",\n        10 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        101 AS \"id\",\n        'B' AS \"type\",\n        20 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        101 AS \"id\",\n        'C' AS \"type\",\n        30 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        102 AS \"id\",\n        'A' AS \"type\",\n        10 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        102 AS \"id\",\n        'B' AS \"type\",\n        25 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        103 AS \"id\",\n        'A' AS \"type\",\n        25 AS \"part\"\n    FROM dual\n    UNION ALL\n    SELECT\n        103 AS \"id\",\n        'B' AS \"type\",\n        25 AS \"part\"\n    FROM dual\n),\n\nw_cnt AS (\n    SELECT\n        \"id\",\n        \"part\",\n        COUNT(*) AS \"cnt\"\n    FROM data\n    GROUP BY\n        \"id\",\n        \"part\"\n    HAVING COUNT(*) > 1\n)\n\nSELECT\n    d.\"id\",\n    d.\"type\",\n    d.\"part\"\nFROM data d\nINNER JOIN w_cnt\n    w ON d.\"id\" = w.\"id\"\nAND d.\"part\" = w.\"part\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_84", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"c\".\"atom_id2\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"c\".\"atom_id2\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_85", "sol_sql": ["WITH columns (\n    column_name) AS (\n    SELECT 'CDSCode'\n    FROM dual\n    UNION ALL\n    SELECT 'StatusType'\n    FROM dual\n    UNION ALL\n    SELECT 'School'\n    FROM dual\n),\n\ncolumn_exists (column_name, column_exists) AS (\n    SELECT\n        c.column_name,\n        NVL2(a.column_name, 'YES', 'NO')\n    FROM columns c\n    LEFT OUTER JOIN all_tab_columns a\n        ON (\n            a.table_name = 'SCHOOLS'\n            AND c.column_name = a.column_name\n        )\n)\n\nSELECT *\nFROM\n    column_exists PIVOT (\n    MAX(column_exists)\n    FOR column_name IN (\n        'CDSCode' AS cdscode,\n        'StatusType' AS statustype,\n        'School' AS school\n    )\n)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_86", "sol_sql": ["WITH replacements (\"molecule_id\", \"label\", \"spos\") AS\n  (SELECT \"molecule_id\",\n          \"label\",\n          1\n   FROM \"molecule\"\n   UNION ALL SELECT \"molecule_id\",\n                    SUBSTR(\"label\", 1, \"spos\" - 1) || '-' || SUBSTR(\"label\", \"spos\" + 1),\n                    REGEXP_INSTR(\"label\", '\\+', \"spos\" + 1, 1, 1) - 1\n   FROM replacements\n   WHERE \"spos\" > 0) SEARCH DEPTH FIRST BY \"molecule_id\"\nSET order_id\nSELECT \"molecule_id\",\n       \"label\"\nFROM replacements\nWHERE \"spos\" <= 0"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_87", "sol_sql": ["WITH a (\n    \"test\") AS (\n    SELECT 'Jack|Sparrow|17-09-16|DY7009|Address at some where|details '\n    FROM dual\n    UNION ALL\n    SELECT 'Jack|Sparrow|17-09-16|DY7009|'\n    FROM dual\n    UNION ALL\n    SELECT 'Jack|Sparrow|17-09-16'\n    FROM dual\n)\n\nSELECT\n    \"test\",\n    REGEXP_SUBSTR(\"test\", '([^|]+\\|?){1,5}') AS \"res\"\nFROM a\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_88", "sol_sql": ["SELECT\n    m.\"molecule_id\",\n    m.\"label\",\n    a.\"atom_id\",\n    a.\"element\",\n    b.\"bond_id\",\n    b.\"bond_type\"\nFROM \"molecule\" m\nINNER JOIN \"atom\" a ON m.\"molecule_id\" = a.\"molecule_id\"\nINNER JOIN \"connected\" c ON a.\"atom_id\" = c.\"atom_id\"\nINNER JOIN \"bond\" b ON c.\"bond_id\" = b.\"bond_id\"\nORDER BY\n    m.\"molecule_id\",\n    a.\"atom_id\",\n    b.\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_89", "sol_sql": ["SELECT\n    m1.\"molecule_id\",\n    m2.\"molecule_id\"\nFROM \"molecule\" m1\nINNER JOIN \"molecule\" m2 ON (\n    m1.\"molecule_id\",\n    m2.\"molecule_id\") IN ((\n    'TR427',\n    'TR430'), ('TR427',\n'TR431'), (\n    'TR430',\n    'TR431'\n)\n)\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_90", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"atom_id\",\n    \"a\".\"element\",\n    \"b\".\"bond_id\",\n    \"b\".\"bond_type\",\n    \"c\".\"atom_id2\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nINNER JOIN \"connected\" \"c\" ON \"a\".\"atom_id\" = \"c\".\"atom_id\"\nINNER JOIN \"bond\" \"b\" ON \"c\".\"bond_id\" = \"b\".\"bond_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\",\n    \"b\".\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_91", "sol_sql": ["WITH string1_tab AS (\n    SELECT REGEXP_SUBSTR('24,36,78,98', '[^,]+', 1, level) AS value\n    FROM dual CONNECT BY level\n    <= LENGTH('24,36,78,98') - LENGTH(REPLACE('24,36,78,98', ',')) + 1\n),\n\nstring2_tab AS (\n    SELECT REGEXP_SUBSTR('25,36,88,98', '[^,]+', 1, level) AS value\n    FROM dual CONNECT BY level\n    <= LENGTH('25,36,88,98') - LENGTH(REPLACE('25,36,88,98', ',')) + 1\n)\n\nSELECT *\nFROM string1_tab\nINTERSECT\nSELECT *\nFROM string2_tab\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_92", "sol_sql": ["WITH t AS (\n    SELECT\n        \"date\",\n        \"match_api_id\" AS code,\n        TRUNC(SYSDATE)\n        - TRUNC(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')) AS duration,\n        COUNT(*)\n            OVER (\n                PARTITION BY\n                    TRUNC(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')),\n                    \"match_api_id\",\n                    TRUNC(SYSDATE)\n                    - TRUNC(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS'))\n            )\n            AS cnt,\n        MIN(TRUNC(SYSDATE) - TRUNC(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')))\n            OVER (\n                PARTITION BY\n                    TRUNC(TO_DATE(\"date\", 'YYYY-MM-DD HH24:MI:SS')),\n                    \"match_api_id\"\n            )\n            AS min_dur\n    FROM \"Match\"\n)\n\nSELECT\n    t.\"date\",\n    t.code,\n    t.duration,\n    CASE\n        WHEN\n            t.min_dur = 0\n            OR MAX(t.cnt) OVER (PARTITION BY t.\"date\", t.code) > 1 THEN 'Y'\n        ELSE 'N'\n    END AS flg\nFROM t\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_93", "sol_sql": ["SELECT\n    \"m\".\"molecule_id\",\n    \"m\".\"label\",\n    \"a\".\"element\"\nFROM \"molecule\" \"m\"\nINNER JOIN \"atom\" \"a\" ON \"m\".\"molecule_id\" = \"a\".\"molecule_id\"\nORDER BY\n    \"m\".\"molecule_id\",\n    \"a\".\"atom_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_94", "sol_sql": ["SELECT\n    b.*,\n    GREATEST(ADD_MONTHS(TRUNC(SYSDATE - 1, 'MM') + 1, m.months), SYSDATE)\n        AS bond_formation_date\nFROM \"bond\" b\nCROSS JOIN\n    LATERAL\n    (\n        SELECT level - 1 AS months\n        FROM dual CONNECT BY level - 1 <= 5\n    ) m\nWHERE b.\"molecule_id\" = 'TR011'\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_95", "sol_sql": ["SELECT\n    JSON_OBJECT(\n        KEY 'country_id'\n        || \"country_id\" VALUE JSON_ARRAYAGG(\n            JSON_OBJECT(\n                KEY 'date' VALUE \"date\",\n                KEY 'home_team_goal' VALUE \"home_team_goal\",\n                KEY 'away_team_goal' VALUE \"away_team_goal\" RETURNING CLOB\n            ) RETURNING CLOB\n        ) RETURNING CLOB\n    ) AS JSON\nFROM \"Match\"\nGROUP BY \"country_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_96", "sol_sql": ["SELECT\n    m.\"molecule_id\",\n    m.\"label\",\n    a.\"atom_id\",\n    a.\"element\",\n    b.\"bond_id\",\n    b.\"bond_type\"\nFROM \"molecule\" m\nLEFT OUTER JOIN \"atom\" a ON m.\"molecule_id\" = a.\"molecule_id\"\nLEFT OUTER JOIN \"connected\" c ON a.\"atom_id\" = c.\"atom_id\"\nLEFT OUTER JOIN \"bond\" b ON c.\"bond_id\" = b.\"bond_id\"\nORDER BY\n    m.\"molecule_id\",\n    a.\"atom_id\",\n    b.\"bond_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_97", "sol_sql": ["SELECT\n    \"molecule\".\"molecule_id\",\n    COUNT(\"atom\".\"atom_id\") AS \"total_atoms\"\nFROM \"molecule\"\nINNER JOIN \"atom\" ON \"molecule\".\"molecule_id\" = \"atom\".\"molecule_id\"\nGROUP BY \"molecule\".\"molecule_id\"\nORDER BY \"molecule\".\"molecule_id\"\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_98", "sol_sql": ["SELECT\n    \"m\".\"id\",\n    \"m\".\"date\",\n    \"m\".\"home_team_api_id\",\n    \"m\".\"away_team_api_id\",\n    \"m\".\"home_team_goal\",\n    \"m\".\"away_team_goal\"\nFROM \"Match\" \"m\"\nINNER JOIN \"Team_Attributes\" \"ta\" ON \"m\".\"home_team_api_id\" = \"ta\".\"team_api_id\"\nWHERE\n    \"ta\".\"buildUpPlaySpeed\"\n    > (\n        SELECT AVG(\"buildUpPlaySpeed\")\n        FROM \"Team_Attributes\"\n    )\nORDER BY \"m\".\"home_team_goal\" DESC\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "Oracle_99", "sol_sql": ["with lose_agg as (\n    select\n        \"team_api_id\",\n        sum(case\n            when\n                to_number(to_char(\"date\", 'YYYY')) = 2011\n                then \"defencePressure\"\n        end) as lose_5,\n        sum(case\n            when\n                to_number(to_char(\"date\", 'YYYY')) = 2012\n                then \"defencePressure\"\n        end) as lose_10\n    from \"Team_Attributes\"\n    group by \"team_api_id\"\n),\n\nprofit_agg as (\n    select\n        \"team_api_id\",\n        sum(case\n            when\n                to_number(to_char(\"date\", 'YYYY')) = 2011\n                then \"buildUpPlaySpeed\"\n        end) as profit_5,\n        sum(case\n            when\n                to_number(to_char(\"date\", 'YYYY')) = 2012\n                then \"buildUpPlaySpeed\"\n        end) as profit_10\n    from \"Team_Attributes\"\n    group by \"team_api_id\"\n)\n\nselect\n    l.lose_5,\n    p.profit_5,\n    l.lose_10,\n    p.profit_10,\n    coalesce(p.\"team_api_id\", l.\"team_api_id\") as \"team_api_id\"\nfrom lose_agg l\nfull outer join profit_agg p on l.\"team_api_id\" = p.\"team_api_id\"\norder by coalesce(p.\"team_api_id\", l.\"team_api_id\")\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
